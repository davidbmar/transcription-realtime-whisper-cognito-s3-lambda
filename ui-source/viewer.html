<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Transcript Viewer - CloudDrive</title>
    <link rel="stylesheet" href="viewer-styles.css">
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <div class="viewer-container">
        <!-- Header -->
        <div class="viewer-header">
            <div class="header-left">
                <h1><i class="fas fa-eye"></i> Live Transcript Viewer</h1>
                <div class="session-info" id="session-info">
                    <span class="status-badge" id="status-badge">
                        <i class="fas fa-circle"></i> Connecting...
                    </span>
                    <span id="session-id-display">Session: Loading...</span>
                    <span id="duration-display">Duration: 00:00:00</span>
                </div>
            </div>
            <div class="header-right">
                <button class="btn btn-secondary" onclick="toggleAutoScroll()" id="autoscroll-btn">
                    <i class="fas fa-arrow-down"></i> Auto-scroll: ON
                </button>
                <button class="btn btn-secondary" onclick="copyTranscript()">
                    <i class="fas fa-copy"></i> Copy
                </button>
                <button class="btn btn-secondary" onclick="downloadTranscript()">
                    <i class="fas fa-download"></i> Download
                </button>
                <button class="btn btn-primary" onclick="refreshNow()">
                    <i class="fas fa-sync"></i> Refresh
                </button>
                <a href="/" class="btn btn-secondary">
                    <i class="fas fa-arrow-left"></i> Dashboard
                </a>
            </div>
        </div>

        <!-- Transcript Display -->
        <div class="transcript-wrapper">
            <div class="transcript-container" id="transcript">
                <div class="transcript-loading">
                    <i class="fas fa-spinner fa-spin"></i>
                    <p>Loading transcript...</p>
                </div>
            </div>
        </div>

        <!-- Stats Footer -->
        <div class="viewer-footer">
            <div class="stat">
                <i class="fas fa-comment-dots"></i>
                <span id="segment-count">0</span> segments
            </div>
            <div class="stat">
                <i class="fas fa-font"></i>
                <span id="word-count">0</span> words
            </div>
            <div class="stat">
                <i class="fas fa-sync"></i>
                Last updated: <span id="last-update">Never</span>
            </div>
            <div class="stat">
                <i class="fas fa-clock"></i>
                Polling every <span id="poll-interval">3</span>s
            </div>
        </div>
    </div>

    <script>
        // Configuration - will be replaced by deployment script
        const config = {
            userPoolId: 'YOUR_USER_POOL_ID',
            userPoolClientId: 'YOUR_USER_POOL_CLIENT_ID',
            identityPoolId: 'YOUR_IDENTITY_POOL_ID',
            region: 'YOUR_REGION',
            apiUrl: 'YOUR_CLOUDFRONT_API_ENDPOINT',
            appUrl: 'YOUR_CLOUDFRONT_URL'
        };

        // Viewer state
        const viewerState = {
            sessionId: null,
            userId: null,
            sessionPath: null,
            lastLoadedChunk: 0,
            transcriptionStatus: "pending",
            segments: [],
            pollInterval: null,
            pollFrequency: 3000, // 3 seconds
            autoScrollEnabled: true,
            sessionStartTime: null,
            durationInterval: null
        };

        // Parse URL parameters
        function getUrlParams() {
            const params = new URLSearchParams(window.location.search);
            return {
                sessionId: params.get('sessionId'),
                userId: params.get('userId')
            };
        }

        // Get auth token
        function getAuthToken() {
            return localStorage.getItem('id_token');
        }

        // Get user from token
        function getUserFromToken() {
            const token = getAuthToken();
            if (!token) return null;

            try {
                const payload = JSON.parse(atob(token.split('.')[1]));
                return {
                    email: payload.email,
                    userId: payload.sub,
                    name: payload.given_name || payload.email
                };
            } catch (error) {
                console.error('Error parsing token:', error);
                return null;
            }
        }

        // Fetch file from S3 via CloudDrive API
        async function fetchFromS3(key) {
            const token = getAuthToken();
            if (!token) {
                throw new Error('Not authenticated');
            }

            const encodedKey = encodeURIComponent(key);

            const response = await fetch(`${config.apiUrl}/api/s3/download/${encodedKey}`, {
                headers: {
                    'Authorization': `Bearer ${token}`
                }
            });

            if (!response.ok) {
                const error = new Error('S3 fetch failed');
                error.statusCode = response.status;
                throw error;
            }

            // API returns presigned URL, fetch actual content
            const data = await response.json();
            const contentResponse = await fetch(data.downloadUrl);
            return await contentResponse.text();
        }

        // Fetch metadata to check session status
        async function fetchMetadata() {
            const key = `${viewerState.sessionPath}metadata.json`;
            try {
                const response = await fetchFromS3(key);
                return JSON.parse(response);
            } catch (error) {
                if (error.statusCode === 404) {
                    return null; // Session not started yet
                }
                throw error;
            }
        }

        // Load new transcription chunks
        async function loadNewChunks() {
            const newSegments = [];
            let chunkIndex = viewerState.lastLoadedChunk + 1;

            // Try to load next chunks until we hit a 404
            while (true) {
                const paddedIndex = String(chunkIndex).padStart(3, '0');
                const key = `${viewerState.sessionPath}transcription-chunk-${paddedIndex}.json`;

                try {
                    const response = await fetchFromS3(key);
                    const chunkData = JSON.parse(response);

                    // Extract segments from chunk
                    if (chunkData.segments && Array.isArray(chunkData.segments)) {
                        newSegments.push(...chunkData.segments);
                    }
                    viewerState.lastLoadedChunk = chunkIndex;
                    chunkIndex++;

                } catch (error) {
                    if (error.statusCode === 404) {
                        // No more chunks available yet
                        break;
                    } else {
                        console.error(`Error loading chunk ${chunkIndex}:`, error);
                        break; // Stop on error
                    }
                }
            }

            return newSegments;
        }

        // Load final consolidated transcription
        async function loadFinalTranscription() {
            const key = `${viewerState.sessionPath}transcription.json`;
            try {
                const response = await fetchFromS3(key);
                const data = JSON.parse(response);

                // Replace all segments with final version
                viewerState.segments = data.segments || [];
                displayFullTranscript();
                updateStats();

                console.log('Loaded final transcription:', data.totalSegments, 'segments');
            } catch (error) {
                console.error('Error loading final transcription:', error);
            }
        }

        // Main polling loop
        async function pollTranscription() {
            try {
                // Step 1: Check session status
                const metadata = await fetchMetadata();

                if (!metadata) {
                    console.log('Session metadata not found yet, waiting...');
                    updateStatus('waiting', 'Waiting for recording to start...');
                    return;
                }

                viewerState.transcriptionStatus = metadata.transcriptionStatus || "pending";

                // Update session start time for duration display
                if (!viewerState.sessionStartTime && metadata.createdAt) {
                    viewerState.sessionStartTime = new Date(metadata.createdAt);
                }

                if (viewerState.transcriptionStatus === "completed") {
                    // Session ended, load final consolidated transcription
                    updateStatus('completed', 'Recording completed');
                    await loadFinalTranscription();
                    stopPolling();
                    return;
                }

                // Step 2: Load new chunks (if still recording)
                updateStatus('active', 'Recording...');
                const newSegments = await loadNewChunks();

                if (newSegments.length > 0) {
                    // Step 3: Append to transcript display
                    appendSegments(newSegments);
                    autoScroll();
                    updateStats();
                }

                updateLastUpdateTime();

            } catch (error) {
                console.error("Polling error:", error);
                updateStatus('error', 'Error loading transcript');
                // Continue polling even on error
            }
        }

        // Append segments to display
        function appendSegments(segments) {
            const container = document.getElementById('transcript');

            // Remove loading message if present
            const loading = container.querySelector('.transcript-loading');
            if (loading) {
                loading.remove();
            }

            segments.forEach(segment => {
                const div = document.createElement('div');
                div.className = 'transcript-segment';
                if (segment.paragraph_break) {
                    div.classList.add('paragraph-break');
                }

                const timestamp = document.createElement('span');
                timestamp.className = 'timestamp';
                timestamp.textContent = formatTimestamp(segment.start || 0);

                const text = document.createElement('span');
                text.className = 'text';
                text.textContent = segment.text || '';

                div.appendChild(timestamp);
                div.appendChild(text);
                container.appendChild(div);
            });

            viewerState.segments.push(...segments);
        }

        // Display full transcript (for finalized sessions)
        function displayFullTranscript() {
            const container = document.getElementById('transcript');
            container.innerHTML = ''; // Clear existing

            viewerState.segments.forEach(segment => {
                const div = document.createElement('div');
                div.className = 'transcript-segment';
                if (segment.paragraph_break) {
                    div.classList.add('paragraph-break');
                }

                const timestamp = document.createElement('span');
                timestamp.className = 'timestamp';
                timestamp.textContent = formatTimestamp(segment.start || 0);

                const text = document.createElement('span');
                text.className = 'text';
                text.textContent = segment.text || '';

                div.appendChild(timestamp);
                div.appendChild(text);
                container.appendChild(div);
            });
        }

        // Format timestamp
        function formatTimestamp(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            return `[${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}]`;
        }

        // Update status badge
        function updateStatus(status, message) {
            const badge = document.getElementById('status-badge');
            badge.className = 'status-badge ' + status;

            const icon = {
                'waiting': 'fa-hourglass-half',
                'active': 'fa-circle',
                'completed': 'fa-check-circle',
                'error': 'fa-exclamation-triangle'
            }[status] || 'fa-circle';

            badge.innerHTML = `<i class="fas ${icon}"></i> ${message}`;
        }

        // Update stats
        function updateStats() {
            document.getElementById('segment-count').textContent = viewerState.segments.length;

            const wordCount = viewerState.segments.reduce((sum, seg) => {
                return sum + (seg.text || '').split(/\s+/).filter(w => w.length > 0).length;
            }, 0);
            document.getElementById('word-count').textContent = wordCount;
        }

        // Update last update time
        function updateLastUpdateTime() {
            const now = new Date();
            document.getElementById('last-update').textContent = now.toLocaleTimeString();
        }

        // Update duration display
        function updateDuration() {
            if (!viewerState.sessionStartTime) return;

            const now = new Date();
            const elapsed = Math.floor((now - viewerState.sessionStartTime) / 1000);
            document.getElementById('duration-display').textContent = `Duration: ${formatTimestamp(elapsed)}`;
        }

        // Auto-scroll
        function autoScroll() {
            if (!viewerState.autoScrollEnabled) return;

            const container = document.getElementById('transcript');
            container.scrollTo({
                top: container.scrollHeight,
                behavior: 'smooth'
            });
        }

        // Toggle auto-scroll
        function toggleAutoScroll() {
            viewerState.autoScrollEnabled = !viewerState.autoScrollEnabled;
            const btn = document.getElementById('autoscroll-btn');
            btn.innerHTML = `<i class="fas fa-arrow-down"></i> Auto-scroll: ${viewerState.autoScrollEnabled ? 'ON' : 'OFF'}`;
        }

        // Detect manual scroll
        document.addEventListener('DOMContentLoaded', () => {
            const container = document.getElementById('transcript');
            container.addEventListener('scroll', (e) => {
                const isAtBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 50;

                if (!isAtBottom && viewerState.autoScrollEnabled) {
                    viewerState.autoScrollEnabled = false;
                    const btn = document.getElementById('autoscroll-btn');
                    btn.innerHTML = '<i class="fas fa-arrow-down"></i> Auto-scroll: OFF';
                } else if (isAtBottom && !viewerState.autoScrollEnabled) {
                    viewerState.autoScrollEnabled = true;
                    const btn = document.getElementById('autoscroll-btn');
                    btn.innerHTML = '<i class="fas fa-arrow-down"></i> Auto-scroll: ON';
                }
            });
        });

        // Copy transcript
        function copyTranscript() {
            const text = viewerState.segments.map(seg => {
                const timestamp = formatTimestamp(seg.start || 0);
                return `${timestamp} ${seg.text || ''}`;
            }).join('\n');

            navigator.clipboard.writeText(text).then(() => {
                alert('Transcript copied to clipboard!');
            }).catch(err => {
                console.error('Copy failed:', err);
                alert('Failed to copy transcript');
            });
        }

        // Download transcript
        function downloadTranscript() {
            const text = viewerState.segments.map(seg => {
                const timestamp = formatTimestamp(seg.start || 0);
                return `${timestamp} ${seg.text || ''}`;
            }).join('\n');

            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `transcript-${viewerState.sessionId}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Refresh now
        function refreshNow() {
            pollTranscription();
        }

        // Start polling
        function startPolling() {
            if (viewerState.pollInterval) {
                clearInterval(viewerState.pollInterval);
            }

            // Poll immediately
            pollTranscription();

            // Then poll on interval
            viewerState.pollInterval = setInterval(pollTranscription, viewerState.pollFrequency);

            // Update duration every second
            viewerState.durationInterval = setInterval(updateDuration, 1000);
        }

        // Stop polling
        function stopPolling() {
            if (viewerState.pollInterval) {
                clearInterval(viewerState.pollInterval);
                viewerState.pollInterval = null;
            }
            if (viewerState.durationInterval) {
                clearInterval(viewerState.durationInterval);
                viewerState.durationInterval = null;
            }
        }

        // Initialize viewer
        async function initViewer() {
            // Check authentication
            const user = getUserFromToken();
            if (!user) {
                alert('Please login first');
                window.location.href = '/';
                return;
            }

            // Get URL parameters
            const params = getUrlParams();

            if (!params.sessionId || !params.userId) {
                alert('Missing session ID or user ID in URL');
                return;
            }

            viewerState.sessionId = params.sessionId;
            viewerState.userId = params.userId;

            // Build session path
            const timestamp = viewerState.sessionId.match(/session_(\d{4}-\d{2}-\d{2})/);
            const datePrefix = timestamp ? timestamp[1] : new Date().toISOString().split('T')[0];
            viewerState.sessionPath = `users/${viewerState.userId}/audio/sessions/${datePrefix}-${viewerState.sessionId}/`;

            // Update UI
            document.getElementById('session-id-display').textContent = `Session: ${viewerState.sessionId}`;

            console.log('Viewer initialized:', viewerState);
            console.log('Session path:', viewerState.sessionPath);

            // Start polling
            startPolling();
        }

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', initViewer);

        // Cleanup on page unload
        window.addEventListener('beforeunload', stopPolling);
    </script>
</body>
</html>
