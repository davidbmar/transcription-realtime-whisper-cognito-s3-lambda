<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collaborative Transcript Editor - CloudDrive</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <!-- Build: 2025-11-17-00:53 -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://unpkg.com; style-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; connect-src 'self' https://*.execute-api.us-east-2.amazonaws.com https://*.cloudfront.net https://*.s3.us-east-2.amazonaws.com https://*.s3.amazonaws.com; media-src 'self' blob: https:; img-src 'self' data: https:; font-src 'self' data: https://cdnjs.cloudflare.com; worker-src 'self' blob:;">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --primary-light: #dbeafe;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --gray-50: #f9fafb;
            --gray-100: #f3f4f6;
            --gray-200: #e5e7eb;
            --gray-300: #d1d5db;
            --gray-400: #9ca3af;
            --gray-500: #6b7280;
            --gray-600: #4b5563;
            --gray-700: #374151;
            --gray-800: #1f2937;
            --gray-900: #111827;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--gray-50);
            color: var(--gray-900);
        }

        /* Header */
        .header {
            background: white;
            border-bottom: 1px solid var(--gray-200);
            padding: 16px 24px;
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 20px;
            font-weight: 700;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .breadcrumb-nav {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .breadcrumb-link {
            display: flex;
            align-items: center;
            gap: 6px;
            color: var(--primary);
            text-decoration: none;
            padding: 6px 12px;
            border-radius: 6px;
            transition: all 0.2s;
            cursor: pointer;
        }

        .breadcrumb-link:hover {
            background: var(--primary-light);
        }

        .breadcrumb-link i {
            font-size: 16px;
        }

        .breadcrumb-separator {
            color: var(--gray-400);
            font-size: 12px;
        }

        .breadcrumb-current {
            color: var(--gray-700);
            font-weight: 600;
        }

        .header-actions {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        /* Two-Panel Layout */
        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 24px;
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 24px;
            min-height: calc(100vh - 80px);
        }

        /* Sidebar */
        .sidebar {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            height: fit-content;
            position: sticky;
            top: 100px;
        }

        .sidebar-section {
            margin-bottom: 24px;
        }

        .sidebar-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--gray-700);
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .plugin-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .plugin-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            border: 1px solid var(--gray-200);
            border-radius: 6px;
            background: white;
            color: var(--gray-700);
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            text-align: left;
        }

        .plugin-btn:hover {
            background: var(--gray-50);
            border-color: var(--primary);
            color: var(--primary);
        }

        .plugin-btn.active {
            background: var(--primary-light);
            border-color: var(--primary);
            color: var(--primary);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .stat-card {
            background: var(--gray-50);
            padding: 12px;
            border-radius: 6px;
            border: 1px solid var(--gray-200);
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--primary);
        }

        .stat-label {
            font-size: 12px;
            color: var(--gray-600);
            margin-top: 4px;
        }

        /* Editor Panel */
        .editor-panel {
            background: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .editor-toolbar {
            background: var(--gray-50);
            border-bottom: 1px solid var(--gray-200);
            padding: 12px 20px;
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .toolbar-group {
            display: flex;
            gap: 6px;
            align-items: center;
            padding-right: 12px;
            border-right: 1px solid var(--gray-300);
        }

        .toolbar-group:last-child {
            border-right: none;
        }

        .toolbar-btn {
            padding: 6px 12px;
            border-radius: 6px;
            border: 1px solid var(--gray-300);
            background: white;
            color: var(--gray-700);
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .toolbar-btn:hover {
            background: var(--gray-100);
            border-color: var(--primary);
        }

        .toolbar-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .search-box {
            flex: 1;
            min-width: 250px;
            max-width: 400px;
        }

        .search-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--gray-300);
            border-radius: 6px;
            font-size: 14px;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px var(--primary-light);
        }

        /* Dropdown Menu */
        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 4px;
            background: white;
            border: 1px solid var(--gray-300);
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            min-width: 180px;
            z-index: 1000;
        }

        .dropdown-menu.show {
            display: block;
        }

        .dropdown-item {
            display: block;
            width: 100%;
            padding: 10px 16px;
            border: none;
            background: white;
            text-align: left;
            font-size: 14px;
            color: var(--gray-700);
            cursor: pointer;
            transition: background 0.2s;
        }

        .dropdown-item:first-child {
            border-radius: 6px 6px 0 0;
        }

        .dropdown-item:last-child {
            border-radius: 0 0 6px 6px;
        }

        .dropdown-item:hover {
            background: var(--gray-100);
        }

        /* Editor Content */
        .editor-content {
            padding: 32px;
            padding-bottom: 100px; /* Space for fixed bottom playback bar */
            max-width: 900px;
            margin: 0 auto;
        }

        .paragraph-container {
            margin-bottom: 32px;
            position: relative;
            padding-left: 48px;
            display: flex;
            flex-direction: column;
        }

        /* Topic change indicator - shown at paragraph boundaries where topic shifts */
        .paragraph-container.topic-start {
            margin-top: 32px;
            padding-top: 20px;
            border-top: 2px solid var(--primary-light);
        }

        .paragraph-container.topic-start::before {
            content: 'Topic Change';
            display: block;
            position: absolute;
            top: -10px;
            left: 48px;
            background: white;
            padding: 0 8px;
            font-size: 11px;
            color: var(--primary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        /* First paragraph shouldn't show topic change marker */
        .paragraph-container.topic-start:first-child {
            margin-top: 0;
            padding-top: 0;
            border-top: none;
        }

        .paragraph-container.topic-start:first-child::before {
            display: none;
        }

        .paragraph-number {
            position: absolute;
            left: 0;
            top: 0;
            width: 36px;
            height: 36px;
            background: var(--gray-100);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
            color: var(--gray-600);
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .paragraph-number:hover {
            background: var(--primary);
            color: white;
        }

        .paragraph-text {
            line-height: 1.8;
            font-size: 16px;
            color: var(--gray-800);
            padding: 16px;
            border-radius: 8px;
            border: 2px solid transparent;
            transition: all 0.2s;
            outline: none;
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            word-wrap: break-word;
            overflow-wrap: break-word;
            max-width: 100%;
            overflow-x: hidden;
        }

        .paragraph-text:hover {
            background: var(--gray-50);
        }

        .paragraph-text:focus {
            border-color: var(--primary);
            background: white;
            box-shadow: 0 0 0 3px var(--primary-light);
        }

        .paragraph-text.playing {
            background: #fef3c7;
            border-color: #f59e0b;
        }

        .paragraph-text.edited {
            border-left: 4px solid var(--success);
        }

        .paragraph-meta {
            display: flex;
            gap: 12px;
            margin-top: 8px;
            font-size: 12px;
            color: var(--gray-500);
            padding-left: 16px;
            user-select: none !important;
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            pointer-events: all;
        }

        .paragraph-meta * {
            user-select: none !important;
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .chunk-badge {
            background: var(--primary-light);
            color: var(--primary);
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .chunk-badge:hover {
            background: var(--primary);
            color: white;
        }

        .audio-btn {
            background: var(--success);
            color: white;
            border: none;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            transition: all 0.2s;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .audio-btn:hover {
            background: #059669;
        }

        /* Original Text Dropdown */
        .original-text-toggle {
            background: var(--gray-100);
            border: 1px solid var(--gray-300);
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            color: var(--gray-600);
            transition: all 0.2s;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .original-text-toggle:hover {
            background: var(--gray-200);
        }

        .original-text-content {
            display: none;
            margin-top: 12px;
            padding: 12px;
            background: var(--gray-50);
            border-left: 3px solid var(--gray-400);
            border-radius: 4px;
            font-size: 14px;
            color: var(--gray-600);
            font-style: italic;
        }

        .original-text-content.show {
            display: block;
        }

        /* Word Highlighting */
        .word-highlight {
            padding: 2px 4px;
            border-radius: 3px;
            cursor: pointer;
            transition: background-color 0.15s, color 0.15s;
            display: inline-block;
        }

        .word-highlight:hover {
            background: #fef08a;
        }

        .word-highlight.playing {
            background: #fbbf24;
            color: #78350f;
            font-weight: 500;
        }

        /* Global Playback Controls - Fixed Bottom Bar (spans second column only) */
        .global-playback-bar {
            position: fixed;
            bottom: 0;
            /* Account for sidebar (320px) + gap (24px) + container padding (24px) */
            left: calc(50% - 700px + 320px + 24px + 24px);
            /* Match the main content area width */
            right: calc(50% - 700px + 24px);
            z-index: 1000;
            background: white;
            border-top: 1px solid var(--gray-200);
            border-radius: 12px 12px 0 0;
            padding: 16px 24px;
            box-shadow: 0 -4px 12px rgba(0,0,0,0.1);
            display: none;
        }

        /* When viewport is smaller than max-width, adjust positioning */
        @media (max-width: 1448px) {
            .global-playback-bar {
                left: calc(320px + 24px + 24px);
                right: 24px;
            }
        }

        .global-playback-bar.visible {
            display: block;
        }

        /* Skip buttons (rewind/forward) - Audible style */
        .skip-btn {
            background: transparent;
            color: #1a1a1a;
            border: none;
            width: 48px;
            height: 48px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
            padding: 0;
        }

        .skip-btn svg {
            width: 40px;
            height: 40px;
        }

        .skip-btn:hover {
            opacity: 0.7;
        }

        .skip-btn:active {
            transform: scale(0.95);
        }

        .global-playback-controls {
            display: flex;
            align-items: center;
            gap: 16px;
            max-width: 100%;
        }

        /* Play button - Audible style (large solid black circle) */
        .global-play-btn {
            background: #1a1a1a;
            color: white;
            border: none;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
            padding: 0;
        }

        .global-play-btn svg {
            width: 24px;
            height: 24px;
            fill: white;
        }

        .global-play-btn:hover {
            background: #333;
            transform: scale(1.05);
        }

        .global-play-btn:disabled {
            background: var(--gray-300);
            cursor: not-allowed;
        }

        .global-time-display {
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 14px;
            color: var(--gray-700);
            min-width: 120px;
            text-align: center;
            flex-shrink: 0;
        }

        .global-scrubber-container {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 200px;
        }

        .global-scrubber {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--gray-200);
            border-radius: 4px;
            outline: none;
            cursor: pointer;
        }

        .global-scrubber::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.15s;
        }

        .global-scrubber::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .global-scrubber::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .global-speed-select {
            padding: 6px 12px;
            border: 1px solid var(--gray-300);
            border-radius: 6px;
            font-size: 13px;
            color: var(--gray-700);
            background: white;
            cursor: pointer;
            flex-shrink: 0;
        }

        .global-speed-select:hover {
            border-color: var(--primary);
        }

        .global-chunk-indicator {
            font-size: 11px;
            color: var(--gray-500);
            background: var(--gray-100);
            padding: 4px 8px;
            border-radius: 4px;
            flex-shrink: 0;
        }

        /* Playing paragraph highlight */
        .paragraph-container.playing-now {
            background: #fffbeb;
            border-left: 4px solid #f59e0b;
        }

        /* Clickable paragraph for seeking */
        .paragraph-container.clickable-seek {
            cursor: pointer;
        }

        .paragraph-container.clickable-seek:hover {
            background: var(--gray-50);
        }

        /* Plugin Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 24px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 16px;
        }

        .modal-close {
            float: right;
            cursor: pointer;
            font-size: 24px;
            color: var(--gray-500);
        }

        .modal-close:hover {
            color: var(--gray-700);
        }

        /* Loading & Toast */
        .loading {
            text-align: center;
            padding: 48px;
            color: var(--gray-600);
        }

        .spinner {
            border: 3px solid var(--gray-200);
            border-top: 3px solid var(--primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .toast {
            position: fixed;
            bottom: 24px;
            right: 24px;
            background: var(--success);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s;
            z-index: 3000;
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }

        .toast.error {
            background: var(--danger);
        }

        /* Annotation Highlight Styles */
        .annotation-highlight {
            position: relative;
        }

        .annotation-tag {
            background: rgba(59, 130, 246, 0.2);
            border-bottom: 2px solid #3b82f6;
        }

        .annotation-redaction {
            background: #dc2626;
            color: white !important;
            border-radius: 2px;
            padding: 0 2px;
        }

        .annotation-comment {
            background: rgba(251, 191, 36, 0.3);
            border-bottom: 2px dashed #f59e0b;
        }

        /* Split Mode Styles */
        .split-mode {
            background: rgba(239, 68, 68, 0.05) !important;
            border: 2px dashed var(--danger) !important;
            padding: 12px !important;
        }

        .split-mode .paragraph-text {
            cursor: text;
        }

        .split-mode .blade-target {
            cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Ctext x='0' y='20' font-size='20'%3E✂️%3C/text%3E%3C/svg%3E") 12 12, crosshair !important;
        }

        .split-mode .blade-target:hover {
            background: rgba(239, 68, 68, 0.3);
            border-radius: 2px;
        }

        .split-mode .blade-target.cut {
            color: var(--danger) !important;
            font-size: 16px;
        }

        .segment-wrapper {
            display: inline;
            border-radius: 4px;
            padding: 2px 4px;
            margin: 2px 4px 2px 0;
        }

        .segment-wrapper.saved {
            display: block;
            word-wrap: break-word;
            overflow-wrap: break-word;
            max-width: 100%;
        }

        .segment-speaker-chip {
            cursor: pointer;
            transition: all 0.2s;
        }

        .segment-speaker-chip:hover {
            background: var(--primary-light) !important;
            border-color: var(--primary) !important;
        }

        .split-marker {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Speaker Split Button */
        .split-speaker-btn {
            position: absolute;
            right: 8px;
            top: 8px;
            padding: 4px 8px;
            font-size: 11px;
            background: var(--gray-100);
            border: 1px solid var(--gray-300);
            border-radius: 4px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .paragraph-container:hover .split-speaker-btn {
            opacity: 1;
        }

        .split-speaker-btn:hover {
            background: var(--danger);
            color: white;
            border-color: var(--danger);
        }

        /* Button Styles */
        .btn {
            padding: 10px 18px;
            border-radius: 6px;
            border: 1px solid var(--gray-300);
            background: white;
            color: var(--gray-700);
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .btn:hover {
            background: var(--gray-50);
        }

        .btn-primary {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .btn-primary:hover {
            background: var(--primary-dark);
        }

        /* AI Timeline Navigation Styles */
        .ai-nav-container {
            position: sticky;
            top: 64px; /* Below header */
            z-index: 90;
            background: white;
            border-radius: 0 0 12px 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            margin-bottom: 24px;
            margin-top: -64px; /* Pull up under header */
            padding-top: 64px; /* Space for header */
        }

        /* Add slight padding when scrolled */
        .ai-nav-container.scrolled {
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
        }

        /* Main content wrapper for scroll context */
        .main-content-wrapper {
            flex: 1;
            min-height: 0;
            overflow-y: auto;
        }

        /* Editor panel needs to allow scrolling */
        .editor-panel {
            background: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            overflow: visible;
        }

        .ai-nav-tabs {
            display: flex;
            gap: 8px;
            padding: 16px;
            background: var(--gray-50);
            border-bottom: 1px solid var(--gray-200);
            overflow-x: auto;
        }

        .ai-nav-tab {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 16px;
            border: 2px solid transparent;
            border-radius: 8px;
            background: white;
            color: var(--gray-700);
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .ai-nav-tab:hover {
            border-color: var(--gray-300);
            background: var(--gray-100);
        }

        .ai-nav-tab.active {
            color: white;
            border-color: currentColor;
        }

        .ai-nav-tab.active.highlights { background: #8b5cf6; }
        .ai-nav-tab.active.questions { background: #ec4899; }
        .ai-nav-tab.active.actionItems { background: #ef4444; }
        .ai-nav-tab.active.keyTerms { background: #3b82f6; }
        .ai-nav-tab.active.keyThemes { background: #f59e0b; }
        .ai-nav-tab.active.topicChanges { background: #10b981; }
        .ai-nav-tab.active.all { background: var(--primary); }

        .ai-count-badge {
            background: rgba(255,255,255,0.3);
            color: inherit;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        .ai-nav-tab.active .ai-count-badge {
            background: rgba(255,255,255,0.25);
        }

        .timeline-container {
            padding: 24px;
            background: white;
        }

        .timeline-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .timeline-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--gray-700);
        }

        .timeline-duration {
            font-size: 13px;
            color: var(--gray-500);
        }

        .timeline-track-wrapper {
            position: relative;
            height: 60px;
            background: var(--gray-100);
            border-radius: 8px;
            overflow: visible;
        }

        .timeline-track {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .timeline-marker {
            position: absolute;
            top: 0;
            width: 4px;
            height: 100%;
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .timeline-marker:hover {
            width: 8px;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .timeline-marker.segment {
            height: 100%;
            opacity: 0.4;
        }

        .timeline-marker.segment:hover {
            opacity: 0.6;
        }

        .timeline-time-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 11px;
            color: var(--gray-500);
        }

        .timeline-tooltip {
            position: fixed;
            background: var(--gray-900);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            max-width: 320px;
            z-index: 2000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .timeline-tooltip.show {
            opacity: 1;
        }

        .tooltip-time {
            font-weight: 600;
            color: #fbbf24;
            margin-bottom: 6px;
        }

        .tooltip-summary {
            line-height: 1.5;
        }

        .ai-highlighted {
            animation: highlight-pulse 2s ease-in-out;
        }

        @keyframes highlight-pulse {
            0%, 100% { background: var(--gray-50); }
            50% { background: #fef3c7; }
        }

        /* Question highlighting styles - alternating shades */
        .question-highlight {
            font-weight: 700;
            padding: 2px 0;
        }

        .question-highlight.shade-1 {
            color: #ec4899;  /* Base pink */
        }

        .question-highlight.shade-2 {
            color: #db2777;  /* Darker pink */
        }

        .question-highlight.shade-3 {
            color: #f472b6;  /* Lighter pink */
        }

        .question-highlight.shade-4 {
            color: #be185d;  /* Deep pink */
        }

        .question-paragraph {
            margin-top: 24px !important;
            margin-bottom: 24px !important;
            padding-top: 16px;
            padding-bottom: 16px;
            border-left: 4px solid #ec4899;
            background: #fdf2f8;
        }

        /* Speaker labels for diarization */
        .speaker-label {
            display: inline-block;
            font-size: 11px;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 4px;
            margin-right: 8px;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .speaker-label.speaker-0 {
            background: #dbeafe;
            color: #1e40af;
        }

        .speaker-label.speaker-1 {
            background: #dcfce7;
            color: #166534;
        }

        .speaker-label.speaker-2 {
            background: #fef3c7;
            color: #92400e;
        }

        .speaker-label.speaker-3 {
            background: #f3e8ff;
            color: #6b21a8;
        }

        .speaker-label.speaker-4 {
            background: #ffe4e6;
            color: #be123c;
        }

        .speaker-label.speaker-5 {
            background: #e0f2fe;
            color: #0369a1;
        }

        /* Hide speaker label when paragraph has split annotation */
        .has-split-annotation > .speaker-label,
        .has-split-annotation > .split-speaker-btn,
        .hidden-by-split {
            display: none !important;
            visibility: hidden !important;
        }

        /* Delete annotation button */
        .delete-split-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 4px;
            width: 20px;
            height: 20px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .segment-wrapper.saved:hover .delete-split-btn {
            opacity: 1;
        }

        .delete-split-btn:hover {
            background: #dc2626;
        }

        /* Speaker legend in sidebar */
        .speaker-legend {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .speaker-row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 0;
        }

        .speaker-color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .speaker-name-input {
            flex: 1;
            padding: 4px 8px;
            border: 1px solid var(--gray-300);
            border-radius: 4px;
            font-size: 12px;
            min-width: 0;
        }

        .speaker-name-input:focus {
            outline: none;
            border-color: var(--primary);
        }

        .speaker-merge-select {
            font-size: 11px;
            padding: 2px 4px;
            border: 1px solid var(--gray-300);
            border-radius: 4px;
            max-width: 80px;
            background: white;
            cursor: pointer;
        }

        .speaker-merge-select:hover {
            border-color: var(--gray-400);
        }

        /* Speaker change indicator */
        .paragraph-container.speaker-change {
            margin-top: 16px;
        }

        /* Speaker stats card */
        .stat-card.speakers {
            border-left: 3px solid #6366f1;
        }

        .ai-loading-state {
            text-align: center;
            padding: 32px;
            color: var(--gray-600);
        }

        .ai-empty-state {
            text-align: center;
            padding: 32px;
            color: var(--gray-500);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .main-container {
                grid-template-columns: 1fr;
            }

            .sidebar {
                position: relative;
                top: 0;
            }

            .ai-nav-tabs {
                overflow-x: scroll;
            }

            .timeline-track-wrapper {
                height: 80px;
            }
        }

        /* ====================================================================
           AI Configuration Panel
           ==================================================================== */

        .config-header {
            padding: 16px;
            border-bottom: 1px solid var(--gray-200);
        }

        .back-button {
            background: none;
            border: none;
            color: var(--gray-500);
            cursor: pointer;
            font-size: 14px;
            padding: 6px 12px;
            margin-bottom: 8px;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .back-button:hover {
            color: var(--gray-900);
            background: var(--gray-100);
        }

        .config-section {
            padding: 16px;
            border-bottom: 1px solid var(--gray-100);
        }

        .category-name-input {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid var(--gray-200);
            border-radius: 6px;
            font-size: 14px;
            margin-top: 4px;
            transition: border-color 0.2s;
        }

        .category-name-input:focus {
            border-color: var(--primary);
            outline: none;
        }

        .hint {
            color: var(--gray-500);
            font-size: 12px;
            font-style: italic;
            display: block;
            margin-top: 4px;
        }

        /* Prompt Editor */
        .prompt-editor-wrapper {
            position: relative;
            margin-top: 4px;
        }

        .prompt-editor {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--gray-200);
            border-radius: 6px;
            font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
            resize: vertical;
            min-height: 80px;
            max-height: 400px;
            transition: border-color 0.2s;
        }

        .prompt-editor:focus {
            border-color: #8b5cf6;
            outline: none;
        }

        .prompt-editor.dirty {
            border-left: 4px solid var(--warning);
        }

        .expand-button {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: white;
            border: 1px solid var(--gray-300);
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .expand-button:hover {
            background: var(--gray-100);
            border-color: var(--gray-400);
        }

        /* Settings Grid */
        .settings-grid {
            display: grid;
            gap: 12px;
            margin-top: 8px;
        }

        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .setting-item label {
            font-size: 12px;
            color: var(--gray-600);
            font-weight: 500;
        }

        .setting-item select,
        .setting-item input[type="number"],
        .setting-item input[type="text"] {
            padding: 6px 10px;
            border: 1px solid var(--gray-300);
            border-radius: 4px;
            font-size: 13px;
            transition: border-color 0.2s;
        }

        .setting-item select:focus,
        .setting-item input:focus {
            border-color: var(--primary);
            outline: none;
        }

        .setting-item input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        /* Status Section */
        .status-section {
            background: var(--gray-50);
        }

        .status-info {
            background: white;
            border-radius: 6px;
            padding: 12px;
            margin-top: 8px;
            border: 1px solid var(--gray-200);
        }

        .status-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            font-size: 13px;
        }

        .status-row span:first-child {
            color: var(--gray-600);
        }

        .status-row span:last-child {
            font-weight: 600;
            color: var(--gray-900);
        }

        /* Action Buttons */
        .config-actions {
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .btn-reanalyze {
            background: linear-gradient(135deg, #8b5cf6, #6d28d9);
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .btn-reanalyze:hover:not(:disabled) {
            background: linear-gradient(135deg, #7c3aed, #5b21b6);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
        }

        .btn-reanalyze:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-save {
            background: white;
            border: 2px solid var(--gray-200);
            padding: 10px 16px;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .btn-save:not([disabled]):hover {
            border-color: var(--primary);
            background: var(--primary-light);
        }

        .btn-save[disabled] {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-save.dirty {
            border-color: var(--warning);
            background: #fffbeb;
        }

        .btn-reset {
            background: none;
            border: none;
            color: var(--gray-600);
            padding: 8px;
            cursor: pointer;
            font-size: 13px;
            transition: color 0.2s;
        }

        .btn-reset:hover {
            color: var(--gray-900);
        }

        /* Progress Indicator */
        .progress-container {
            padding: 16px;
            background: #f0f9ff;
            border-top: 2px solid var(--primary);
            text-align: center;
        }

        .progress-spinner {
            width: 24px;
            height: 24px;
            border: 3px solid #dbeafe;
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .progress-text {
            font-size: 13px;
            color: #1e40af;
            font-weight: 500;
        }

        /* Transitions */
        #session-info,
        #ai-config-panel {
            transition: opacity 0.3s ease-in-out;
        }

        #session-info.hiding,
        #ai-config-panel.hiding {
            opacity: 0;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="header-content">
            <div class="breadcrumb-nav">
                <a href="index.html" class="breadcrumb-link">
                    <i class="fas fa-home"></i>
                    Dashboard
                </a>
                <span class="breadcrumb-separator">›</span>
                <span class="breadcrumb-current">Collaborative Transcript Editor</span>
            </div>
            <div class="header-actions">
                <select id="timezone-selector" style="padding: 8px 12px; border: 1px solid var(--gray-300); border-radius: 6px; font-size: 14px; background: white; cursor: pointer; margin-right: 12px;">
                    <option value="UTC">UTC</option>
                    <option value="America/New_York">Eastern (ET)</option>
                    <option value="America/Chicago">Central (CT)</option>
                    <option value="America/Denver">Mountain (MT)</option>
                    <option value="America/Los_Angeles">Pacific (PT)</option>
                    <option value="America/Phoenix">Arizona (MST)</option>
                    <option value="America/Anchorage">Alaska (AKT)</option>
                    <option value="Pacific/Honolulu">Hawaii (HST)</option>
                    <option value="Europe/London">London (GMT/BST)</option>
                    <option value="Europe/Paris">Paris (CET)</option>
                    <option value="Europe/Berlin">Berlin (CET)</option>
                    <option value="Asia/Tokyo">Tokyo (JST)</option>
                    <option value="Asia/Shanghai">Shanghai (CST)</option>
                    <option value="Asia/Dubai">Dubai (GST)</option>
                    <option value="Australia/Sydney">Sydney (AEDT)</option>
                </select>
                <span id="user-email" style="color: var(--gray-600); font-size: 14px;"></span>
                <button class="btn" id="logout-btn">Logout</button>
            </div>
        </div>
    </div>

    <!-- Loading State -->
    <div id="loading" class="loading">
        <div class="spinner"></div>
        <div>Loading and processing transcript...</div>
    </div>

    <!-- Main Container -->
    <div id="main-container" class="main-container" style="display: none;">
        <!-- Sidebar -->
        <div class="sidebar">
            <!-- Session Info (default view) -->
            <div id="session-info">
            <!-- Session Selector -->
            <div class="sidebar-section">
                <div class="sidebar-title" style="display: flex; align-items: center; justify-content: space-between;">
                    <span>Session</span>
                    <button onclick="sessionInfoModal.show()" style="
                        background: none;
                        border: none;
                        cursor: pointer;
                        font-size: 16px;
                        padding: 4px;
                        opacity: 0.6;
                        transition: opacity 0.2s;
                        line-height: 1;
                    " onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.6'" title="View session details">
                        ℹ️
                    </button>
                </div>
                <select id="session-selector" style="width: 100%; padding: 8px 12px; border: 1px solid var(--gray-300); border-radius: 6px; font-size: 14px; background: white; cursor: pointer;">
                    <option value="">Loading sessions...</option>
                </select>
            </div>

            <!-- Stats -->
            <div class="sidebar-section">
                <div class="sidebar-title">Statistics</div>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="stat-paragraphs">0</div>
                        <div class="stat-label">Paragraphs</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="stat-words">0</div>
                        <div class="stat-label">Words</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="stat-duration">0:00</div>
                        <div class="stat-label">Duration</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="stat-wpm">0</div>
                        <div class="stat-label">WPM</div>
                    </div>
                    <div class="stat-card" id="stat-topics-card" style="display: none;">
                        <div class="stat-value" id="stat-topics">0</div>
                        <div class="stat-label">Topics</div>
                    </div>
                    <div class="stat-card speakers" id="stat-speakers-card" style="display: none;">
                        <div class="stat-value" id="stat-speakers">0</div>
                        <div class="stat-label">Speakers</div>
                    </div>
                </div>
            </div>

            <!-- Speakers (only shown if diarization data exists) -->
            <div class="sidebar-section" id="speakers-section" style="display: none;">
                <div class="sidebar-title" style="display: flex; justify-content: space-between; align-items: center;">
                    <span>Speakers</span>
                    <button id="save-speakers-btn" onclick="saveSpeakerNames()"
                            style="font-size: 11px; padding: 2px 8px; background: var(--primary); color: white; border: none; border-radius: 4px; cursor: pointer;"
                            title="Save speaker names">
                        Save
                    </button>
                </div>
                <div id="speaker-list" class="speaker-legend">
                    <!-- Dynamically populated -->
                </div>
            </div>

            <!-- Annotation Layers -->
            <!-- Photoshop-Style Layer Panel -->
            <div class="sidebar-section layer-panel" id="layers-section">
                <div class="layer-panel-header">
                    <span class="layer-panel-title">Layers</span>
                    <button class="layer-add-btn" onclick="layerManager.addLayer()" title="Add Layer">+</button>
                </div>
                <div class="layer-stack" id="layer-stack">
                    <!-- Layers rendered dynamically by renderLayerPanel() -->
                </div>
            </div>
            <style>
                .layer-panel {
                    background: white;
                    border-radius: 8px;
                    border: 1px solid var(--gray-200);
                    overflow: hidden;
                }
                .layer-panel-header {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    padding: 10px 12px;
                    background: var(--gray-50);
                    border-bottom: 1px solid var(--gray-200);
                }
                .layer-panel-title {
                    font-weight: 600;
                    font-size: 13px;
                    color: var(--gray-700);
                }
                .layer-add-btn {
                    width: 24px;
                    height: 24px;
                    border: none;
                    background: var(--primary);
                    color: white;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 16px;
                    font-weight: bold;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }
                .layer-add-btn:hover {
                    background: var(--primary-dark, #1d4ed8);
                }
                .layer-stack {
                    max-height: 280px;
                    overflow-y: auto;
                }
                .layer-item {
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    padding: 10px 12px;
                    border-bottom: 1px solid var(--gray-100);
                    cursor: pointer;
                    transition: background 0.15s;
                }
                .layer-item:hover {
                    background: var(--gray-50);
                }
                .layer-item.selected {
                    background: rgba(59, 130, 246, 0.1);
                    border-left: 3px solid var(--primary);
                }
                .layer-item.locked {
                    opacity: 0.7;
                }
                .layer-item.hidden {
                    opacity: 0.4;
                }
                .layer-visibility, .layer-lock {
                    background: none;
                    border: none;
                    cursor: pointer;
                    padding: 2px;
                    font-size: 14px;
                    opacity: 0.7;
                }
                .layer-visibility:hover, .layer-lock:hover {
                    opacity: 1;
                }
                .layer-visibility.off {
                    opacity: 0.3;
                }
                .layer-color {
                    width: 12px;
                    height: 12px;
                    border-radius: 3px;
                    flex-shrink: 0;
                }
                .layer-name {
                    flex: 1;
                    font-size: 13px;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                }
                .layer-count {
                    font-size: 11px;
                    color: var(--gray-500);
                    background: var(--gray-100);
                    padding: 2px 6px;
                    border-radius: 8px;
                    min-width: 20px;
                    text-align: center;
                }

                /* Hide speaker chunks when Layer 1 is toggled off */
                .hide-speaker-chunks .speaker-label {
                    display: none !important;
                }
                .hide-speaker-chunks .segment-wrapper {
                    background: transparent !important;
                    border-left: none !important;
                    padding: 0 !important;
                    margin: 0 !important;
                }
                .hide-speaker-chunks .segment-speaker-chip {
                    display: none !important;
                }
                .hide-speaker-chunks .split-speaker-btn {
                    display: none !important;
                }
            </style>

            <!-- Actions -->
            <div class="sidebar-section">
                <div class="sidebar-title">Actions</div>
                <div class="plugin-list">
                    <button class="plugin-btn" onclick="pluginManager.showSearchDialog()">
                        🔍 Search
                    </button>
                    <button class="plugin-btn" onclick="pluginManager.showReplaceDialog()">
                        🔄 Find & Replace
                    </button>
                    <button class="plugin-btn" onclick="pluginManager.showHighlightDialog()">
                        ✨ Highlight Keywords
                    </button>
                    <button class="plugin-btn" onclick="pluginManager.extractActions()">
                        ✅ Extract Action Items
                    </button>
                    <button class="plugin-btn" onclick="pluginManager.showWordFrequency()">
                        📊 Word Frequency
                    </button>
                </div>
            </div>

            <!-- Export -->
            <div class="sidebar-section">
                <div class="sidebar-title">Export</div>
                <div class="plugin-list">
                    <button class="plugin-btn" onclick="pluginManager.export('plain')">
                        📄 Plain Text
                    </button>
                    <button class="plugin-btn" onclick="pluginManager.export('markdown')">
                        📝 Markdown
                    </button>
                    <button class="plugin-btn" onclick="pluginManager.export('srt')">
                        🎬 SRT Subtitles
                    </button>
                    <button class="plugin-btn" onclick="pluginManager.export('json')">
                        💾 JSON
                    </button>
                </div>
            </div>

            <!-- Save -->
            <button class="btn btn-primary" style="width: 100%;" onclick="saveTranscript()">
                💾 Save Changes
            </button>
            </div>
            <!-- End Session Info -->

            <!-- AI Configuration Panel (hidden by default) -->
            <div id="ai-config-panel" style="display: none;">
                <!-- Header -->
                <div class="config-header">
                    <button onclick="aiConfigPanel.close()" class="back-button">
                        ← Back to Session
                    </button>
                    <h3 style="margin: 0; font-size: 16px; color: var(--gray-900);">✨ AI Category Configuration</h3>
                </div>

                <!-- Category Name -->
                <div class="config-section">
                    <label for="category-name" style="display: block; font-weight: 600; font-size: 13px; margin-bottom: 4px; color: var(--gray-700);">Tab Name:</label>
                    <input type="text" id="category-name" class="category-name-input" placeholder="e.g., Key Interviewer Questions">
                    <small class="hint">This name appears in the timeline tab</small>
                </div>

                <!-- Prompt Editor -->
                <div class="config-section">
                    <label for="category-prompt" style="display: block; font-weight: 600; font-size: 13px; margin-bottom: 4px; color: var(--gray-700);">Prompt:</label>
                    <div class="prompt-editor-wrapper">
                        <textarea id="category-prompt" class="prompt-editor" rows="4"></textarea>
                        <button onclick="promptEditor.toggleExpand()" class="expand-button">
                            ▼ Expand
                        </button>
                    </div>
                </div>

                <!-- Settings -->
                <div class="config-section">
                    <label style="display: block; font-weight: 600; font-size: 13px; margin-bottom: 8px; color: var(--gray-700);">Settings:</label>
                    <div class="settings-grid">
                        <div class="setting-item">
                            <label for="setting-model">Model:</label>
                            <select id="setting-model">
                                <option value="claude-3-5-haiku-20241022">Claude 3.5 Haiku (Fast)</option>
                                <option value="claude-3-5-sonnet-20241022">Claude 3.5 Sonnet (Best)</option>
                            </select>
                        </div>

                        <div class="setting-item">
                            <label for="setting-max-items">Max Items:</label>
                            <input type="number" id="setting-max-items" min="1" max="50" value="15">
                        </div>

                        <!-- Category-specific settings rendered dynamically -->
                        <div id="category-specific-settings"></div>
                    </div>
                </div>

                <!-- Status -->
                <div class="config-section status-section">
                    <label style="display: block; font-weight: 600; font-size: 13px; margin-bottom: 8px; color: var(--gray-700);">Status:</label>
                    <div class="status-info">
                        <div class="status-row">
                            <span>Last analyzed:</span>
                            <span id="last-analyzed-time">Never</span>
                        </div>
                        <div class="status-row">
                            <span>Estimated cost:</span>
                            <span id="estimated-cost">$0.0000</span>
                        </div>
                        <div class="status-row">
                            <span>Current count:</span>
                            <span id="current-count">0 items</span>
                        </div>
                    </div>
                </div>

                <!-- Actions -->
                <div class="config-actions">
                    <button onclick="aiConfigPanel.reanalyzeCategory()" class="btn-primary btn-reanalyze">
                        🔄 Re-analyze This Category
                    </button>

                    <button onclick="aiConfigPanel.saveConfig()" class="btn-secondary btn-save" disabled>
                        💾 Save Configuration
                    </button>

                    <button onclick="aiConfigPanel.resetToDefault()" class="btn-text btn-reset">
                        Reset to Default
                    </button>
                </div>

                <!-- Progress Indicator (shown during re-analysis) -->
                <div id="reanalysis-progress" class="progress-container" style="display: none;">
                    <div class="progress-spinner"></div>
                    <div class="progress-text">
                        Re-analyzing... <span id="progress-eta">~10s</span>
                    </div>
                </div>
            </div>
            <!-- End AI Config Panel -->
        </div>

        <!-- Main Content Column -->
        <div class="main-content-wrapper" style="display: flex; flex-direction: column; position: relative; overflow: visible;">
            <!-- AI Timeline Navigation (Sticky) -->
            <div id="ai-nav-container" class="ai-nav-container" style="display: none;">
                <!-- Navigation Tabs -->
                <div class="ai-nav-tabs">
                    <button class="ai-nav-tab all active" onclick="aiNavigator.filterByType('all')" data-type="all">
                        🌐 All
                        <span class="ai-count-badge" id="count-all">0</span>
                    </button>
                    <button class="ai-nav-tab highlights" onclick="aiNavigator.filterByType('highlights')" data-type="highlights">
                        ✨ Highlights
                        <span class="ai-count-badge" id="count-highlights">0</span>
                    </button>
                    <button class="ai-nav-tab questions" onclick="aiNavigator.filterByType('questions')" data-type="questions">
                        ❓ Questions
                        <span class="ai-count-badge" id="count-questions">0</span>
                    </button>
                    <button class="ai-nav-tab actionItems" onclick="aiNavigator.filterByType('actionItems')" data-type="actionItems">
                        ✅ Action Items
                        <span class="ai-count-badge" id="count-actionItems">0</span>
                    </button>
                    <button class="ai-nav-tab keyTerms" onclick="aiNavigator.filterByType('keyTerms')" data-type="keyTerms">
                        📚 Key Terms
                        <span class="ai-count-badge" id="count-keyTerms">0</span>
                    </button>
                    <button class="ai-nav-tab keyThemes" onclick="aiNavigator.filterByType('keyThemes')" data-type="keyThemes">
                        🎯 Themes
                        <span class="ai-count-badge" id="count-keyThemes">0</span>
                    </button>
                    <button class="ai-nav-tab topicChanges" onclick="aiNavigator.filterByType('topicChanges')" data-type="topicChanges">
                        🔀 Topic Changes
                        <span class="ai-count-badge" id="count-topicChanges">0</span>
                    </button>
                </div>

                <!-- Timeline Track -->
                <div class="timeline-container">
                    <div class="timeline-header">
                        <div class="timeline-title">Interactive Timeline</div>
                        <div class="timeline-duration" id="timeline-duration">0:00</div>
                    </div>
                    <div class="timeline-track-wrapper">
                        <div class="timeline-track" id="timeline-track">
                            <!-- Markers added dynamically -->
                        </div>
                    </div>
                    <div class="timeline-time-labels">
                        <span>0:00</span>
                        <span id="timeline-end-label">0:00</span>
                    </div>
                </div>
            </div>

            <!-- Editor Panel -->
            <div class="editor-panel">
            <div class="editor-toolbar">
                <div class="toolbar-group">
                    <button class="toolbar-btn" id="edit-mode-btn" title="Toggle Edit Mode" onclick="toggleEditMode()">
                        ✏️ Edit Mode: OFF
                    </button>
                </div>

                <div class="toolbar-group">
                    <button class="toolbar-btn" title="Undo" onclick="document.execCommand('undo')" id="undo-btn" disabled>
                        ↶
                    </button>
                    <button class="toolbar-btn" title="Redo" onclick="document.execCommand('redo')" id="redo-btn" disabled>
                        ↷
                    </button>
                </div>

                <div class="toolbar-group">
                    <button class="toolbar-btn" title="Bold" onclick="document.execCommand('bold')" id="bold-btn" disabled>
                        <strong>B</strong>
                    </button>
                    <button class="toolbar-btn" title="Italic" onclick="document.execCommand('italic')" id="italic-btn" disabled>
                        <em>I</em>
                    </button>
                    <button class="toolbar-btn" title="Underline" onclick="document.execCommand('underline')" id="underline-btn" disabled>
                        <u>U</u>
                    </button>
                </div>

                <div class="search-box">
                    <input type="text" class="search-input" id="quick-search" placeholder="Quick search..." onkeyup="quickSearch(this.value)">
                </div>

                <div class="toolbar-group">
                    <div class="dropdown">
                        <button class="toolbar-btn" onclick="toggleDownloadMenu()">
                            ⬇️ Download
                        </button>
                        <div class="dropdown-menu" id="download-menu">
                            <button class="dropdown-item" onclick="downloadTranscript('markdown')">
                                📝 Markdown (.md)
                            </button>
                            <button class="dropdown-item" onclick="downloadTranscript('text')">
                                📄 Plain Text (.txt)
                            </button>
                            <button class="dropdown-item" onclick="downloadTranscript('json')">
                                📊 JSON (.json)
                            </button>
                        </div>
                    </div>
                    <button class="toolbar-btn" onclick="copyAsMarkdown()">
                        📋 Copy MD
                    </button>
                </div>

                <button class="toolbar-btn" onclick="copyAllText()">
                    📋 Copy All
                </button>
            </div>

            <!-- Global Playback Controls - Fixed Bottom Bar -->
            <div id="global-playback-bar" class="global-playback-bar">
                <div class="global-playback-controls">
                    <!-- Rewind 15 seconds - Audible style circular arrow with number -->
                    <button class="skip-btn" onclick="skipBackward(15)" title="Rewind 15 seconds">
                        <svg viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M20 8C13.373 8 8 13.373 8 20s5.373 12 12 12 12-5.373 12-12" stroke="#1a1a1a" stroke-width="2.5" stroke-linecap="round"/>
                            <path d="M8 12V8h4" stroke="#1a1a1a" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
                            <text x="20" y="24" text-anchor="middle" font-size="11" font-weight="600" fill="#1a1a1a">15</text>
                        </svg>
                    </button>
                    <!-- Play/Pause - Audible style solid black circle -->
                    <button id="global-play-btn" class="global-play-btn" onclick="toggleGlobalPlayback()" title="Play/Pause (Space)">
                        <span class="play-icon">
                            <svg viewBox="0 0 24 24" fill="white" xmlns="http://www.w3.org/2000/svg">
                                <path d="M8 5v14l11-7z"/>
                            </svg>
                        </span>
                        <span class="pause-icon" style="display:none">
                            <svg viewBox="0 0 24 24" fill="white" xmlns="http://www.w3.org/2000/svg">
                                <path d="M6 4h4v16H6zM14 4h4v16h-4z"/>
                            </svg>
                        </span>
                    </button>
                    <!-- Forward 15 seconds - Audible style circular arrow with number -->
                    <button class="skip-btn" onclick="skipForward(15)" title="Forward 15 seconds">
                        <svg viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M20 8c6.627 0 12 5.373 12 12s-5.373 12-12 12S8 26.627 8 20" stroke="#1a1a1a" stroke-width="2.5" stroke-linecap="round"/>
                            <path d="M32 12V8h-4" stroke="#1a1a1a" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
                            <text x="20" y="24" text-anchor="middle" font-size="11" font-weight="600" fill="#1a1a1a">15</text>
                        </svg>
                    </button>
                    <div class="global-time-container">
                        <span id="global-current-time" class="global-time-display">00:00</span>
                        <span class="time-separator">/</span>
                        <span id="global-total-time" class="global-time-display">00:00</span>
                    </div>
                    <div class="global-scrubber-container">
                        <input type="range" id="global-scrubber" class="global-scrubber"
                               min="0" max="100" value="0" step="0.1"
                               oninput="onScrubberInput(this.value)"
                               onchange="onScrubberChange(this.value)">
                        <div id="scrubber-progress" class="scrubber-progress"></div>
                    </div>
                    <div class="global-chunk-indicator">
                        <span id="chunk-indicator">Chunk 0/0</span>
                    </div>
                    <select id="playback-speed" class="global-speed-select" onchange="setPlaybackSpeed(this.value)">
                        <option value="0.5">0.5x</option>
                        <option value="0.75">0.75x</option>
                        <option value="1" selected>1x</option>
                        <option value="1.25">1.25x</option>
                        <option value="1.5">1.5x</option>
                        <option value="1.75">1.75x</option>
                        <option value="2">2x</option>
                        <option value="2.25">2.25x</option>
                    </select>
                </div>
            </div>

            <div class="editor-content" id="editor-content">
                <!-- Paragraphs will be rendered here -->
            </div>
        </div>
    </div>

    <!-- Plugin Modal -->
    <div id="plugin-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeModal()">&times;</span>
            <h2 class="modal-title" id="modal-title">Plugin</h2>
            <div id="modal-body"></div>
        </div>
    </div>

    <!-- Session Info Modal -->
    <div id="session-info-modal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 600px;">
            <span class="modal-close" onclick="sessionInfoModal.close()">&times;</span>
            <h2 class="modal-title">ℹ️ Session Information</h2>
            <div id="session-info-body" style="padding: 16px 0;">
                <!-- Content will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Toast -->
    <div id="toast" class="toast"></div>

    <!-- Split Mode Toolbar -->
    <div id="split-toolbar" style="
        display: none;
        position: fixed;
        bottom: 100px;
        left: 50%;
        transform: translateX(-50%);
        background: white;
        border: 2px solid var(--danger);
        border-radius: 12px;
        padding: 16px 24px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.25);
        z-index: 2000;
        gap: 16px;
        align-items: center;
    ">
        <div style="display: flex; flex-direction: column; gap: 4px;">
            <span style="font-weight: 600; color: var(--danger); font-size: 15px;">✂️ Blade Tool Active</span>
            <span id="split-count" style="color: var(--gray-500); font-size: 13px;">Hover between words and click to cut</span>
        </div>
        <div style="display: flex; gap: 8px;">
            <button onclick="speakerSplitManager.saveSplits()" style="
                background: var(--success);
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 6px;
                cursor: pointer;
                font-weight: 600;
                font-size: 14px;
            ">✓ Save</button>
            <button onclick="speakerSplitManager.cancelSplit()" style="
                background: var(--gray-100);
                color: var(--gray-700);
                border: 1px solid var(--gray-300);
                padding: 10px 20px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 14px;
            ">Cancel</button>
        </div>
    </div>

    <!-- AI Timeline Tooltip -->
    <div id="timeline-tooltip" class="timeline-tooltip">
        <div class="tooltip-time" id="tooltip-time"></div>
        <div class="tooltip-summary" id="tooltip-summary"></div>
    </div>

    <!-- Preprocessor Scripts - Version 2 for cache busting -->
    <script src="https://d2l28rla2hk7np.cloudfront.net/transcript-preprocessor-boundary.js?v=2" onerror="console.error('Failed to load transcript-preprocessor-boundary.js')"></script>
    <script src="https://d2l28rla2hk7np.cloudfront.net/transcript-preprocessor-simple.js?v=2" onerror="console.error('Failed to load transcript-preprocessor-simple.js')"></script>
    <script src="https://d2l28rla2hk7np.cloudfront.net/transcript-preprocessor.js?v=2" onerror="console.error('Failed to load transcript-preprocessor.js')"></script>
    <script src="https://d2l28rla2hk7np.cloudfront.net/transcript-plugins.js?v=2" onerror="console.error('Failed to load transcript-plugins.js')"></script>

    <script>
        // Verify scripts loaded
        window.addEventListener('DOMContentLoaded', () => {
            console.log('=== Script Loading Status ===');
            console.log('TranscriptPreprocessor:', typeof window.TranscriptPreprocessor);
            console.log('TranscriptPreprocessorBoundary:', typeof window.TranscriptPreprocessorBoundary);
            console.log('TranscriptPreprocessorSimple:', typeof window.TranscriptPreprocessorSimple);
            console.log('TranscriptPluginManager:', typeof window.TranscriptPluginManager);
            console.log('============================');
        });
    </script>

    <script>
        // Configuration
        const config = {
            userPoolId: 'us-east-2_6sN45GbIh',
            userPoolClientId: '7sjtp1gd6buhs3a7b362pvod3a',
            identityPoolId: 'us-east-2:43b4ec02-d7c0-4c8b-a188-27b9d1f16287',
            region: 'us-east-2',
            apiUrl: 'https://5x0ygivhe1.execute-api.us-east-2.amazonaws.com/dev',
            s3ApiUrl: 'https://5x0ygivhe1.execute-api.us-east-2.amazonaws.com/dev',
            appUrl: 'https://d2l28rla2hk7np.cloudfront.net'
        };

        let transcriptData = null;
        let processedData = null;
        let currentSession = null;
        let preprocessor = null;
        let pluginManager = null;
        let audioCache = new Map();
        let speakerNames = {}; // Maps SPEAKER_XX -> display name

        // Audio playback state (legacy - being replaced by global playback)
        let currentAudio = null;
        let currentPlayingIndex = null;
        let currentPlayButton = null;
        let wordHighlightInterval = null;

        // Version for debugging cache issues
        const TRANSCRIPT_EDITOR_VERSION = '2.20.0-update-debug';
        console.log(`%c[Transcript Editor] Version: ${TRANSCRIPT_EDITOR_VERSION}`, 'color: #00ff00; font-weight: bold; font-size: 14px;');

        // Global Sequential Playback State
        const CHUNK_DURATION = 120; // seconds per chunk (2 minutes)

        // No fixed compensation - instead we detect when audio actually starts playing
        // by monitoring audio.currentTime advancement

        let globalPlaybackState = {
            isPlaying: false,
            currentChunkIndex: 0,      // Which chunk file we're playing (0-based)
            totalChunks: 0,            // Total number of chunk files
            absoluteTime: 0,           // Current position in absolute session time
            totalDuration: 0,          // Total session duration
            playbackRate: 1.0,         // Current playback speed
            chunkAudios: [],           // Preloaded Audio objects for each chunk
            chunkUrls: [],             // Presigned URLs for each chunk
            isScrubbing: false,        // True while user is dragging scrubber
            seekFloorTime: 0,          // Minimum highlight time after seek (prevents jumping before clicked word)
            currentCompensation: 0.5   // Current delay compensation (calculated per seek based on position)
        };

        // ========================================
        // Layer Management for Annotation Pipeline
        // ========================================
        // Photoshop-style Layer Manager
        // Layer 0: Raw Transcription (system, locked)
        // Layer 1: Speaker Chunks (system, editable)
        // Layer 100+: User-created annotation layers
        const layerManager = {
            // Default layer definitions (will be overwritten by session data)
            layers: {
                0: {
                    id: 0,
                    name: 'Raw Transcription',
                    type: 'system',
                    locked: true,
                    visible: true,
                    color: '#6b7280',
                    order: 0,
                    annotations: []
                },
                1: {
                    id: 1,
                    name: 'Speaker Chunks',
                    type: 'system',
                    locked: false,
                    visible: true,
                    color: '#3b82f6',
                    order: 1,
                    annotations: []
                },
                5: {
                    id: 5,
                    name: 'Annotations',
                    type: 'user',
                    locked: false,
                    visible: true,
                    color: '#f59e0b',
                    order: 2,
                    annotations: []
                }
            },
            layerOrder: [5, 1, 0], // Top to bottom (highest layer first)
            activeLayer: 5, // Currently selected layer for editing
            nextLayerId: 100, // Next ID for user-created layers

            // Get layers sorted by order (top to bottom for display)
            getOrderedLayers() {
                return this.layerOrder
                    .map(id => this.layers[id])
                    .filter(Boolean);
            },

            toggleVisibility(layerId) {
                if (this.layers[layerId]) {
                    this.layers[layerId].visible = !this.layers[layerId].visible;
                    this.renderLayerPanel();
                    this.applyLayerVisibility();
                    this.renderAnnotations();
                    console.log(`[Layer] ${layerId} visibility: ${this.layers[layerId].visible}`);
                }
            },

            // Apply visibility CSS classes based on layer state
            applyLayerVisibility() {
                const transcriptContent = document.getElementById('transcript-content');
                if (!transcriptContent) return;

                // Layer 1: Speaker Chunks - toggle speaker labels and split wrappers
                if (this.layers[1]?.visible) {
                    transcriptContent.classList.remove('hide-speaker-chunks');
                } else {
                    transcriptContent.classList.add('hide-speaker-chunks');
                }

                // Layer 0: Raw Transcription - always visible (base text)
                // No toggle needed - text is always shown
            },

            toggleLock(layerId) {
                const layer = this.layers[layerId];
                if (layer && layer.type !== 'system') {
                    // Can't unlock system layers that are always locked
                    if (layer.id === 0) return;
                    layer.locked = !layer.locked;
                    this.renderLayerPanel();
                    console.log(`[Layer] ${layerId} locked: ${layer.locked}`);
                }
            },

            selectLayer(layerId) {
                if (this.layers[layerId]) {
                    this.activeLayer = layerId;
                    this.renderLayerPanel();
                    console.log(`[Layer] Selected: ${layerId}`);
                }
            },

            // Legacy method for compatibility
            toggleLayer(layerId, visible) {
                if (this.layers[layerId]) {
                    this.layers[layerId].visible = visible;
                    this.renderLayerPanel();
                    this.applyLayerVisibility();
                    this.renderAnnotations();
                }
            },

            // Legacy method for compatibility
            setEditLayer(layerId) {
                this.activeLayer = layerId;
                this.renderLayerPanel();
            },

            // Alias for backward compatibility
            get currentEditLayer() {
                return this.activeLayer;
            },
            set currentEditLayer(value) {
                this.activeLayer = value;
            },

            async loadLayersForSession(sessionId) {
                try {
                    const response = await apiCall(`/api/sessions/${sessionId}/layers`);
                    console.log('[Layers] Raw response:', response);
                    if (response.layers) {
                        // Update layer data from backend
                        for (const [layerId, layerData] of Object.entries(response.layers)) {
                            const lid = parseInt(layerId);
                            console.log(`[Layers] Processing layer ${layerId} (parsed: ${lid}), status: ${layerData.status}, has data: ${!!layerData.data}`);

                            if (layerData.data?.annotations) {
                                console.log(`[Layers] Layer ${layerId} has ${layerData.data.annotations.length} annotations`);
                            }

                            // Layer 1 (Speaker Chunks) - chunk-split annotations
                            if (lid === 1) {
                                this.layers[1].annotations = layerData.data?.annotations || [];
                                console.log(`[Layers] Loaded ${this.layers[1].annotations.length} annotations into Speaker Chunks (layer 1)`);
                            }
                            // Layer 2 (legacy speaker chunks) - also goes to layer 1 for backward compat
                            else if (layerId === '2' && layerData.data?.annotations) {
                                // Merge with existing layer 1 annotations
                                const existing = this.layers[1].annotations || [];
                                this.layers[1].annotations = [...existing, ...layerData.data.annotations];
                                console.log(`[Layers] Merged ${layerData.data.annotations.length} legacy layer 2 annotations into Speaker Chunks`);
                            }
                            // User annotation layers (5, 6, 7)
                            else if (this.layers[lid] && layerData.data) {
                                this.layers[lid].annotations = layerData.data.annotations || [];
                                console.log(`[Layers] Loaded ${this.layers[lid].annotations.length} annotations into layer ${lid}`);
                            }
                        }
                    }
                    this.renderLayerPanel();
                } catch (err) {
                    console.log('Layers not yet available for session:', err.message);
                    this.renderLayerPanel();
                }
            },

            // Render the Photoshop-style layer panel
            renderLayerPanel() {
                const container = document.getElementById('layer-stack');
                if (!container) return;

                container.innerHTML = '';

                // Render layers top to bottom
                for (const layer of this.getOrderedLayers()) {
                    const item = document.createElement('div');
                    item.className = 'layer-item' +
                        (layer.id === this.activeLayer ? ' selected' : '') +
                        (layer.locked ? ' locked' : '') +
                        (!layer.visible ? ' hidden' : '');
                    item.dataset.layerId = layer.id;

                    // Eye icon (visibility)
                    const eyeBtn = document.createElement('button');
                    eyeBtn.className = 'layer-visibility' + (!layer.visible ? ' off' : '');
                    eyeBtn.innerHTML = layer.visible ? '👁' : '👁‍🗨';
                    eyeBtn.title = layer.visible ? 'Hide layer' : 'Show layer';
                    eyeBtn.onclick = (e) => {
                        e.stopPropagation();
                        this.toggleVisibility(layer.id);
                    };

                    // Lock icon
                    const lockBtn = document.createElement('button');
                    lockBtn.className = 'layer-lock';
                    lockBtn.innerHTML = layer.locked ? '🔒' : '🔓';
                    lockBtn.title = layer.locked ? 'Locked' : 'Unlocked';
                    if (layer.id === 0) {
                        lockBtn.disabled = true;
                        lockBtn.style.opacity = '0.5';
                    } else {
                        lockBtn.onclick = (e) => {
                            e.stopPropagation();
                            this.toggleLock(layer.id);
                        };
                    }

                    // Color swatch
                    const colorSwatch = document.createElement('div');
                    colorSwatch.className = 'layer-color';
                    colorSwatch.style.background = layer.color;

                    // Layer name
                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'layer-name';
                    nameSpan.textContent = layer.name;

                    // Annotation count
                    const countSpan = document.createElement('span');
                    countSpan.className = 'layer-count';
                    countSpan.textContent = layer.id === 0 ? '-' : (layer.annotations?.length || 0);

                    // Assemble
                    item.appendChild(eyeBtn);
                    item.appendChild(lockBtn);
                    item.appendChild(colorSwatch);
                    item.appendChild(nameSpan);
                    item.appendChild(countSpan);

                    // Click to select
                    item.onclick = () => this.selectLayer(layer.id);

                    container.appendChild(item);
                }
            },

            // Add a new user layer
            addLayer() {
                const name = prompt('Enter layer name:', `Layer ${this.nextLayerId}`);
                if (!name) return;

                const colors = ['#f59e0b', '#10b981', '#8b5cf6', '#ec4899', '#06b6d4', '#84cc16'];
                const color = colors[Object.keys(this.layers).length % colors.length];

                const newLayer = {
                    id: this.nextLayerId,
                    name: name,
                    type: 'user',
                    locked: false,
                    visible: true,
                    color: color,
                    order: this.layerOrder.length,
                    annotations: []
                };

                this.layers[this.nextLayerId] = newLayer;
                this.layerOrder.unshift(this.nextLayerId); // Add to top
                this.activeLayer = this.nextLayerId;
                this.nextLayerId++;

                this.renderLayerPanel();
                showToast(`Layer "${name}" created`);
            },

            // Delete a user layer
            deleteLayer(layerId) {
                const layer = this.layers[layerId];
                if (!layer || layer.type === 'system') {
                    showToast('Cannot delete system layer', 'error');
                    return;
                }

                if (!confirm(`Delete layer "${layer.name}"? This will remove all annotations in this layer.`)) {
                    return;
                }

                delete this.layers[layerId];
                this.layerOrder = this.layerOrder.filter(id => id !== layerId);

                // Select another layer if we deleted the active one
                if (this.activeLayer === layerId) {
                    this.activeLayer = this.layerOrder[0] || 5;
                }

                this.renderLayerPanel();
                this.renderAnnotations();
                showToast(`Layer deleted`);
            },

            async createAnnotation(type, target, data) {
                if (!currentSession?.folder) {
                    console.error('No session folder available');
                    return null;
                }

                // Route chunk-split annotations to Layer 1 (Speaker Chunks)
                // All other annotations go to the current edit layer
                const targetLayer = (type === 'chunk-split') ? 1 : this.currentEditLayer;
                console.log(`[Layer] Creating ${type} annotation in layer ${targetLayer}`);

                const sessionId = encodeURIComponent(currentSession.folder);
                const body = {
                    layerId: targetLayer,
                    type,
                    target,
                    data
                };

                try {
                    const response = await apiCall(`/api/sessions/${sessionId}/annotations`, {
                        method: 'POST',
                        body: JSON.stringify(body)
                    });

                    if (response.annotation) {
                        this.layers[targetLayer].annotations.push(response.annotation);
                        const countEl = document.getElementById(`layer-${targetLayer}-count`);
                        if (countEl) {
                            countEl.textContent = this.layers[targetLayer].annotations.length;
                        }
                        this.renderAnnotations();
                        showToast('Annotation saved');
                        return response.annotation;
                    }
                } catch (err) {
                    showToast('Failed to save annotation', 'error');
                    console.error('Create annotation error:', err);
                }
                return null;
            },

            async deleteAnnotation(annotationId) {
                if (!currentSession?.folder) {
                    console.error('No session folder available');
                    return false;
                }

                // Find which layer contains this annotation
                let foundLayerId = null;
                for (const [layerId, layer] of Object.entries(this.layers)) {
                    if (layer.annotations?.some(a => a.id === annotationId)) {
                        foundLayerId = layerId;
                        break;
                    }
                }

                if (!foundLayerId) {
                    console.error('Annotation not found in any layer:', annotationId);
                    return false;
                }

                const sessionId = encodeURIComponent(currentSession.folder);

                try {
                    await apiCall(`/api/sessions/${sessionId}/annotations/${annotationId}?layerId=${foundLayerId}`, {
                        method: 'DELETE'
                    });

                    // Remove from local layer data
                    for (const [layerId, layer] of Object.entries(this.layers)) {
                        if (layer.annotations) {
                            const idx = layer.annotations.findIndex(a => a.id === annotationId);
                            if (idx !== -1) {
                                layer.annotations.splice(idx, 1);
                                const countEl = document.getElementById(`layer-${layerId}-count`);
                                if (countEl) {
                                    countEl.textContent = layer.annotations.length;
                                }
                                console.log(`[Delete] Removed annotation from layer ${layerId}`);
                                break;
                            }
                        }
                    }

                    this.renderAnnotations();
                    showToast('Annotation deleted');
                    return true;
                } catch (err) {
                    showToast('Failed to delete annotation', 'error');
                    console.error('Delete annotation error:', err);
                    return false;
                }
            },

            getAllVisibleAnnotations() {
                const result = [];
                for (const [layerId, layer] of Object.entries(this.layers)) {
                    if (layer.visible && layer.annotations) {
                        for (const annotation of layer.annotations) {
                            result.push({ ...annotation, layerId: parseInt(layerId) });
                        }
                    }
                }
                return result;
            },

            renderAnnotations() {
                // Apply visible annotations to transcript display
                const annotations = this.getAllVisibleAnnotations();

                // Clear existing annotation highlights
                document.querySelectorAll('.annotation-highlight').forEach(el => {
                    el.classList.remove('annotation-highlight', 'annotation-tag', 'annotation-redaction', 'annotation-comment');
                });

                // Clear existing chunk-split segment wrappers (but not ones being actively edited)
                document.querySelectorAll('.segment-wrapper.saved').forEach(w => {
                    // Only move word-highlight elements back, NOT the chips
                    const wordsToMove = Array.from(w.querySelectorAll('.word-highlight'));
                    wordsToMove.forEach(word => {
                        w.parentNode.insertBefore(word, w);
                    });
                    w.remove(); // This removes the wrapper AND any chips inside it
                });

                // Restore hidden speaker labels and remove split class
                document.querySelectorAll('.has-split-annotation').forEach(el => {
                    el.classList.remove('has-split-annotation');
                    const speakerLabel = el.querySelector('.speaker-label');
                    if (speakerLabel) {
                        speakerLabel.style.display = '';
                    }
                });

                // Remove any orphaned segment speaker chips (from previous buggy cleanup)
                document.querySelectorAll('.segment-speaker-chip').forEach(c => {
                    // Only remove if it's not inside an active (non-saved) wrapper
                    if (!c.closest('.segment-wrapper:not(.saved)')) {
                        c.remove();
                    }
                });

                // Apply each annotation's styling
                for (const annotation of annotations) {
                    if (annotation.target?.chunkId) {
                        const chunkEl = document.querySelector(`[data-chunk-id="${annotation.target.chunkId}"]`);

                        // Handle chunk-split annotations
                        if (annotation.type === 'chunk-split' && chunkEl && annotation.data?.segments) {
                            this.renderChunkSplit(chunkEl, annotation);
                            continue;
                        }

                        if (chunkEl && annotation.target.wordStart !== undefined) {
                            // Highlight specific words
                            const words = chunkEl.querySelectorAll('.word-highlight');
                            for (let i = annotation.target.wordStart; i <= (annotation.target.wordEnd || annotation.target.wordStart); i++) {
                                if (words[i]) {
                                    words[i].classList.add('annotation-highlight');
                                    if (annotation.type === 'tag') words[i].classList.add('annotation-tag');
                                    if (annotation.type === 'redaction') words[i].classList.add('annotation-redaction');
                                    if (annotation.type === 'comment') words[i].classList.add('annotation-comment');
                                }
                            }
                        }
                    }
                }
            },

            renderChunkSplit(chunkEl, annotation) {
                const textEl = chunkEl.querySelector('.paragraph-text');
                if (!textEl) return;

                // CLEANUP: Remove any existing segment wrappers first (prevents duplication)
                textEl.querySelectorAll('.segment-wrapper').forEach(wrapper => {
                    // Move children (words) back out to textEl
                    while (wrapper.firstChild) {
                        // Skip speaker chips and delete buttons - just move word elements
                        const child = wrapper.firstChild;
                        if (child.classList?.contains('word-highlight')) {
                            textEl.insertBefore(child, wrapper);
                        } else {
                            wrapper.removeChild(child);
                        }
                    }
                    wrapper.remove();
                });

                const words = Array.from(textEl.querySelectorAll('.word-highlight'));
                const segments = annotation.data.segments;

                console.log('[Render] Applying chunk-split to', chunkEl.dataset.chunkId, 'with', segments.length, 'segments');

                // Hide the original paragraph speaker label since we're showing segment-level speakers
                const originalSpeakerLabel = chunkEl.querySelector(':scope > .speaker-label');
                console.log('[Render] Found speaker label:', originalSpeakerLabel, 'in chunk', chunkEl.dataset.chunkId);
                if (originalSpeakerLabel) {
                    originalSpeakerLabel.style.display = 'none';
                    originalSpeakerLabel.classList.add('hidden-by-split');
                    console.log('[Render] Hidden speaker label for', chunkEl.dataset.chunkId);
                }

                // Also hide the split button
                const splitBtn = chunkEl.querySelector(':scope > .split-speaker-btn');
                if (splitBtn) {
                    splitBtn.style.display = 'none';
                }

                // Add a class to indicate this paragraph has been split
                chunkEl.classList.add('has-split-annotation');
                console.log('[Render] Added has-split-annotation class to', chunkEl.dataset.chunkId);

                // STEP 1: Collect all word nodes for each segment BEFORE any DOM changes
                const segmentWordNodes = segments.map(seg => {
                    const wordNodes = [];
                    for (let i = seg.startWord; i <= seg.endWord && i < words.length; i++) {
                        wordNodes.push(words[i]);
                    }
                    return wordNodes;
                });

                // STEP 2: Ensure all words are direct children of textEl (flat structure)
                segmentWordNodes.flat().forEach(word => {
                    if (word.parentNode !== textEl) {
                        textEl.appendChild(word);
                    }
                });

                // STEP 3: Create ALL wrappers first (they will be siblings)
                const wrappers = segments.map((seg, segIdx) => {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'segment-wrapper saved';
                    wrapper.dataset.annotationId = annotation.id;
                    wrapper.style.cssText = `
                        display: block;
                        background: ${speakerSplitManager.getSegmentColor(segIdx)};
                        border-radius: 6px;
                        padding: 8px 12px;
                        margin: 8px 0;
                        border-left: 4px solid ${speakerSplitManager.getSegmentBorderColor(segIdx)};
                        position: relative;
                    `;

                    // Add speaker label - clickable to change speaker
                    const chip = document.createElement('span');
                    chip.className = 'segment-speaker-chip saved';
                    const displayName = speakerNames[seg.speaker] || seg.speaker;
                    chip.textContent = displayName + ' ▼';
                    chip.style.cssText = `
                        display: inline-block;
                        background: white;
                        border: 1px solid var(--gray-400);
                        border-radius: 12px;
                        padding: 4px 12px;
                        font-size: 12px;
                        margin-bottom: 6px;
                        margin-right: 8px;
                        font-weight: 600;
                        box-shadow: 0 1px 2px rgba(0,0,0,0.1);
                        cursor: pointer;
                    `;
                    chip.onclick = (e) => {
                        e.stopPropagation();
                        this.showSavedSpeakerPicker(chip, annotation, segIdx);
                    };
                    wrapper.appendChild(chip);

                    // Add delete button on first segment only (deletes the whole split)
                    if (segIdx === 0) {
                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'delete-split-btn';
                        deleteBtn.innerHTML = '×';
                        deleteBtn.title = 'Remove this split annotation';
                        deleteBtn.onclick = async (e) => {
                            console.log('[Delete] Button clicked, annotation:', annotation.id);
                            e.stopPropagation();
                            e.preventDefault();
                            console.log('[Delete] Showing confirm dialog...');
                            const confirmed = confirm('Remove this speaker split?');
                            console.log('[Delete] Confirmed:', confirmed);
                            if (confirmed) {
                                console.log('[Delete] Calling deleteAnnotation...');
                                const result = await layerManager.deleteAnnotation(annotation.id);
                                console.log('[Delete] Result:', result);
                            }
                        };
                        wrapper.appendChild(deleteBtn);
                    }

                    return wrapper;
                });

                // STEP 4: Append all wrappers to textEl as siblings
                wrappers.forEach(wrapper => {
                    textEl.appendChild(wrapper);
                });

                // STEP 5: Move words into their respective wrappers
                segments.forEach((seg, segIdx) => {
                    const wrapper = wrappers[segIdx];
                    const wordNodes = segmentWordNodes[segIdx];
                    wordNodes.forEach(word => wrapper.appendChild(word));
                });
            },

            // Show speaker picker for saved split annotations
            showSavedSpeakerPicker(chip, annotation, segmentIndex) {
                // Remove existing pickers
                document.querySelectorAll('.speaker-picker').forEach(p => p.remove());

                const picker = document.createElement('div');
                picker.className = 'speaker-picker';
                picker.style.cssText = `
                    position: absolute;
                    background: white;
                    border: 1px solid var(--gray-300);
                    border-radius: 8px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                    z-index: 1001;
                    padding: 8px;
                    min-width: 160px;
                `;

                // Get available speakers from transcript data
                const speakerList = processedData?.speakers || [];
                const speakers = speakerList.length > 0
                    ? speakerList.map(id => [id, speakerNames[id] || id])
                    : [['SPEAKER_00', 'Speaker 1'], ['SPEAKER_01', 'Speaker 2']];

                speakers.forEach(([id, name]) => {
                    const btn = document.createElement('button');
                    btn.textContent = name;
                    btn.style.cssText = `
                        display: block;
                        width: 100%;
                        padding: 8px 12px;
                        border: none;
                        background: white;
                        text-align: left;
                        cursor: pointer;
                        border-radius: 4px;
                        font-size: 13px;
                    `;
                    btn.onmouseenter = () => btn.style.background = 'var(--gray-100)';
                    btn.onmouseleave = () => btn.style.background = 'white';
                    btn.onclick = async () => {
                        // Update the annotation segment
                        annotation.data.segments[segmentIndex].speaker = id;
                        chip.textContent = name + ' ▼';
                        picker.remove();

                        // Save the updated annotation
                        await this.updateAnnotation(annotation);
                        showToast(`Speaker changed to ${name}`);
                    };
                    picker.appendChild(btn);
                });

                // Position picker below the chip
                const rect = chip.getBoundingClientRect();
                picker.style.left = `${rect.left}px`;
                picker.style.top = `${rect.bottom + 4}px`;
                picker.style.position = 'fixed';

                document.body.appendChild(picker);

                // Close picker when clicking outside
                const closeHandler = (e) => {
                    if (!picker.contains(e.target) && e.target !== chip) {
                        picker.remove();
                        document.removeEventListener('click', closeHandler);
                    }
                };
                setTimeout(() => document.addEventListener('click', closeHandler), 0);
            },

            // Update an existing annotation
            async updateAnnotation(annotation) {
                if (!currentSession?.folder) {
                    console.error('No session folder available');
                    return false;
                }

                console.log('[Update] Looking for annotation:', annotation.id);
                console.log('[Update] Current layers state:', Object.keys(this.layers).map(k =>
                    `Layer ${k}: ${this.layers[k].annotations?.length || 0} annotations`
                ));

                // Find which layer contains this annotation
                let foundLayerId = null;
                for (const [layerId, layer] of Object.entries(this.layers)) {
                    if (layer.annotations?.some(a => a.id === annotation.id)) {
                        foundLayerId = layerId;
                        console.log(`[Update] Found annotation in layer ${layerId}`);
                        break;
                    }
                }

                if (!foundLayerId) {
                    console.error('Annotation not found in any layer:', annotation.id);
                    console.log('[Update] Dumping all annotations for debugging:');
                    for (const [layerId, layer] of Object.entries(this.layers)) {
                        console.log(`  Layer ${layerId}:`, layer.annotations?.map(a => a.id) || []);
                    }
                    return false;
                }

                const sessionId = encodeURIComponent(currentSession.folder);

                // Convert to integer for backend
                const layerIdInt = parseInt(foundLayerId, 10);
                console.log(`[Update] Sending update to layer ${layerIdInt} (was string: "${foundLayerId}")`);

                try {
                    const response = await apiCall(`/api/sessions/${sessionId}/annotations/${annotation.id}`, {
                        method: 'PUT',
                        body: JSON.stringify({
                            layerId: layerIdInt,
                            data: annotation.data  // Backend expects 'data' field for partial update
                        })
                    });

                    console.log('[LayerManager] Annotation updated:', response);
                    return true;
                } catch (error) {
                    console.error('[LayerManager] Failed to update annotation:', error);
                    showToast('Failed to update annotation', 'error');
                    return false;
                }
            }
        };

        // Speaker Split/Reassign Manager - Video Editor Style (Blade Tool)
        // Split first, then assign speakers to resulting segments
        const speakerSplitManager = {
            activeChunkId: null,
            activeChunkEl: null,
            splits: [],           // Array of word indices where splits occur
            segments: [],         // Resulting segments with speaker assignments
            originalSpeaker: null,

            startSplit(chunkId) {
                console.log('[Split] startSplit called with chunkId:', chunkId);

                // Cancel any existing split
                if (this.activeChunkId) this.cancelSplit();

                this.activeChunkId = chunkId;
                this.splits = [];
                this.segments = [];

                const chunkEl = document.querySelector(`[data-chunk-id="${chunkId}"]`);
                console.log('[Split] Found element:', chunkEl);
                if (!chunkEl) {
                    console.error('[Split] Could not find element with data-chunk-id:', chunkId);
                    // Debug: list all elements with data-chunk-id
                    const allChunks = document.querySelectorAll('[data-chunk-id]');
                    console.log('[Split] Available chunk IDs:', Array.from(allChunks).map(el => el.dataset.chunkId));
                    return;
                }

                this.activeChunkEl = chunkEl;
                this.originalSpeaker = chunkEl.querySelector('.speaker-label')?.textContent || 'Unknown';

                // Enter split mode
                chunkEl.classList.add('split-mode');

                // Add blade cursor and click handlers between words
                const textEl = chunkEl.querySelector('.paragraph-text');
                if (textEl) {
                    this.setupBladeTool(textEl);
                }

                // Show toolbar
                const toolbar = document.getElementById('split-toolbar');
                if (toolbar) {
                    toolbar.style.display = 'flex';
                    this.updateToolbarStatus();
                }

                showToast('🔪 Blade mode: DOUBLE-CLICK between words to cut');
            },

            setupBladeTool(textEl) {
                const words = textEl.querySelectorAll('.word-highlight');
                console.log('[Blade] Setting up blade tool, found', words.length, 'words');

                words.forEach((word, idx) => {
                    // Create a clickable gap before each word (except first)
                    if (idx > 0) {
                        const blade = document.createElement('span');
                        blade.className = 'blade-target';
                        blade.dataset.splitIndex = idx;
                        blade.innerHTML = '|'; // Simple pipe character
                        blade.style.cssText = `
                            cursor: crosshair;
                            color: #ff6b6b;
                            padding: 2px 4px;
                            margin: 0 2px;
                            background: rgba(255, 107, 107, 0.1);
                            border-radius: 2px;
                            font-weight: bold;
                            display: inline-block;
                            user-select: none;
                        `;
                        blade.title = 'Double-click to cut here';
                        blade.onmouseenter = () => {
                            blade.style.background = 'rgba(255, 107, 107, 0.3)';
                            blade.style.color = '#ff0000';
                        };
                        blade.onmouseleave = () => {
                            if (!blade.classList.contains('cut')) {
                                blade.style.background = 'rgba(255, 107, 107, 0.1)';
                                blade.style.color = '#ff6b6b';
                            }
                        };
                        // Use double-click for intentional cutting (like video editors)
                        blade.ondblclick = (e) => {
                            e.stopPropagation();
                            e.preventDefault();
                            console.log('[Blade] Double-click cut at word index:', idx);
                            this.cutAt(idx, blade);
                        };
                        // Single click just prevents propagation
                        blade.onclick = (e) => {
                            e.stopPropagation();
                            e.preventDefault();
                            console.log('[Blade] Single click at index:', idx, '(double-click to cut)');
                        };
                        word.parentNode.insertBefore(blade, word);
                    }
                });
                console.log('[Blade] Created', words.length - 1, 'blade targets');
            },

            cutAt(wordIndex, bladeEl) {
                // Check if already cut here
                if (this.splits.includes(wordIndex)) {
                    // Remove the cut
                    this.splits = this.splits.filter(s => s !== wordIndex);
                    bladeEl.classList.remove('cut');
                    bladeEl.style.color = 'transparent';
                    bladeEl.innerHTML = '│';
                } else {
                    // Add new cut
                    this.splits.push(wordIndex);
                    this.splits.sort((a, b) => a - b);
                    bladeEl.classList.add('cut');
                    bladeEl.style.color = 'var(--danger)';
                    bladeEl.innerHTML = '✂️';
                }

                this.updateSegmentDisplay();
                this.updateToolbarStatus();
            },

            updateSegmentDisplay() {
                if (!this.activeChunkEl) return;

                const textEl = this.activeChunkEl.querySelector('.paragraph-text');
                const words = textEl.querySelectorAll('.word-highlight');

                // Remove existing segment wrappers
                textEl.querySelectorAll('.segment-wrapper').forEach(w => {
                    // Move children back out
                    while (w.firstChild) {
                        w.parentNode.insertBefore(w.firstChild, w);
                    }
                    w.remove();
                });

                if (this.splits.length === 0) {
                    this.segments = [];
                    return;
                }

                // Build segments based on splits
                const splitPoints = [0, ...this.splits, words.length];
                this.segments = [];

                for (let i = 0; i < splitPoints.length - 1; i++) {
                    const start = splitPoints[i];
                    const end = splitPoints[i + 1];
                    // First segment keeps original speaker, others get undefined_speaker_XX
                    const speaker = i === 0
                        ? this.originalSpeaker
                        : `undefined_speaker_${String(i).padStart(2, '0')}`;
                    this.segments.push({
                        startWord: start,
                        endWord: end - 1,
                        speaker: speaker
                    });
                }

                // IMPORTANT: Capture ALL nodes in a static array BEFORE modifying the DOM
                // This fixes the bug where processing segment 1 modifies the DOM,
                // causing segment 2 to miss elements that were moved into segment 1's wrapper
                const allNodes = [];
                let node = textEl.firstChild;
                let wordCount = 0;
                while (node) {
                    if (node.classList?.contains('word-highlight')) {
                        allNodes.push({ node, type: 'word', wordIndex: wordCount });
                        wordCount++;
                    } else if (node.classList?.contains('blade-target')) {
                        const bladeIdx = parseInt(node.dataset.splitIndex);
                        const isCut = node.classList.contains('cut');
                        allNodes.push({ node, type: 'blade', bladeIndex: bladeIdx, isCut });
                    }
                    node = node.nextSibling;
                }

                // Now assign each node to a segment
                const segmentNodes = this.segments.map(() => []);

                allNodes.forEach(item => {
                    if (item.type === 'word') {
                        // Find which segment this word belongs to
                        for (let segIdx = 0; segIdx < this.segments.length; segIdx++) {
                            const seg = this.segments[segIdx];
                            if (item.wordIndex >= seg.startWord && item.wordIndex <= seg.endWord) {
                                segmentNodes[segIdx].push(item.node);
                                break;
                            }
                        }
                    } else if (item.type === 'blade') {
                        // Blade at index X is positioned BEFORE word X
                        // Include in the segment that contains word X, OR
                        // if it's a cut blade, include at the END of the previous segment
                        for (let segIdx = 0; segIdx < this.segments.length; segIdx++) {
                            const seg = this.segments[segIdx];
                            // Non-cut blades go with their word (blade X goes with word X)
                            if (item.bladeIndex >= seg.startWord && item.bladeIndex <= seg.endWord) {
                                segmentNodes[segIdx].push(item.node);
                                break;
                            }
                            // Cut blade at segment boundary goes to the END of the previous segment
                            if (item.isCut && item.bladeIndex === seg.endWord + 1) {
                                segmentNodes[segIdx].push(item.node);
                                break;
                            }
                        }
                    }
                });

                // First, move ALL nodes back to textEl to ensure flat structure
                // This handles any case where nodes might be in nested wrappers
                segmentNodes.flat().forEach(node => {
                    if (node.parentNode !== textEl) {
                        textEl.appendChild(node);
                    }
                });

                // Now create ALL wrappers first, then populate them
                // This ensures wrappers are siblings, not nested
                const wrappers = this.segments.map((seg, segIdx) => {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'segment-wrapper';
                    wrapper.dataset.segmentIndex = segIdx;
                    wrapper.style.cssText = `
                        display: block;
                        background: ${this.getSegmentColor(segIdx)};
                        border-radius: 6px;
                        padding: 8px 12px;
                        margin: 8px 0;
                        border-left: 4px solid ${this.getSegmentBorderColor(segIdx)};
                        position: relative;
                    `;

                    // Add speaker selector chip
                    const chip = document.createElement('span');
                    chip.className = 'segment-speaker-chip';
                    chip.style.cssText = `
                        display: inline-block;
                        background: white;
                        border: 1px solid var(--gray-400);
                        border-radius: 12px;
                        padding: 4px 12px;
                        font-size: 12px;
                        margin-bottom: 6px;
                        margin-right: 8px;
                        cursor: pointer;
                        font-weight: 600;
                        box-shadow: 0 1px 2px rgba(0,0,0,0.1);
                    `;
                    // Use display name if available
                    const displayName = speakerNames[seg.speaker] || seg.speaker || '👤 Assign...'
                    chip.textContent = displayName + ' ▼';
                    chip.onclick = (e) => {
                        e.stopPropagation();
                        this.showSpeakerPicker(chip, segIdx);
                    };
                    wrapper.appendChild(chip);

                    return wrapper;
                });

                // Insert all wrappers into textEl as siblings
                wrappers.forEach(wrapper => {
                    textEl.appendChild(wrapper);
                });

                // Now move nodes into their respective wrappers
                this.segments.forEach((seg, segIdx) => {
                    const nodesForSegment = segmentNodes[segIdx];
                    const wrapper = wrappers[segIdx];
                    nodesForSegment.forEach(n => wrapper.appendChild(n));
                });
            },

            getSegmentColor(index) {
                const colors = [
                    'rgba(59, 130, 246, 0.15)',   // blue
                    'rgba(16, 185, 129, 0.15)',   // green
                    'rgba(245, 158, 11, 0.15)',   // amber
                    'rgba(139, 92, 246, 0.15)',   // purple
                    'rgba(236, 72, 153, 0.15)',   // pink
                    'rgba(6, 182, 212, 0.15)',    // cyan
                ];
                return colors[index % colors.length];
            },

            getSegmentBorderColor(index) {
                const colors = [
                    'rgb(59, 130, 246)',   // blue
                    'rgb(16, 185, 129)',   // green
                    'rgb(245, 158, 11)',   // amber
                    'rgb(139, 92, 246)',   // purple
                    'rgb(236, 72, 153)',   // pink
                    'rgb(6, 182, 212)',    // cyan
                ];
                return colors[index % colors.length];
            },

            showSpeakerPicker(chip, segmentIndex) {
                // Remove existing pickers
                document.querySelectorAll('.speaker-picker').forEach(p => p.remove());

                const picker = document.createElement('div');
                picker.className = 'speaker-picker';
                picker.style.cssText = `
                    position: absolute;
                    background: white;
                    border: 1px solid var(--gray-300);
                    border-radius: 8px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                    z-index: 1001;
                    padding: 8px;
                    min-width: 160px;
                `;

                // Get available speakers from transcript data
                const speakerList = processedData?.speakers || [];
                const speakers = speakerList.length > 0
                    ? speakerList.map(id => [id, speakerNames[id] || id])
                    : [['SPEAKER_00', 'Speaker 1'], ['SPEAKER_01', 'Speaker 2']];

                console.log('[SpeakerPicker] Available speakers:', speakers);

                speakers.forEach(([id, name]) => {
                    const btn = document.createElement('button');
                    btn.textContent = name;
                    btn.style.cssText = `
                        display: block;
                        width: 100%;
                        padding: 8px 12px;
                        border: none;
                        background: white;
                        text-align: left;
                        cursor: pointer;
                        border-radius: 4px;
                        font-size: 13px;
                    `;
                    btn.onmouseenter = () => btn.style.background = 'var(--gray-100)';
                    btn.onmouseleave = () => btn.style.background = 'white';
                    btn.onclick = () => {
                        this.segments[segmentIndex].speaker = id;  // Store the ID
                        chip.textContent = name + ' ▼';  // Display name with dropdown arrow
                        picker.remove();
                        this.updateToolbarStatus();
                    };
                    picker.appendChild(btn);
                });

                // Add new speaker option
                const newBtn = document.createElement('button');
                newBtn.textContent = '+ New Speaker';
                newBtn.style.cssText = `
                    display: block;
                    width: 100%;
                    padding: 8px 12px;
                    border: none;
                    border-top: 1px solid var(--gray-200);
                    background: white;
                    text-align: left;
                    cursor: pointer;
                    border-radius: 4px;
                    font-size: 13px;
                    color: var(--primary);
                    margin-top: 4px;
                `;
                newBtn.onclick = () => {
                    const name = prompt('Enter speaker name:');
                    if (name) {
                        this.segments[segmentIndex].speaker = name;
                        chip.textContent = name;
                        this.updateToolbarStatus();
                    }
                    picker.remove();
                };
                picker.appendChild(newBtn);

                // Position picker
                const rect = chip.getBoundingClientRect();
                picker.style.left = `${rect.left}px`;
                picker.style.top = `${rect.bottom + 4}px`;
                picker.style.position = 'fixed';

                document.body.appendChild(picker);

                // Close on outside click
                setTimeout(() => {
                    const close = (e) => {
                        if (!picker.contains(e.target)) {
                            picker.remove();
                            document.removeEventListener('click', close);
                        }
                    };
                    document.addEventListener('click', close);
                }, 0);
            },

            updateToolbarStatus() {
                const countEl = document.getElementById('split-count');
                if (!countEl) return;

                if (this.splits.length === 0) {
                    countEl.textContent = 'Click between words to cut';
                } else {
                    const assigned = this.segments.filter(s => s.speaker).length;
                    const total = this.segments.length;
                    countEl.textContent = `${this.splits.length} cut${this.splits.length !== 1 ? 's' : ''} • ${assigned}/${total} speakers assigned`;
                }
            },

            async saveSplits() {
                if (!this.activeChunkId || this.splits.length === 0) {
                    showToast('No cuts to save', 'error');
                    return;
                }

                // Check all segments have speakers
                const unassigned = this.segments.filter(s => !s.speaker);
                if (unassigned.length > 0) {
                    showToast(`Please assign speakers to all ${unassigned.length} segment(s)`, 'error');
                    return;
                }

                // Create chunk-split annotation
                const annotation = await layerManager.createAnnotation('chunk-split', {
                    chunkId: this.activeChunkId,
                    originalText: this.activeChunkEl?.querySelector('.paragraph-text')?.textContent
                }, {
                    splits: this.splits,
                    segments: this.segments
                });

                if (annotation) {
                    showToast(`✅ Split saved: ${this.segments.length} segments`);
                    // Cancel edit mode first, then re-render to show saved split
                    this.cancelSplit();
                    // Re-render annotations to show the saved split permanently
                    layerManager.renderAnnotations();
                } else {
                    this.cancelSplit();
                }
            },

            cancelSplit() {
                if (this.activeChunkEl) {
                    this.activeChunkEl.classList.remove('split-mode');

                    // Remove blade targets and segment wrappers
                    this.activeChunkEl.querySelectorAll('.blade-target').forEach(b => b.remove());
                    this.activeChunkEl.querySelectorAll('.segment-wrapper').forEach(w => {
                        while (w.firstChild) {
                            w.parentNode.insertBefore(w.firstChild, w);
                        }
                        w.remove();
                    });
                    this.activeChunkEl.querySelectorAll('.segment-speaker-chip').forEach(c => c.remove());
                }

                this.activeChunkId = null;
                this.activeChunkEl = null;
                this.splits = [];
                this.segments = [];

                // Hide toolbar
                const toolbar = document.getElementById('split-toolbar');
                if (toolbar) {
                    toolbar.style.display = 'none';
                }
            }
        };

        // Auth functions
        function getAuthToken() {
            return localStorage.getItem('id_token');
        }

        function getUserEmail() {
            try {
                const token = getAuthToken();
                if (token) {
                    const payload = JSON.parse(atob(token.split('.')[1]));
                    return payload.email || payload.sub || 'User';
                }
            } catch (e) {
                console.error('Error parsing token:', e);
            }
            return 'User';
        }

        function getUserId() {
            try {
                const token = getAuthToken();
                if (token) {
                    const payload = JSON.parse(atob(token.split('.')[1]));
                    return payload.sub;
                }
            } catch (e) {
                console.error('Error parsing token for userId:', e);
            }
            return null;
        }

        function logout() {
            localStorage.clear();
            window.location.href = 'index.html';
        }

        // API calls
        async function apiCall(endpoint, options = {}) {
            const token = getAuthToken();
            const response = await fetch(`${config.apiUrl}${endpoint}`, {
                ...options,
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json',
                    ...options.headers
                }
            });

            if (!response.ok) {
                // Handle auth errors - redirect to login instead of spinning
                if (response.status === 401 || response.status === 403) {
                    console.error('Session expired or unauthorized - redirecting to login');
                    localStorage.clear();
                    window.location.href = 'index.html';
                    return; // Stop execution
                }
                throw new Error(`API call failed: ${response.statusText}`);
            }

            return await response.json();
        }

        // Initialize
        window.addEventListener('DOMContentLoaded', async () => {
            const token = getAuthToken();
            if (!token) {
                window.location.href = 'index.html';
                return;
            }

            // Validate token
            try {
                const payload = JSON.parse(atob(token.split('.')[1]));
                const now = Math.floor(Date.now() / 1000);
                if (payload.exp && payload.exp < now) {
                    localStorage.clear();
                    window.location.href = 'index.html';
                    return;
                }
            } catch (e) {
                window.location.href = 'index.html';
                return;
            }

            document.getElementById('user-email').textContent = getUserEmail();
            document.getElementById('logout-btn').onclick = logout;

            // Initialize preprocessor and plugin manager
            console.log('Initializing TranscriptPreprocessor (boundary mode)...');
            preprocessor = new TranscriptPreprocessorBoundary({
                maxBoundaryWords: 10  // Only option for boundary preprocessor
            });
            console.log('Preprocessor initialized:', preprocessor);

            pluginManager = new UIPluginManager();

            // Initialize layer panel
            layerManager.renderLayerPanel();

            // Setup timezone selector
            setupTimezoneSelector();

            await loadLatestSession();
        });

        // Setup timezone selector with auto-detection
        function setupTimezoneSelector() {
            const selector = document.getElementById('timezone-selector');

            // Try to auto-detect user's timezone
            try {
                const userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                console.log('Detected user timezone:', userTimezone);

                // Check if detected timezone is in our list
                const option = Array.from(selector.options).find(opt => opt.value === userTimezone);
                if (option) {
                    selector.value = userTimezone;
                    selectedTimezone = userTimezone;
                    console.log('Set timezone to detected:', userTimezone);
                } else {
                    // Default to UTC
                    selectedTimezone = 'UTC';
                }
            } catch (e) {
                console.error('Failed to detect timezone:', e);
                selectedTimezone = 'UTC';
            }

            // Add change handler
            selector.onchange = (e) => {
                selectedTimezone = e.target.value;
                console.log('Timezone changed to:', selectedTimezone);

                // Update session selector display names
                populateSessionSelector();

                showToast(`Timezone changed to ${selectedTimezone}`, 'success');
            };
        }

        // Store all sessions
        let allSessions = [];
        let selectedTimezone = 'UTC'; // Default timezone

        // Parse session folder timestamp
        // Formats: session_YYYY-MM-DDTHH_MM_SS_MMMZ (new)
        //      or: YYYY-MM-DD-session_YYYY-MM-DDTHH_MM_SS_MMMZ (legacy)
        function parseSessionTimestamp(folderName) {
            try {
                // Extract timestamp from folder name
                const match = folderName.match(/session_(\d{4})-(\d{2})-(\d{2})T(\d{2})_(\d{2})_(\d{2})_(\d{3})Z/);
                if (!match) return null;

                const [, year, month, day, hour, minute, second, ms] = match;
                // Create UTC date string
                const isoString = `${year}-${month}-${day}T${hour}:${minute}:${second}.${ms}Z`;
                return new Date(isoString);
            } catch (e) {
                console.error('Failed to parse session timestamp:', folderName, e);
                return null;
            }
        }

        // Format session display name with timezone conversion
        function formatSessionName(folderName, timezone) {
            const date = parseSessionTimestamp(folderName);
            if (!date) {
                // Fallback to original format
                return folderName.replace('session_', '').replace(/-session_/g, ' ');
            }

            try {
                // Create a more readable format: "Nov 18, 2025 8:35 PM PST"
                const dateOptions = {
                    timeZone: timezone,
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric'
                };

                const timeOptions = {
                    timeZone: timezone,
                    hour: 'numeric',
                    minute: '2-digit',
                    hour12: true
                };

                const datePart = new Intl.DateTimeFormat('en-US', dateOptions).format(date);
                const timePart = new Intl.DateTimeFormat('en-US', timeOptions).format(date);

                // Get timezone abbreviation
                const tzAbbr = timezone === 'UTC' ? 'UTC' :
                              new Intl.DateTimeFormat('en-US', { timeZone: timezone, timeZoneName: 'short' })
                                .formatToParts(date)
                                .find(part => part.type === 'timeZoneName')?.value || '';

                return `${datePart} ${timePart} ${tzAbbr}`;
            } catch (e) {
                console.error('Failed to format session name:', e);
                return folderName.replace('session_', '').replace(/-session_/g, ' ');
            }
        }

        // Load latest session
        async function loadLatestSession() {
            try {
                console.log('Loading latest session...');
                const data = await apiCall('/api/audio/sessions');
                console.log('Sessions loaded:', data.sessions?.length || 0);

                if (!data.sessions || data.sessions.length === 0) {
                    // Show empty state for no sessions
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('main-container').style.display = 'grid';

                    const editorContent = document.querySelector('.editor-content');
                    editorContent.innerHTML = `
                        <div style="text-align: center; padding: 64px 32px; color: var(--gray-500);">
                            <div style="font-size: 48px; margin-bottom: 16px;">🎙️</div>
                            <h2 style="color: var(--gray-700); margin-bottom: 8px;">No Transcripts Found</h2>
                            <p>You haven't recorded any sessions yet.</p>
                            <p style="margin-top: 16px;">Start by recording a new session in the audio recorder.</p>
                        </div>
                    `;
                    showToast('No sessions found', 'error');
                    return;
                }

                // Filter sessions to only include those with transcriptions
                console.log('Filtering sessions with transcriptions...');
                const userId = getUserId();
                const sessionsWithTranscripts = await filterSessionsWithTranscripts(data.sessions, userId);

                console.log('Sessions with transcripts:', sessionsWithTranscripts.length);

                if (sessionsWithTranscripts.length === 0) {
                    // Show empty state
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('main-container').style.display = 'grid';

                    const editorContent = document.querySelector('.editor-content');
                    editorContent.innerHTML = `
                        <div style="text-align: center; padding: 64px 32px; color: var(--gray-500);">
                            <div style="font-size: 48px; margin-bottom: 16px;">📝</div>
                            <h2 style="color: var(--gray-700); margin-bottom: 8px;">No Transcriptions Available</h2>
                            <p>None of your sessions have been transcribed yet.</p>
                            <p style="margin-top: 16px;">Run batch transcription to generate transcripts.</p>
                        </div>
                    `;
                    showToast('No transcribed sessions found', 'error');
                    return;
                }

                // Store filtered sessions and populate dropdown
                allSessions = sessionsWithTranscripts;
                populateSessionSelector();

                // Load the first session
                currentSession = sessionsWithTranscripts[0];
                console.log('Current session:', currentSession);
                await loadAndProcessTranscript();
            } catch (error) {
                console.error('Error loading session:', error);
                showToast('Failed to load session: ' + error.message, 'error');
            }
        }

        // Filter sessions to only include those with transcription files
        async function filterSessionsWithTranscripts(sessions, userId) {
            const checks = await Promise.all(
                sessions.map(async (session) => {
                    try {
                        const sessionPath = `users/${userId}/audio/sessions/${session.folder}`;

                        // Check for preprocessed file first (fastest)
                        try {
                            const processedKey = `${sessionPath}/transcription-processed.json`;
                            await apiCall(`/api/s3/download/${encodeURIComponent(processedKey)}`);
                            return { session, hasTranscript: true };
                        } catch {
                            // No preprocessed file, check for individual chunks
                            const listResponse = await apiCall(`/api/s3/list?prefix=audio/sessions/${session.folder}/&userScope=true`);
                            const hasChunks = listResponse.files.some(f =>
                                f.displayKey.includes('transcription-chunk-') && f.displayKey.endsWith('.json')
                            );
                            return { session, hasTranscript: hasChunks };
                        }
                    } catch {
                        return { session, hasTranscript: false };
                    }
                })
            );

            return checks
                .filter(result => result.hasTranscript)
                .map(result => result.session);
        }

        // Populate session selector dropdown
        function populateSessionSelector() {
            const selector = document.getElementById('session-selector');
            selector.innerHTML = '';

            allSessions.forEach((session, index) => {
                const option = document.createElement('option');
                option.value = index;

                // Format session display name with timezone conversion
                option.textContent = formatSessionName(session.folder, selectedTimezone);

                selector.appendChild(option);
            });

            // Add change handler
            selector.onchange = async (e) => {
                const selectedIndex = parseInt(e.target.value);
                if (selectedIndex >= 0 && selectedIndex < allSessions.length) {
                    currentSession = allSessions[selectedIndex];
                    console.log('Switched to session:', currentSession);

                    // Stop any playing audio from previous session
                    stopAudio();

                    // Clear audio cache to prevent playing cached audio from previous session
                    audioCache.clear();

                    // Reset AI timeline navigator to clear previous session's data
                    aiNavigator.reset();

                    // Clean up scroll sync observer
                    cleanupScrollSync();

                    // Show loading state
                    document.getElementById('loading').style.display = 'flex';
                    document.getElementById('main-container').style.display = 'none';

                    // Load new session
                    await loadAndProcessTranscript();
                }
            };

            // Check for preprocessed files in background (non-blocking)
            checkPreprocessedFiles();
        }

        // Check which sessions have preprocessed files (runs in background)
        async function checkPreprocessedFiles() {
            const userId = getUserId();
            const selector = document.getElementById('session-selector');

            for (let index = 0; index < allSessions.length; index++) {
                const session = allSessions[index];
                try {
                    const sessionPath = `users/${userId}/audio/sessions/${session.folder}`;
                    const processedKey = `${sessionPath}/transcription-processed.json`;
                    await apiCall(`/api/s3/download/${encodeURIComponent(processedKey)}`);

                    // Update option to show lightning bolt
                    const option = selector.options[index];
                    if (option) {
                        const sessionDate = formatSessionName(session.folder, selectedTimezone);
                        option.textContent = `⚡ ${sessionDate}`;
                    }
                } catch {
                    // No preprocessed file, keep as-is
                }
            }
        }

        // Load and process transcript
        async function loadAndProcessTranscript() {
            try {
                console.log('Loading and processing transcript...');
                const userId = getUserId();
                const sessionFolder = currentSession.folder;
                console.log('User ID:', userId);
                console.log('Session folder:', sessionFolder);

                // Construct full S3 path
                const sessionPath = `users/${userId}/audio/sessions/${sessionFolder}`;
                console.log('Full session path:', sessionPath);

                // FAST PATH: Try to load user-edited file first, then diarized, then topic-segmented
                console.log('Checking for processed, diarized, or topic-segmented transcript...');

                // Priority order: processed (user edits) > diarized (speaker labels) > topic-segmented
                const processedKey = `${sessionPath}/transcription-processed.json`;
                const diarizedKey = `${sessionPath}/transcription-diarized.json`;
                const topicSegmentedKey = `${sessionPath}/transcription-topic-segmented.json`;

                let loadedFrom = null;

                // Try processed first (has user edits like speaker names)
                try {
                    const downloadData = await apiCall(`/api/s3/download/${encodeURIComponent(processedKey)}`);
                    const response = await fetch(downloadData.downloadUrl);
                    if (response.ok) {
                        const savedData = await response.json();
                        // Only use processed file if it has proper speaker data (paragraphs with speakers)
                        const hasSpeakers = savedData.paragraphs?.some(p => p.speaker) || savedData.speakers?.length > 0;
                        if (hasSpeakers) {
                            processedData = savedData;
                            loadedFrom = 'processed';
                            console.log('✅ Found processed transcript with speaker data - loading with user edits!');
                        } else {
                            console.log('⚠️ Processed file exists but has no speaker data, will try diarized instead...');
                        }
                    }
                } catch (e) {
                    console.log('No processed file, trying diarized...');
                }

                // Try diarized next (has speaker labels from diarization)
                if (!loadedFrom) {
                    try {
                        const downloadData = await apiCall(`/api/s3/download/${encodeURIComponent(diarizedKey)}`);
                        const response = await fetch(downloadData.downloadUrl);
                        if (response.ok) {
                            const diarizedData = await response.json();
                            // Convert diarized format (segments) to editor format (paragraphs)
                            if (diarizedData.segments && !diarizedData.paragraphs) {
                                const paragraphs = diarizedData.segments.map((seg, idx) => ({
                                    text: seg.text,
                                    startTime: seg.start,
                                    endTime: seg.end,
                                    start: seg.start,
                                    end: seg.end,
                                    speaker: seg.speaker,
                                    words: seg.words || [],
                                    chunkIds: ['chunk-001'],
                                    originalText: seg.text
                                }));

                                // Compute stats from paragraphs
                                const totalWords = paragraphs.reduce((sum, p) => sum + (p.text || '').split(/\s+/).filter(w => w).length, 0);
                                const totalDuration = paragraphs.length > 0 ?
                                    Math.max(...paragraphs.map(p => p.endTime || 0)) - Math.min(...paragraphs.map(p => p.startTime || 0)) : 0;

                                processedData = {
                                    paragraphs: paragraphs,
                                    speakers: diarizedData.speakers,
                                    diarization_metadata: diarizedData.diarization_metadata,
                                    stats: {
                                        paragraphCount: paragraphs.length,
                                        totalWords: totalWords,
                                        totalDuration: totalDuration,
                                        wordsPerMinute: totalDuration > 0 ? Math.round(totalWords / (totalDuration / 60)) : 0
                                    }
                                };
                            } else {
                                processedData = diarizedData;
                            }
                            loadedFrom = 'diarized';
                            console.log('✅ Found diarized transcript - loading with speaker labels!');
                        }
                    } catch (e) {
                        console.log('No diarized file, trying topic-segmented...');
                    }
                }

                // Fall back to topic-segmented
                if (!loadedFrom) {
                    try {
                        const downloadData = await apiCall(`/api/s3/download/${encodeURIComponent(topicSegmentedKey)}`);
                        const response = await fetch(downloadData.downloadUrl);
                        if (response.ok) {
                            processedData = await response.json();
                            loadedFrom = 'topic-segmented';
                            console.log('✅ Found topic-segmented transcript - loading with topic breaks!');
                        }
                    } catch (e) {
                        console.log('No topic-segmented file either');
                    }
                }

                if (loadedFrom) {
                    // Render
                    renderEditor();

                    // Initialize global playback controls
                    await initGlobalPlayback();

                    // Try to load AI analysis
                    await loadAIAnalysis();

                    // Load annotations for this session (if any)
                    if (currentSession?.folder) {
                        await layerManager.loadLayersForSession(encodeURIComponent(currentSession.folder));
                        layerManager.renderAnnotations();
                    }

                    // Hide loading, show content
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('main-container').style.display = 'grid';

                    const topicInfo = processedData.metadata?.topicCount
                        ? ` with ${processedData.metadata.topicCount} topics`
                        : '';
                    showToast(`Loaded ${processedData.paragraphs.length} paragraphs${topicInfo} (${loadedFrom})`);
                    return; // Done! Exit early
                }

                // FALLBACK PATH: Load individual chunks (slower, but works for in-progress transcriptions)
                console.log('Listing transcription chunk files...');
                const listResponse = await apiCall(`/api/s3/list?prefix=audio/sessions/${sessionFolder}/&userScope=true`);

                const chunkFiles = listResponse.files
                    .filter(f => f.displayKey.includes('transcription-chunk-') && f.displayKey.endsWith('.json'))
                    .sort((a, b) => {
                        const aNum = parseInt(a.displayKey.match(/chunk-(\d+)\.json/)?.[1] || '0');
                        const bNum = parseInt(b.displayKey.match(/chunk-(\d+)\.json/)?.[1] || '0');
                        return aNum - bNum;
                    });

                console.log('Found chunk files:', chunkFiles.length);
                console.log('Chunk files:', chunkFiles.map(f => f.displayKey).join(', '));

                if (chunkFiles.length === 0) {
                    // No transcription files - show empty state
                    console.log('No transcription files found - showing empty state');

                    // Show main container so user can select different session
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('main-container').style.display = 'grid';

                    // Show message in editor area
                    const editorContent = document.querySelector('.editor-content');
                    editorContent.innerHTML = `
                        <div style="text-align: center; padding: 64px 32px; color: var(--gray-500);">
                            <div style="font-size: 48px; margin-bottom: 16px;">📝</div>
                            <h2 style="color: var(--gray-700); margin-bottom: 8px;">No Transcription Available</h2>
                            <p>This session hasn't been transcribed yet.</p>
                            <p style="margin-top: 16px;">Select a different session from the dropdown above, or run batch transcription.</p>
                        </div>
                    `;

                    showToast('No transcription files found for this session', 'error');
                    return;
                }

                // Load all chunks IN PARALLEL (much faster than sequential)
                console.log('Loading chunk data in parallel...');
                const chunkPromises = chunkFiles.map(async (chunkFile) => {
                    const downloadData = await apiCall(`/api/s3/download/${encodeURIComponent(chunkFile.key)}`);
                    const response = await fetch(downloadData.downloadUrl);

                    if (response.ok) {
                        const chunkData = await response.json();
                        const chunkNum = parseInt(chunkFile.displayKey.match(/chunk-(\d+)\.json/)?.[1] || '0');
                        return {
                            chunkIndex: chunkNum,
                            chunkId: `chunk-${String(chunkNum).padStart(3, '0')}`,
                            ...chunkData
                        };
                    }
                    return null;
                });

                const chunks = (await Promise.all(chunkPromises)).filter(c => c !== null);

                // Process with preprocessor
                console.log('Processing chunks with boundary deduplication...');
                processedData = preprocessor.process(chunks);

                // Render
                renderEditor();

                // Initialize global playback controls
                await initGlobalPlayback();

                // Try to load AI analysis
                await loadAIAnalysis();

                // Load annotations for this session (if any)
                if (currentSession?.folder) {
                    await layerManager.loadLayersForSession(encodeURIComponent(currentSession.folder));
                    layerManager.renderAnnotations();
                }

                // Hide loading, show content
                document.getElementById('loading').style.display = 'none';
                document.getElementById('main-container').style.display = 'grid';

                showToast(`Processed ${processedData.paragraphs.length} paragraphs from ${chunks.length} chunks (slower fallback - run 518 script to speed up)`);
            } catch (error) {
                console.error('Error loading transcript:', error);
                showToast('Failed to load transcript: ' + error.message, 'error');
            }
        }

        // Load AI analysis if available
        async function loadAIAnalysis() {
            try {
                const hasAnalysis = await aiNavigator.loadAnalysis();
                if (hasAnalysis) {
                    aiNavigator.render();
                    console.log('✅ AI Timeline Navigation enabled');

                    // Initialize scroll sync after timeline is rendered
                    initializeScrollSync();
                } else {
                    console.log('ℹ️  No AI analysis - timeline hidden');
                }
            } catch (error) {
                console.error('Error loading AI analysis:', error);
                // Hide timeline if error
                document.getElementById('ai-nav-container').style.display = 'none';
            }
        }

        // ====================================================================
        // Scroll Sync: Auto-highlight timeline based on visible paragraph
        // ====================================================================

        let paragraphObserver = null;
        let currentlyHighlightedMarker = null;

        function initializeScrollSync() {
            // Clean up existing observer if any
            if (paragraphObserver) {
                paragraphObserver.disconnect();
            }

            // Create intersection observer
            // Trigger when paragraph is in center 40% of viewport
            const options = {
                root: null,
                rootMargin: '-30% 0px -30% 0px', // Center 40% of viewport
                threshold: 0
            };

            paragraphObserver = new IntersectionObserver((entries) => {
                // Find the most visible paragraph in the center zone
                let mostVisibleEntry = null;
                let maxVisibility = 0;

                entries.forEach(entry => {
                    if (entry.isIntersecting && entry.intersectionRatio > maxVisibility) {
                        maxVisibility = entry.intersectionRatio;
                        mostVisibleEntry = entry;
                    }
                });

                if (mostVisibleEntry) {
                    const paraIndex = parseInt(mostVisibleEntry.target.dataset.paraIndex);
                    updateTimelineHighlight(paraIndex);
                }
            }, options);

            // Observe all paragraphs
            document.querySelectorAll('.paragraph[data-para-index]').forEach(para => {
                paragraphObserver.observe(para);
            });

            console.log('✅ Scroll sync initialized');
        }

        function updateTimelineHighlight(paraIndex) {
            if (!processedData || !processedData.paragraphs) return;

            const para = processedData.paragraphs[paraIndex];
            if (!para) return;

            // Get the time range for this paragraph
            const paraStart = para.start;
            const paraEnd = para.end;

            // Find timeline items that overlap with this paragraph
            const track = document.getElementById('timeline-track');
            if (!track) return;

            // Remove previous highlight
            if (currentlyHighlightedMarker) {
                currentlyHighlightedMarker.style.opacity = '';
                currentlyHighlightedMarker.style.transform = '';
                currentlyHighlightedMarker.style.zIndex = '';
            }

            // Find the first marker that overlaps with current paragraph
            const markers = track.querySelectorAll('.timeline-marker');
            let bestMarker = null;
            let bestOverlap = 0;

            markers.forEach(marker => {
                const markerStart = parseFloat(marker.dataset.start || marker.dataset.time);
                const markerEnd = parseFloat(marker.dataset.end || markerStart);

                // Calculate overlap between marker and paragraph
                const overlapStart = Math.max(markerStart, paraStart);
                const overlapEnd = Math.min(markerEnd, paraEnd);
                const overlap = Math.max(0, overlapEnd - overlapStart);

                if (overlap > bestOverlap) {
                    bestOverlap = overlap;
                    bestMarker = marker;
                }
            });

            // Highlight the best matching marker
            if (bestMarker && bestOverlap > 0) {
                bestMarker.style.opacity = '1';
                bestMarker.style.transform = 'scale(1.15)';
                bestMarker.style.zIndex = '100';
                bestMarker.style.transition = 'all 0.3s ease';
                currentlyHighlightedMarker = bestMarker;

                // Auto-scroll timeline to keep marker visible
                const timelineNav = document.querySelector('.ai-nav-tabs');
                if (timelineNav) {
                    const markerRect = bestMarker.getBoundingClientRect();
                    const navRect = timelineNav.getBoundingClientRect();

                    // Only scroll if marker is not visible in timeline
                    if (markerRect.left < navRect.left || markerRect.right > navRect.right) {
                        bestMarker.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
                    }
                }
            }
        }

        // Clean up observer when switching sessions
        function cleanupScrollSync() {
            if (paragraphObserver) {
                paragraphObserver.disconnect();
                paragraphObserver = null;
            }
            currentlyHighlightedMarker = null;
        }

        // Format questions in a paragraph (initial render, no word timing)
        function formatQuestionsInParagraph(textDiv, para) {
            const text = para.text;
            const questionPatterns = [
                /\?$/,  // Ends with question mark
                /^(what|where|when|why|who|whom|which|whose|how)\b/i,
                /^(is|are|was|were|do|does|did|can|could|will|would|should|have|has|had)\b/i,
            ];

            // Split into sentences keeping punctuation attached
            const sentences = text.split(/(?<=[.!?])\s+/);
            let hasQuestion = false;
            let formattedHTML = '';
            let questionIndex = 0;  // Track question number for alternating colors

            sentences.forEach((sentence, i) => {
                const trimmed = sentence.trim();
                if (!trimmed) return;

                // Check if this sentence is a question
                const isQuestion = questionPatterns.some(pattern => pattern.test(trimmed)) ||
                                 trimmed.includes('?');

                if (isQuestion) {
                    hasQuestion = true;
                    // Cycle through 4 shades
                    const shade = (questionIndex % 4) + 1;
                    formattedHTML += '<br><span class="question-highlight shade-' + shade + '">' + trimmed + '</span><br>';
                    questionIndex++;
                } else {
                    formattedHTML += trimmed;
                    if (i < sentences.length - 1) {
                        formattedHTML += ' ';
                    }
                }
            });

            // Apply formatting
            if (hasQuestion) {
                textDiv.innerHTML = formattedHTML;
                textDiv.parentElement?.classList.add('question-paragraph');
            } else {
                textDiv.textContent = text;
            }
        }

        // Render editor
        function renderEditor() {
            const container = document.getElementById('editor-content');
            container.innerHTML = '';

            // Update stats
            document.getElementById('stat-paragraphs').textContent = processedData.stats.paragraphCount;
            document.getElementById('stat-words').textContent = processedData.stats.totalWords;
            document.getElementById('stat-duration').textContent = formatDuration(processedData.stats.totalDuration);
            document.getElementById('stat-wpm').textContent = Math.round(processedData.stats.wordsPerMinute);

            // Show topic count if topic segmentation was performed
            if (processedData.metadata && processedData.metadata.topicCount) {
                document.getElementById('stat-topics').textContent = processedData.metadata.topicCount;
                document.getElementById('stat-topics-card').style.display = 'block';
            } else if (processedData.topicStats && processedData.topicStats.topicCount) {
                document.getElementById('stat-topics').textContent = processedData.topicStats.topicCount;
                document.getElementById('stat-topics-card').style.display = 'block';
            }

            // Show speaker count if diarization was performed
            if (processedData.speakers && processedData.speakers.length > 0) {
                document.getElementById('stat-speakers').textContent = processedData.speakers.length;
                document.getElementById('stat-speakers-card').style.display = 'block';
            } else if (processedData.diarization_metadata && processedData.diarization_metadata.num_speakers) {
                document.getElementById('stat-speakers').textContent = processedData.diarization_metadata.num_speakers;
                document.getElementById('stat-speakers-card').style.display = 'block';
            }

            // Build speaker index map for consistent colors
            const speakerList = processedData.speakers || [];
            const speakerIndexMap = {};
            speakerList.forEach((speaker, index) => {
                speakerIndexMap[speaker] = index;
            });

            // Populate speaker legend in sidebar
            populateSpeakerList(speakerList);

            // Track previous speaker to detect changes
            let previousSpeaker = null;

            // Render paragraphs
            processedData.paragraphs.forEach((para, index) => {
                const paraDiv = document.createElement('div');
                paraDiv.className = 'paragraph-container';
                paraDiv.id = `para-${index}`;

                // Add topic-start class if this paragraph starts a new topic
                // (set by script 524-segment-transcripts-by-topic.py)
                if (para.isTopicStart && index > 0) {
                    paraDiv.classList.add('topic-start');
                }

                const number = document.createElement('div');
                number.className = 'paragraph-number';
                number.textContent = index + 1;
                number.title = 'Click to play from here';
                number.onclick = (e) => {
                    // Skip if in split mode
                    if (speakerSplitManager.activeChunkId) {
                        console.log('[Number Click] Skipped - split mode active');
                        return;
                    }
                    onParagraphClick(index, e);
                };

                // Add speaker label if diarization data is available
                const speaker = para.speaker;
                if (speaker && speaker !== 'UNKNOWN') {
                    const speakerLabel = document.createElement('span');
                    speakerLabel.className = 'speaker-label';
                    const speakerIndex = speakerIndexMap[speaker] !== undefined ? speakerIndexMap[speaker] : 0;
                    speakerLabel.classList.add(`speaker-${speakerIndex % 6}`);
                    // Use custom name if available
                    speakerLabel.textContent = speakerNames[speaker] || speaker;
                    paraDiv.appendChild(speakerLabel);

                    // Mark speaker change
                    if (previousSpeaker && previousSpeaker !== speaker) {
                        paraDiv.classList.add('speaker-change');
                    }
                    previousSpeaker = speaker;

                    // Add split speaker button
                    const splitBtn = document.createElement('button');
                    splitBtn.className = 'split-speaker-btn';
                    splitBtn.innerHTML = '✂️ Split';
                    splitBtn.title = 'Split this chunk into multiple speakers';
                    // Always use unique para-${index} ID for split targeting
                    const uniqueParaId = `para-${index}`;
                    splitBtn.onclick = (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        console.log('[Split Button] Clicked! paraId:', uniqueParaId);
                        speakerSplitManager.startSplit(uniqueParaId);
                    };
                    paraDiv.appendChild(splitBtn);
                }

                // Add data-chunk-id for annotation targeting - use unique para-${index}
                paraDiv.dataset.chunkId = `para-${index}`;
                // Also store original chunk IDs for reference
                if (para.chunkIds?.length) {
                    paraDiv.dataset.originalChunkIds = para.chunkIds.join(',');
                }

                const text = document.createElement('div');
                text.className = 'paragraph-text';
                text.contentEditable = false;  // Start in read-only mode for text selection
                text.dataset.paraIndex = index;
                text.addEventListener('input', () => markEdited(index));

                // Apply word wrapping with timestamps on initial render
                // This enables word-level highlighting during global playback
                wrapWordsWithTimestamps(text, para);

                // Make entire paragraph clickable for seek
                paraDiv.classList.add('clickable-seek');
                paraDiv.onclick = (e) => {
                    // Skip if in split mode - let blade tool handle clicks
                    if (speakerSplitManager.activeChunkId) {
                        console.log('[Para Click] Skipped - split mode active');
                        return;
                    }
                    // Only trigger if not clicking on interactive elements
                    if (!e.target.closest('.chunk-badge') &&
                        !e.target.closest('.original-text-toggle') &&
                        !e.target.isContentEditable) {
                        onParagraphClick(index, e);
                    }
                };

                const meta = document.createElement('div');
                meta.className = 'paragraph-meta';

                // Time - now shows absolute session time
                const timeMeta = document.createElement('div');
                timeMeta.className = 'meta-item';
                timeMeta.innerHTML = `⏱️ ${formatTime(para.start)} - ${formatTime(para.end)}`;
                timeMeta.title = 'Click to play from this paragraph';

                // Chunk badges
                const chunkMeta = document.createElement('div');
                chunkMeta.className = 'meta-item';
                (para.chunkIds || []).forEach(chunkId => {
                    const badge = document.createElement('span');
                    badge.className = 'chunk-badge';
                    badge.textContent = chunkId;
                    badge.onclick = () => showChunkDetails(chunkId, index);
                    chunkMeta.appendChild(badge);
                });

                // Original text toggle
                const originalToggle = document.createElement('button');
                originalToggle.className = 'original-text-toggle';
                originalToggle.textContent = 'Show Original';
                originalToggle.onclick = () => toggleOriginal(index);

                meta.appendChild(timeMeta);
                meta.appendChild(chunkMeta);
                meta.appendChild(originalToggle);

                // Original text content (hidden by default)
                const originalContent = document.createElement('div');
                originalContent.className = 'original-text-content';
                originalContent.id = `original-${index}`;
                originalContent.textContent = para.segments ? para.segments.map(s => s.text).join(' ') : (para.originalText || para.text || '');

                paraDiv.appendChild(number);
                paraDiv.appendChild(text);
                paraDiv.appendChild(meta);
                paraDiv.appendChild(originalContent);

                container.appendChild(paraDiv);
            });
        }

        // Toggle play/pause
        async function togglePlayPause(index, button) {
            // If already playing this paragraph, pause it
            if (currentAudio && currentPlayingIndex === index) {
                if (currentAudio.paused) {
                    currentAudio.play();
                    button.textContent = '⏸ Pause';
                } else {
                    currentAudio.pause();
                    button.textContent = '▶ Play';
                }
                return;
            }

            // Stop any currently playing audio
            if (currentAudio) {
                stopAudio();
            }

            // Start playing this paragraph
            await playParagraph(index, button);
        }

        // Stop audio playback
        function stopAudio() {
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio = null;
            }

            if (wordHighlightInterval) {
                clearInterval(wordHighlightInterval);
                wordHighlightInterval = null;
            }

            // Clear highlighting
            document.querySelectorAll('.paragraph-text').forEach(el => el.classList.remove('playing'));
            document.querySelectorAll('.word-highlight').forEach(el => el.classList.remove('playing'));

            // Restore question formatting for the paragraph that was playing
            if (currentPlayingIndex !== null && processedData && processedData.paragraphs) {
                const para = processedData.paragraphs[currentPlayingIndex];
                const paraText = document.querySelector(`[data-para-index="${currentPlayingIndex}"]`);
                if (paraText && para) {
                    formatQuestionsInParagraph(paraText, para);
                }
            }

            // Reset button
            if (currentPlayButton) {
                currentPlayButton.textContent = '▶ Play';
                currentPlayButton = null;
            }

            currentPlayingIndex = null;
        }

        // Play paragraph audio with word-level highlighting
        async function playParagraph(index, button) {
            const para = processedData.paragraphs[index];
            const firstChunkId = para.chunkIds?.[0] || '';

            // Get paragraph start time - prefer first word's start if available (more reliable for topic-segmented)
            let paraStart = para.start;
            let paraEnd = para.end;

            // If para.words exists, use first/last word timing (more accurate for topic-segmented files)
            if (para.words && para.words.length > 0) {
                paraStart = para.words[0].start;
                paraEnd = para.words[para.words.length - 1].end;
                console.log(`Using word-level timing: start=${paraStart}, end=${paraEnd}`);
            }

            // Validate times - if end < start, the data is corrupted (spans multiple chunks)
            // In this case, just use the start time and play a reasonable duration
            if (paraEnd < paraStart) {
                console.warn(`Invalid paragraph times: start=${paraStart}, end=${paraEnd}. Using start time only.`);
                // Set end to a reasonable duration after start (e.g., remaining chunk time)
                paraEnd = paraStart + 60; // Play up to 60 seconds
            }

            // Try to extract chunk number from chunkId (e.g., "chunk-001" -> 1)
            let chunkIndex = parseInt(firstChunkId.match(/chunk-(\d+)/)?.[1] || '0');

            // If chunkId doesn't match "chunk-XXX" pattern (e.g., topic-segmented files with "topic-X"),
            // calculate the chunk based on the paragraph's start time
            // Live sessions use ~120 second chunks (2 minutes)
            const CHUNK_DURATION = 120; // seconds per chunk
            let chunkStartOffset = 0; // offset into the chunk file

            if (chunkIndex === 0 && paraStart > 0) {
                chunkIndex = Math.floor(paraStart / CHUNK_DURATION) + 1;
                // Calculate the offset within the chunk (paraStart is absolute, but chunk starts at 0)
                chunkStartOffset = paraStart - ((chunkIndex - 1) * CHUNK_DURATION);
                console.log(`Calculated chunk ${chunkIndex} from start time ${paraStart}s, seek offset ${chunkStartOffset}s`);
            }

            try {
                // Load audio chunk
                console.log('Attempting to load audio chunk:', chunkIndex);
                const audioUrl = await getChunkUrl(chunkIndex);
                console.log('Got audio URL, creating Audio element...');
                const audio = new Audio(audioUrl);

                // Add error handler before attempting to play
                audio.onerror = (e) => {
                    console.error('Audio element error:', e);
                    console.error('Audio error details:', {
                        error: audio.error,
                        code: audio.error?.code,
                        message: audio.error?.message,
                        url: audioUrl
                    });
                    showToast('Audio format not supported by browser', 'error');
                    stopAudio();
                    button.textContent = '▶ Play';
                };

                currentAudio = audio;
                currentPlayingIndex = index;
                currentPlayButton = button;

                // Highlight paragraph
                document.querySelectorAll('.paragraph-text').forEach(el => el.classList.remove('playing'));
                const paraText = document.querySelector(`[data-para-index="${index}"]`);
                paraText.classList.add('playing');

                // Wrap words in spans with timing data
                wrapWordsWithTimestamps(paraText, para);

                // Play segment
                // For topic-segmented files, use the calculated offset within the chunk
                // For regular files (with valid chunk-XXX IDs), use paraStart directly
                const seekTime = chunkStartOffset > 0 ? chunkStartOffset : paraStart;
                console.log('Setting currentTime to:', seekTime, '(chunkStartOffset:', chunkStartOffset, ', paraStart:', paraStart, ')');
                audio.currentTime = seekTime;
                console.log('Attempting to play audio...');
                await audio.play();
                console.log('Audio playing successfully');
                button.textContent = '⏸ Pause';

                // Check if this is an uploaded file (single continuous audio)
                const isUpload = (currentSession.sessionId && currentSession.sessionId.includes('-upload-')) ||
                                 (currentSession.metadata && currentSession.metadata.source === 'upload');

                // Update word highlighting as audio plays
                wordHighlightInterval = setInterval(() => {
                    if (!audio.paused) {
                        if (isUpload) {
                            // For uploads, highlight across all paragraphs
                            highlightCurrentWordGlobal(audio.currentTime);
                        } else {
                            // For live sessions, highlight only current paragraph
                            highlightCurrentWord(paraText, para, audio.currentTime);
                        }
                    }
                }, 50); // Update every 50ms for smooth highlighting

                audio.onended = () => {
                    stopAudio();
                    button.textContent = '▶ Play';
                };

                audio.ontimeupdate = () => {
                    // For uploaded files, don't stop at paragraph end - let it play continuously
                    if (!isUpload) {
                        // For topic-segmented files, calculate the end time within the chunk
                        const endTime = chunkStartOffset > 0
                            ? chunkStartOffset + (paraEnd - paraStart)  // relative end within chunk
                            : paraEnd;  // absolute time for regular files

                        if (audio.currentTime >= endTime) {
                            stopAudio();
                            button.textContent = '▶ Play';
                        }
                    }
                };

                audio.onpause = () => {
                    if (currentPlayButton === button) {
                        button.textContent = '▶ Play';
                    }
                };

                audio.onplay = () => {
                    if (currentPlayButton === button) {
                        button.textContent = '⏸ Pause';
                    }
                };

            } catch (error) {
                console.error('Audio playback error:', error);
                showToast('Failed to play audio', 'error');
                stopAudio();
                button.textContent = '▶ Play';
            }
        }

        // Wrap words in spans with timing data
        function wrapWordsWithTimestamps(paraText, para) {
            // Build word-level timing map
            // Topic-segmented files have para.words with exact timing
            // Regular files have para.segments that need to be split
            const wordTimings = [];

            if (para.words && para.words.length > 0) {
                // Use exact word-level timing from topic-segmented files
                para.words.forEach(w => {
                    wordTimings.push({
                        word: w.word.trim(),
                        start: w.start,
                        end: w.end
                    });
                });
            } else if (para.segments && para.segments.length > 0) {
                // Fall back to estimating from segments
                para.segments.forEach(segment => {
                    const words = segment.text.trim().split(/\s+/);
                    const segmentDuration = segment.end - segment.start;
                    const avgWordDuration = segmentDuration / words.length;

                    words.forEach((word, i) => {
                        const wordStart = segment.start + (i * avgWordDuration);
                        const wordEnd = wordStart + avgWordDuration;
                        wordTimings.push({
                            word: word,
                            start: wordStart,
                            end: wordEnd
                        });
                    });
                });
            } else {
                // No timing data available - fall back to simple text rendering
                console.log('No word timing data available, using simple text rendering');
                // Use simple question formatting as fallback
                formatQuestionsInParagraph(paraText, para);
                return;
            }

            // Detect questions in the paragraph text
            const questionPatterns = [
                /\?$/,  // Ends with question mark
                /^(what|where|when|why|who|whom|which|whose|how)\b/i,
                /^(is|are|was|were|do|does|did|can|could|will|would|should|have|has|had)\b/i,
            ];

            const sentences = para.text.split(/(?<=[.!?])\s+/);
            const questionSentences = new Set();

            sentences.forEach(sentence => {
                const isQuestion = questionPatterns.some(pattern => pattern.test(sentence.trim())) ||
                                 sentence.includes('?');
                if (isQuestion) {
                    questionSentences.add(sentence.trim());
                }
            });

            // Build HTML with word spans, detecting question boundaries
            let html = '';
            let currentText = '';
            let wordIndex = 0;
            let inQuestion = false;
            let questionIndex = 0;  // Track question number for alternating colors

            wordTimings.forEach((wt, i) => {
                currentText += (currentText ? ' ' : '') + wt.word;

                // Check if we're starting a question
                let startQuestion = false;
                for (const qSentence of questionSentences) {
                    if (qSentence.startsWith(currentText.trim())) {
                        startQuestion = true;
                        break;
                    }
                }

                // Add word span
                const wordSpan = `<span class="word-highlight" data-word-index="${i}" data-word-start="${wt.start}" data-word-end="${wt.end}">${wt.word}</span>`;

                // If starting a question, add break and open question span with shade
                if (startQuestion && !inQuestion) {
                    const shade = (questionIndex % 4) + 1;
                    html += '<br><span class="question-highlight shade-' + shade + '">';
                    inQuestion = true;
                }

                html += wordSpan;

                // Check if question ends (contains ? or !)
                if (inQuestion && (wt.word.includes('?') || wt.word.includes('!'))) {
                    html += '</span><br>';
                    inQuestion = false;
                    currentText = '';
                    questionIndex++;
                }

                // Add space between words
                if (i < wordTimings.length - 1) {
                    html += ' ';
                }
            });

            // Close any unclosed question span
            if (inQuestion) {
                html += '</span>';
            }

            paraText.innerHTML = html;

            // Mark paragraph if it contains questions
            if (questionSentences.size > 0) {
                paraText.parentElement?.classList.add('question-paragraph');
            }
        }

        // Highlight the current word being spoken (for single paragraph)
        function highlightCurrentWord(paraText, para, currentTime) {
            const words = paraText.querySelectorAll('.word-highlight');
            words.forEach(word => {
                const start = parseFloat(word.dataset.wordStart);
                const end = parseFloat(word.dataset.wordEnd);

                if (currentTime >= start && currentTime < end) {
                    word.classList.add('playing');
                } else {
                    word.classList.remove('playing');
                }
            });
        }

        // Highlight the current word across all paragraphs (for uploaded files)
        // Delegates to highlightCurrentWordWithScroll for consistent behavior
        function highlightCurrentWordGlobal(currentTime) {
            highlightCurrentWordWithScroll(currentTime);
        }

        // Get chunk URL
        async function getChunkUrl(chunkIndex) {
            if (audioCache.has(chunkIndex)) {
                return audioCache.get(chunkIndex);
            }

            const userId = getUserId();
            const sessionFolder = currentSession.folder;
            const metadata = currentSession.metadata || {};
            const isUpload = (currentSession.sessionId && currentSession.sessionId.includes('-upload-')) ||
                             metadata.source === 'upload';

            // For uploaded files, we need to find the actual file extension
            if (isUpload) {
                // Try to get extension from metadata
                let extension = 'webm'; // default
                if (metadata.originalFilename) {
                    const parts = metadata.originalFilename.split('.');
                    if (parts.length > 1) {
                        extension = parts[parts.length - 1];
                    }
                } else if (metadata.mimeType) {
                    // Map MIME type to extension
                    const mimeToExt = {
                        'audio/aac': 'aac',
                        'audio/x-m4a': 'm4a',
                        'audio/m4a': 'm4a',
                        'audio/mpeg': 'mp3',
                        'audio/mp3': 'mp3',
                        'audio/wav': 'wav',
                        'audio/x-wav': 'wav',
                        'audio/webm': 'webm'
                    };
                    extension = mimeToExt[metadata.mimeType] || 'webm';
                }

                const chunkKey = `users/${userId}/audio/sessions/${sessionFolder}/chunk-${String(chunkIndex + 1).padStart(3, '0')}.${extension}`;
                console.log('Loading uploaded audio chunk:', chunkKey);

                try {
                    const downloadData = await apiCall(`/api/s3/download/${encodeURIComponent(chunkKey)}`);
                    audioCache.set(chunkIndex, downloadData.downloadUrl);
                    return downloadData.downloadUrl;
                } catch (error) {
                    console.error(`Failed to get URL for uploaded chunk ${chunkIndex} with extension ${extension}:`, error);
                    // Try fallback extensions
                    const fallbackExts = ['m4a', 'aac', 'mp3', 'wav', 'webm'];
                    for (const ext of fallbackExts) {
                        if (ext === extension) continue; // Already tried
                        try {
                            const fallbackKey = `users/${userId}/audio/sessions/${sessionFolder}/chunk-${String(chunkIndex + 1).padStart(3, '0')}.${ext}`;
                            console.log('Trying fallback extension:', fallbackKey);
                            const downloadData = await apiCall(`/api/s3/download/${encodeURIComponent(fallbackKey)}`);
                            audioCache.set(chunkIndex, downloadData.downloadUrl);
                            return downloadData.downloadUrl;
                        } catch (fallbackError) {
                            // Continue to next extension
                        }
                    }
                    throw new Error(`Could not find audio file for chunk ${chunkIndex}`);
                }
            } else {
                // Live session - use .webm
                const chunkKey = `users/${userId}/audio/sessions/${sessionFolder}/chunk-${String(chunkIndex + 1).padStart(3, '0')}.webm`;

                const downloadData = await apiCall(`/api/s3/download/${encodeURIComponent(chunkKey)}`);
                audioCache.set(chunkIndex, downloadData.downloadUrl);
                return downloadData.downloadUrl;
            }
        }

        // ============================================================================
        // GLOBAL SEQUENTIAL PLAYBACK FUNCTIONS
        // ============================================================================

        /**
         * Initialize global playback - call this after transcript is loaded
         * Counts audio chunks, calculates total duration, sets up controls
         */
        async function initGlobalPlayback() {
            console.log('[Global Playback] Initializing...');

            // Reset state
            globalPlaybackState = {
                isPlaying: false,
                currentChunkIndex: 0,
                totalChunks: 0,
                absoluteTime: 0,
                totalDuration: 0,
                playbackRate: 1.0,
                chunkAudios: [],
                chunkUrls: [],
                isScrubbing: false
            };

            // Count chunks from the processed data
            if (!processedData || !processedData.paragraphs) {
                console.warn('[Global Playback] No processed data available');
                return;
            }

            const metadata = currentSession.metadata || {};
            const isUpload = (currentSession.sessionId && currentSession.sessionId.includes('-upload-')) ||
                             metadata.source === 'upload';

            // For uploads and topic-segmented files, get actual chunk count from metadata
            // The paragraph chunkIds may be "topic-1", "topic-2" etc which aren't actual audio files
            let actualChunkCount = 1; // Default to 1 for uploads

            if (metadata.chunks && Array.isArray(metadata.chunks) && metadata.chunks.length > 0) {
                // Use metadata.chunks which has the actual audio files
                actualChunkCount = metadata.chunks.length;
                console.log('[Global Playback] Got chunk count from metadata.chunks:', actualChunkCount);
            } else if (!isUpload) {
                // For live sessions without metadata.chunks, count unique chunk-XXX patterns
                const chunkIds = new Set();
                processedData.paragraphs.forEach(para => {
                    if (para.chunkIds) {
                        para.chunkIds.forEach(id => {
                            // Only count actual chunk IDs (chunk-001, etc), not topic IDs
                            if (id.match(/^chunk-\d+$/)) {
                                chunkIds.add(id);
                            }
                        });
                    }
                });
                if (chunkIds.size > 0) {
                    actualChunkCount = chunkIds.size;
                } else {
                    // Fallback: estimate from transcript data if no chunk IDs found
                    const lastPara = processedData.paragraphs[processedData.paragraphs.length - 1];
                    if (lastPara && lastPara.end) {
                        actualChunkCount = Math.ceil(lastPara.end / CHUNK_DURATION);
                    }
                }
            }

            globalPlaybackState.totalChunks = actualChunkCount;

            // Calculate total duration from actual transcript data
            // For uploads, use the last paragraph's end time (more accurate)
            // For live sessions, use chunk count * CHUNK_DURATION as fallback
            if (processedData.paragraphs.length > 0) {
                // Use the last word/paragraph end time for actual duration
                const lastPara = processedData.paragraphs[processedData.paragraphs.length - 1];
                if (lastPara && lastPara.words && lastPara.words.length > 0) {
                    globalPlaybackState.totalDuration = lastPara.words[lastPara.words.length - 1].end;
                } else if (lastPara && lastPara.end) {
                    globalPlaybackState.totalDuration = lastPara.end;
                } else {
                    globalPlaybackState.totalDuration = actualChunkCount * CHUNK_DURATION;
                }
            } else {
                globalPlaybackState.totalDuration = actualChunkCount * CHUNK_DURATION;
            }

            // Store whether this is an upload for audio loading
            globalPlaybackState.isUpload = isUpload;

            // Detect audio format from metadata for compensation calculation
            let audioFormat = 'unknown';
            if (metadata.originalFilename) {
                const parts = metadata.originalFilename.split('.');
                if (parts.length > 1) {
                    audioFormat = parts[parts.length - 1].toLowerCase();
                }
            } else if (metadata.chunks && metadata.chunks[0] && metadata.chunks[0].filename) {
                const parts = metadata.chunks[0].filename.split('.');
                if (parts.length > 1) {
                    audioFormat = parts[parts.length - 1].toLowerCase();
                }
            }
            globalPlaybackState.audioFormat = audioFormat;

            console.log(`[Global Playback] Found ${globalPlaybackState.totalChunks} chunks, total duration: ${formatTime(globalPlaybackState.totalDuration)}, isUpload: ${isUpload}`);

            // Show the playback bar
            const playbackBar = document.getElementById('global-playback-bar');
            if (playbackBar) {
                playbackBar.classList.add('visible');
            }

            // Update UI
            updateGlobalPlaybackUI();

            // Add keyboard listener for spacebar
            document.addEventListener('keydown', handleGlobalKeydown);
        }

        /**
         * Handle keyboard shortcuts for playback
         */
        function handleGlobalKeydown(e) {
            // Space to toggle playback (only if not in an input/editable)
            if (e.code === 'Space' && !['INPUT', 'TEXTAREA'].includes(e.target.tagName) && !e.target.isContentEditable) {
                e.preventDefault();
                toggleGlobalPlayback();
            }
            // Left/Right arrows to seek
            if (e.code === 'ArrowLeft') {
                e.preventDefault();
                seekToAbsoluteTime(globalPlaybackState.absoluteTime - 5);
            }
            if (e.code === 'ArrowRight') {
                e.preventDefault();
                seekToAbsoluteTime(globalPlaybackState.absoluteTime + 5);
            }
        }

        /**
         * Update the global playback UI (time displays, scrubber, etc)
         */
        function updateGlobalPlaybackUI() {
            const currentTimeEl = document.getElementById('global-current-time');
            const totalTimeEl = document.getElementById('global-total-time');
            const scrubber = document.getElementById('global-scrubber');
            const chunkIndicator = document.getElementById('chunk-indicator');
            const playBtn = document.getElementById('global-play-btn');

            if (currentTimeEl) {
                currentTimeEl.textContent = formatTime(globalPlaybackState.absoluteTime);
            }
            if (totalTimeEl) {
                totalTimeEl.textContent = formatTime(globalPlaybackState.totalDuration);
            }
            if (scrubber && !globalPlaybackState.isScrubbing) {
                const progress = globalPlaybackState.totalDuration > 0
                    ? (globalPlaybackState.absoluteTime / globalPlaybackState.totalDuration) * 100
                    : 0;
                scrubber.value = progress;
            }
            if (chunkIndicator) {
                chunkIndicator.textContent = `Chunk ${globalPlaybackState.currentChunkIndex + 1}/${globalPlaybackState.totalChunks}`;
            }
            if (playBtn) {
                const playIcon = playBtn.querySelector('.play-icon');
                const pauseIcon = playBtn.querySelector('.pause-icon');
                if (globalPlaybackState.isPlaying) {
                    playIcon.style.display = 'none';
                    pauseIcon.style.display = 'inline';
                } else {
                    playIcon.style.display = 'inline';
                    pauseIcon.style.display = 'none';
                }
            }
        }

        /**
         * Toggle global playback (play/pause)
         */
        function toggleGlobalPlayback() {
            if (globalPlaybackState.isPlaying) {
                pauseGlobal();
            } else {
                playGlobal();
            }
        }

        /**
         * Start or resume global playback
         */
        async function playGlobal() {
            console.log('[Global Playback] Play requested at absoluteTime:', globalPlaybackState.absoluteTime);

            // Stop any legacy playback
            stopAudio();

            globalPlaybackState.isPlaying = true;
            updateGlobalPlaybackUI();

            // Get the current chunk audio
            await ensureChunkLoaded(globalPlaybackState.currentChunkIndex);

            const audio = globalPlaybackState.chunkAudios[globalPlaybackState.currentChunkIndex];
            if (!audio) {
                console.error('[Global Playback] Failed to load audio for chunk', globalPlaybackState.currentChunkIndex);
                globalPlaybackState.isPlaying = false;
                updateGlobalPlaybackUI();
                return;
            }

            // Calculate position within this chunk
            // For uploads (single audio file), use absoluteTime directly
            // For live sessions (multiple chunks), offset by chunk start time
            let positionInChunk;
            if (globalPlaybackState.isUpload || globalPlaybackState.totalChunks === 1) {
                positionInChunk = globalPlaybackState.absoluteTime;
            } else {
                const chunkStartTime = globalPlaybackState.currentChunkIndex * CHUNK_DURATION;
                positionInChunk = globalPlaybackState.absoluteTime - chunkStartTime;
            }

            audio.currentTime = Math.max(0, positionInChunk);
            audio.playbackRate = globalPlaybackState.playbackRate;

            // Debug: Log what the browser actually set currentTime to
            // AAC files may only seek to keyframes, causing jumps
            const seekDiff = Math.abs(audio.currentTime - positionInChunk);
            console.log(`%c[Global Playback] Seek: requested ${positionInChunk.toFixed(2)}s → browser set ${audio.currentTime.toFixed(2)}s (diff: ${seekDiff.toFixed(2)}s)`,
                seekDiff > 0.5 ? 'color: #ff0000; font-weight: bold' : 'color: #00ff00');

            try {
                await audio.play();

                // Log after play() returns
                const playDiff = Math.abs(audio.currentTime - positionInChunk);
                console.log(`%c[Global Playback] After play(): audio at ${audio.currentTime.toFixed(2)}s (requested: ${positionInChunk.toFixed(2)}s, diff: ${playDiff.toFixed(2)}s)`,
                    playDiff > 0.5 ? 'color: #ff0000; font-weight: bold' : 'color: #00ff00');
                console.log('[Global Playback] isUpload:', globalPlaybackState.isUpload, 'chunkIndex:', globalPlaybackState.currentChunkIndex);

                // For uploads, detect when audio is ACTUALLY playing (not just buffering)
                // by monitoring when audio.currentTime starts advancing at real-time speed
                if (globalPlaybackState.isUpload) {
                    console.log('[Global Playback] Detecting actual audio playback...');
                    const playStartTime = Date.now();
                    let lastCurrentTime = audio.currentTime;
                    let stableCount = 0;

                    const detectInterval = setInterval(() => {
                        const now = audio.currentTime;
                        const elapsed = (Date.now() - playStartTime) / 1000;
                        const timeAdvance = now - lastCurrentTime;

                        // If audio.currentTime advanced by 0.08-0.15s in ~100ms, it's playing at real-time
                        if (timeAdvance >= 0.08 && timeAdvance <= 0.15) {
                            stableCount++;
                        } else {
                            stableCount = 0; // Reset if not advancing properly
                        }

                        // Need 3 consecutive stable advances to confirm real playback
                        if (stableCount >= 3) {
                            clearInterval(detectInterval);
                            console.log(`%c[Global Playback] Audio ACTUALLY playing! Detection time: ${elapsed.toFixed(2)}s`, 'color: #00ff00; font-weight: bold');

                            // Sync highlight to actual audio position
                            globalPlaybackState.seekFloorTime = audio.currentTime;
                            globalPlaybackState.absoluteTime = audio.currentTime;

                            // NOW start the time update interval
                            startGlobalTimeUpdate();
                        }

                        // Timeout after 10 seconds - start anyway
                        if (elapsed > 10) {
                            clearInterval(detectInterval);
                            console.log(`%c[Global Playback] Detection timeout - starting anyway`, 'color: #ff9900');
                            startGlobalTimeUpdate();
                        }

                        lastCurrentTime = now;
                    }, 100);
                } else {
                    // For non-uploads (live recordings with multiple chunks), start immediately
                    startGlobalTimeUpdate();
                }

                // Highlight current paragraph
                highlightCurrentParagraph();
            } catch (error) {
                console.error('[Global Playback] Play failed:', error);
                globalPlaybackState.isPlaying = false;
                updateGlobalPlaybackUI();
            }
        }

        /**
         * Pause global playback
         */
        function pauseGlobal() {
            console.log('[Global Playback] Pause');

            globalPlaybackState.isPlaying = false;

            // Pause current chunk audio
            const audio = globalPlaybackState.chunkAudios[globalPlaybackState.currentChunkIndex];
            if (audio) {
                audio.pause();
            }

            // Stop time update
            stopGlobalTimeUpdate();

            updateGlobalPlaybackUI();
        }

        /**
         * Ensure a chunk is loaded and ready to play
         */
        async function ensureChunkLoaded(chunkIndex) {
            if (globalPlaybackState.chunkAudios[chunkIndex]) {
                return; // Already loaded
            }

            console.log('[Global Playback] Loading chunk', chunkIndex);

            try {
                const url = await getChunkUrl(chunkIndex);
                globalPlaybackState.chunkUrls[chunkIndex] = url;

                const audio = new Audio(url);
                audio.preload = 'auto';

                // Set up event listeners
                audio.addEventListener('ended', () => onChunkEnded(chunkIndex));
                audio.addEventListener('error', (e) => {
                    console.error('[Global Playback] Audio error for chunk', chunkIndex, e);
                });

                // Wait for enough data to start playing
                await new Promise((resolve, reject) => {
                    audio.addEventListener('canplay', resolve, { once: true });
                    audio.addEventListener('error', reject, { once: true });
                    audio.load();
                });

                globalPlaybackState.chunkAudios[chunkIndex] = audio;
                console.log('[Global Playback] Chunk', chunkIndex, 'loaded successfully');

                // Preload next chunk
                if (chunkIndex + 1 < globalPlaybackState.totalChunks) {
                    ensureChunkLoaded(chunkIndex + 1).catch(() => {}); // Don't wait, don't fail
                }
            } catch (error) {
                console.error('[Global Playback] Failed to load chunk', chunkIndex, error);
            }
        }

        /**
         * Handle when a chunk finishes playing
         */
        function onChunkEnded(chunkIndex) {
            console.log('[Global Playback] Chunk', chunkIndex, 'ended');

            if (!globalPlaybackState.isPlaying) {
                return; // User paused
            }

            // Move to next chunk
            if (chunkIndex + 1 < globalPlaybackState.totalChunks) {
                globalPlaybackState.currentChunkIndex = chunkIndex + 1;
                globalPlaybackState.absoluteTime = globalPlaybackState.currentChunkIndex * CHUNK_DURATION;

                console.log('[Global Playback] Auto-advancing to chunk', globalPlaybackState.currentChunkIndex);
                playGlobal();
            } else {
                // End of session
                console.log('[Global Playback] Reached end of session');
                globalPlaybackState.isPlaying = false;
                globalPlaybackState.absoluteTime = globalPlaybackState.totalDuration;
                stopGlobalTimeUpdate();
                updateGlobalPlaybackUI();
                clearParagraphHighlight();
            }
        }

        // Time update interval
        let globalTimeUpdateInterval = null;

        /**
         * Start the interval that updates time display and word highlighting
         */
        function startGlobalTimeUpdate() {
            stopGlobalTimeUpdate(); // Clear any existing

            // Log first few updates to debug AAC timing issues
            let updateCount = 0;

            globalTimeUpdateInterval = setInterval(() => {
                const audio = globalPlaybackState.chunkAudios[globalPlaybackState.currentChunkIndex];
                if (!audio) return;

                // Calculate absolute time
                // For uploads (single audio file), currentTime IS the absolute time
                // For live sessions (multiple chunks), add chunk offset
                if (globalPlaybackState.isUpload || globalPlaybackState.totalChunks === 1) {
                    globalPlaybackState.absoluteTime = audio.currentTime;
                } else {
                    const chunkStartTime = globalPlaybackState.currentChunkIndex * CHUNK_DURATION;
                    globalPlaybackState.absoluteTime = chunkStartTime + audio.currentTime;
                }

                // Highlighting time = absoluteTime (no compensation needed)
                // We already waited for audio to actually start playing before starting this interval
                let highlightTime = globalPlaybackState.absoluteTime;

                // Debug: Log first 10 time updates to see what's happening
                if (updateCount < 10) {
                    console.log(`%c[Time Update ${updateCount}] audio: ${audio.currentTime.toFixed(2)}s → highlight: ${highlightTime.toFixed(2)}s`, 'color: #ffcc00');
                    updateCount++;
                }

                // Update UI (shows raw time for scrubber/display)
                updateGlobalPlaybackUI();

                // Highlight current word and paragraph using compensated time
                highlightCurrentWordWithScroll(highlightTime);
                highlightCurrentParagraph();
            }, 100); // Update 10 times per second
        }

        /**
         * Stop the time update interval
         */
        function stopGlobalTimeUpdate() {
            if (globalTimeUpdateInterval) {
                clearInterval(globalTimeUpdateInterval);
                globalTimeUpdateInterval = null;
            }
        }

        // Track the currently highlighted word element to avoid redundant scrolling
        let lastHighlightedWordEl = null;

        /**
         * Highlight the current word based on absolute time (for global playback)
         * @param {number} absoluteTime - The current playback time
         * @param {boolean} forceScroll - Force scroll to word (used for seeking)
         */
        function highlightCurrentWordWithScroll(absoluteTime, forceScroll = false) {
            // Find word element at current time by iterating through all word elements
            // This avoids floating point precision issues with querySelector string matching
            const allWordElements = document.querySelectorAll('.word-highlight');
            let foundWordEl = null;

            // Debug logging on seek (forceScroll) or every 5 seconds
            const shouldLog = forceScroll || (Math.floor(absoluteTime) % 5 === 0 && Math.floor(absoluteTime * 10) % 10 === 0);
            if (shouldLog) {
                console.log(`[Word Highlight] Seeking to ${absoluteTime.toFixed(2)}s, found ${allWordElements.length} word elements`);
                if (allWordElements.length > 0) {
                    const first = allWordElements[0];
                    const last = allWordElements[allWordElements.length - 1];
                    console.log(`[Word Highlight] Word time range: ${first.dataset.wordStart}s - ${last.dataset.wordEnd}s`);
                }
            }

            // Find the word that contains the current time, or the most recent word
            // Words have gaps between them, so we can't rely on exact bounds matching
            let lastWordBeforeTime = null;

            for (let i = 0; i < allWordElements.length; i++) {
                const wordEl = allWordElements[i];
                const start = parseFloat(wordEl.dataset.wordStart);
                const end = parseFloat(wordEl.dataset.wordEnd);

                // Exact match - time is within word bounds
                if (absoluteTime >= start && absoluteTime <= end) {
                    foundWordEl = wordEl;
                    break;
                }

                // Track the last word that started before current time
                // This handles gaps between words
                if (absoluteTime >= start) {
                    lastWordBeforeTime = wordEl;
                }

                // If we've passed the current time, stop searching
                if (start > absoluteTime) {
                    break;
                }
            }

            // If no exact match, use the last word that started before current time
            // This keeps that word highlighted during gaps until the next word starts
            if (!foundWordEl && lastWordBeforeTime) {
                foundWordEl = lastWordBeforeTime;
            }

            if (shouldLog) {
                if (foundWordEl) {
                    console.log(`[Word Highlight] Found: "${foundWordEl.textContent}" at ${foundWordEl.dataset.wordStart}s-${foundWordEl.dataset.wordEnd}s (match: ${foundWordEl === lastWordBeforeTime ? 'gap-fill' : 'exact'}, seeking: ${absoluteTime.toFixed(2)}s)`);
                } else {
                    console.log(`[Word Highlight] NONE found at ${absoluteTime.toFixed(2)}s - first word starts at ${allWordElements.length > 0 ? allWordElements[0].dataset.wordStart : 'N/A'}s`);
                }
            }

            // Only update if the word changed
            if (foundWordEl !== lastHighlightedWordEl) {
                // Log word transitions (helps debug sync issues)
                const prevWord = lastHighlightedWordEl ? lastHighlightedWordEl.textContent : 'NONE';
                const nextWord = foundWordEl ? foundWordEl.textContent : 'NONE';
                console.log(`%c[Word Change] "${prevWord}" → "${nextWord}" at ${absoluteTime.toFixed(2)}s`, 'color: #00ffff; font-weight: bold');

                // Remove old highlight
                if (lastHighlightedWordEl) {
                    lastHighlightedWordEl.classList.remove('playing');
                }

                if (foundWordEl) {
                    foundWordEl.classList.add('playing');

                    // Scroll to center the word in the visible area below the sticky header
                    // Sticky header = 72px (nav) + ~78px (playback bar) = 150px
                    const stickyHeaderHeight = 150;
                    const viewportHeight = window.innerHeight;
                    const visibleAreaHeight = viewportHeight - stickyHeaderHeight;

                    // Get word's current position relative to viewport
                    const wordRect = foundWordEl.getBoundingClientRect();
                    const wordViewportTop = wordRect.top;

                    // Define the "comfortable zone" - middle 60% of visible area
                    const comfortZoneTop = stickyHeaderHeight + (visibleAreaHeight * 0.2);
                    const comfortZoneBottom = viewportHeight - (visibleAreaHeight * 0.2);

                    // Scroll if forced (seek) or word is outside comfortable zone
                    const needsScroll = forceScroll ||
                                        wordViewportTop < comfortZoneTop ||
                                        wordViewportTop > comfortZoneBottom;

                    if (needsScroll) {
                        // Calculate absolute position of word in document
                        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                        const wordAbsoluteTop = wordViewportTop + scrollTop;

                        // Target: put word in center of visible area (below header)
                        const targetScrollTop = wordAbsoluteTop - stickyHeaderHeight - (visibleAreaHeight / 2);

                        window.scrollTo({
                            top: Math.max(0, targetScrollTop),
                            behavior: forceScroll ? 'smooth' : 'auto'
                        });
                    }
                }

                lastHighlightedWordEl = foundWordEl;
            }
        }

        /**
         * Highlight the paragraph containing the current playback position
         */
        function highlightCurrentParagraph() {
            // Remove existing highlights
            document.querySelectorAll('.paragraph-container.playing-now').forEach(el => {
                el.classList.remove('playing-now');
            });

            if (!processedData || !processedData.paragraphs) return;

            const absoluteTime = globalPlaybackState.absoluteTime;

            // Find paragraph containing current time
            for (let i = 0; i < processedData.paragraphs.length; i++) {
                const para = processedData.paragraphs[i];
                if (absoluteTime >= para.start && absoluteTime <= para.end) {
                    const paraEl = document.querySelector(`[data-para-index="${i}"]`);
                    if (paraEl) {
                        const container = paraEl.closest('.paragraph-container');
                        if (container) {
                            container.classList.add('playing-now');
                        }
                    }
                    break;
                }
            }
        }

        /**
         * Clear paragraph and word highlights
         */
        function clearParagraphHighlight() {
            document.querySelectorAll('.paragraph-container.playing-now').forEach(el => {
                el.classList.remove('playing-now');
            });
            document.querySelectorAll('.word-highlight.playing').forEach(el => {
                el.classList.remove('playing');
            });
            // Reset word tracking so next highlight will scroll
            lastHighlightedWordEl = null;
        }

        /**
         * Seek to an absolute time position
         */
        async function seekToAbsoluteTime(targetTime) {
            // Clamp to valid range
            targetTime = Math.max(0, Math.min(targetTime, globalPlaybackState.totalDuration));

            console.log('[Global Playback] Seeking to', formatTime(targetTime));

            // For uploads (single audio file), always use chunk 0
            // For live sessions (multiple chunks), calculate which chunk
            let targetChunk;
            if (globalPlaybackState.isUpload || globalPlaybackState.totalChunks === 1) {
                targetChunk = 0;
            } else {
                targetChunk = Math.floor(targetTime / CHUNK_DURATION);
            }

            // Stop current audio
            const currentAudioObj = globalPlaybackState.chunkAudios[globalPlaybackState.currentChunkIndex];
            if (currentAudioObj) {
                currentAudioObj.pause();
            }

            // Update state
            globalPlaybackState.absoluteTime = targetTime;
            globalPlaybackState.currentChunkIndex = Math.min(targetChunk, globalPlaybackState.totalChunks - 1);

            // Set seek floor - highlighting should never go before this time
            // This prevents AAC compensation from jumping back before the clicked word
            globalPlaybackState.seekFloorTime = targetTime;

            console.log(`[Global Playback] Set seekFloorTime: ${targetTime.toFixed(2)}s`);

            // Reset word tracking so scroll happens on seek
            lastHighlightedWordEl = null;

            // Update UI
            updateGlobalPlaybackUI();
            highlightCurrentWordWithScroll(targetTime, true);  // Force scroll on seek
            highlightCurrentParagraph();

            // If we were playing, continue playing from new position
            if (globalPlaybackState.isPlaying) {
                await playGlobal();
            }
        }

        /**
         * Handle scrubber input (while dragging)
         */
        function onScrubberInput(value) {
            globalPlaybackState.isScrubbing = true;
            const targetTime = (value / 100) * globalPlaybackState.totalDuration;
            globalPlaybackState.absoluteTime = targetTime;

            // Update time display only (don't seek yet)
            const currentTimeEl = document.getElementById('global-current-time');
            if (currentTimeEl) {
                currentTimeEl.textContent = formatTime(targetTime);
            }
        }

        /**
         * Handle scrubber change (when released)
         */
        function onScrubberChange(value) {
            globalPlaybackState.isScrubbing = false;
            const targetTime = (value / 100) * globalPlaybackState.totalDuration;
            seekToAbsoluteTime(targetTime);
        }

        /**
         * Set playback speed
         */
        function setPlaybackSpeed(rate) {
            globalPlaybackState.playbackRate = parseFloat(rate);
            console.log('[Global Playback] Speed set to', globalPlaybackState.playbackRate);

            // Update current audio if playing
            const audio = globalPlaybackState.chunkAudios[globalPlaybackState.currentChunkIndex];
            if (audio) {
                audio.playbackRate = globalPlaybackState.playbackRate;
            }
        }

        /**
         * Skip forward by specified seconds
         */
        function skipForward(seconds) {
            const newTime = Math.min(
                globalPlaybackState.absoluteTime + seconds,
                globalPlaybackState.totalDuration
            );
            console.log('[Global Playback] Skip forward', seconds, 'seconds to', formatTime(newTime));
            seekToAbsoluteTime(newTime);

            // Continue playing if was playing
            if (globalPlaybackState.isPlaying) {
                playGlobal();
            }
        }

        /**
         * Skip backward by specified seconds
         */
        function skipBackward(seconds) {
            const newTime = Math.max(
                globalPlaybackState.absoluteTime - seconds,
                0
            );
            console.log('[Global Playback] Skip backward', seconds, 'seconds to', formatTime(newTime));
            seekToAbsoluteTime(newTime);

            // Continue playing if was playing
            if (globalPlaybackState.isPlaying) {
                playGlobal();
            }
        }

        /**
         * Handle click on a paragraph to seek to its start time
         */
        function onParagraphClick(paraIndex, event) {
            // Don't seek if in split mode
            if (speakerSplitManager.activeChunkId) {
                console.log('[onParagraphClick] Blocked - split mode active');
                return;
            }
            // Don't seek if clicking on editable text or links
            if (event.target.isContentEditable || event.target.tagName === 'A') {
                return;
            }

            const para = processedData.paragraphs[paraIndex];
            if (para && typeof para.start === 'number') {
                console.log('[Global Playback] Paragraph clicked, seeking to', formatTime(para.start));
                seekToAbsoluteTime(para.start);

                // Start playing if not already
                if (!globalPlaybackState.isPlaying) {
                    playGlobal();
                }
            }
        }

        // ============================================================================
        // END GLOBAL SEQUENTIAL PLAYBACK FUNCTIONS
        // ============================================================================

        // Toggle original text
        function toggleOriginal(index) {
            const originalDiv = document.getElementById(`original-${index}`);
            const toggle = event.target;

            if (originalDiv.classList.contains('show')) {
                originalDiv.classList.remove('show');
                toggle.textContent = 'Show Original';
            } else {
                originalDiv.classList.add('show');
                toggle.textContent = 'Hide Original';
            }
        }

        // Toggle edit mode
        let editModeEnabled = false;
        function toggleEditMode() {
            editModeEnabled = !editModeEnabled;
            const btn = document.getElementById('edit-mode-btn');
            const paragraphs = document.querySelectorAll('.paragraph-text');

            // Toggle editing buttons
            const editButtons = ['undo-btn', 'redo-btn', 'bold-btn', 'italic-btn', 'underline-btn'];
            editButtons.forEach(id => {
                document.getElementById(id).disabled = !editModeEnabled;
            });

            if (editModeEnabled) {
                btn.textContent = '✏️ Edit Mode: ON';
                btn.classList.add('active');
                paragraphs.forEach(p => p.contentEditable = true);
                showToast('Edit mode enabled - you can now edit paragraphs');
            } else {
                btn.textContent = '✏️ Edit Mode: OFF';
                btn.classList.remove('active');
                paragraphs.forEach(p => p.contentEditable = false);
                showToast('Edit mode disabled - you can now select and copy text');
            }
        }

        // Mark paragraph as edited
        function markEdited(index) {
            const textDiv = document.querySelector(`[data-para-index="${index}"]`);
            textDiv.classList.add('edited');

            const para = processedData.paragraphs[index];
            para.text = textDiv.textContent;
            para.edited = true;
        }

        // Show chunk details
        function showChunkDetails(chunkId, paraIndex) {
            const para = processedData.paragraphs[paraIndex];
            const chunkSegments = (para.segments || []).filter(s => s.chunkId === chunkId);

            const modalBody = document.getElementById('modal-body');
            modalBody.innerHTML = `
                <p><strong>Chunk:</strong> ${chunkId}</p>
                <p><strong>Segments in this paragraph:</strong> ${chunkSegments.length}</p>
                <div style="margin-top: 16px;">
                    <h3 style="font-size: 14px; font-weight: 600; margin-bottom: 8px;">Original Segments:</h3>
                    ${chunkSegments.map(s => `<p style="margin: 8px 0; padding: 8px; background: var(--gray-50); border-radius: 4px;">${s.text}</p>`).join('')}
                </div>
            `;

            document.getElementById('modal-title').textContent = `Chunk Details: ${chunkId}`;
            document.getElementById('plugin-modal').classList.add('show');
        }

        // Quick search
        function quickSearch(query) {
            if (!query) {
                document.querySelectorAll('.paragraph-text').forEach(el => {
                    el.style.background = '';
                });
                return;
            }

            const lowerQuery = query.toLowerCase();
            document.querySelectorAll('.paragraph-text').forEach(el => {
                const text = el.textContent.toLowerCase();
                if (text.includes(lowerQuery)) {
                    el.style.background = '#fef3c7';
                } else {
                    el.style.background = '';
                }
            });
        }

        // Copy all text
        function copyAllText() {
            const allText = processedData.paragraphs.map(p => p.text).join('\n\n');
            navigator.clipboard.writeText(allText).then(() => {
                showToast('Copied all text to clipboard');
            }).catch(err => {
                showToast('Failed to copy text', 'error');
            });
        }

        // Toggle download menu
        function toggleDownloadMenu() {
            const menu = document.getElementById('download-menu');
            menu.classList.toggle('show');

            // Close dropdown when clicking outside
            if (menu.classList.contains('show')) {
                setTimeout(() => {
                    document.addEventListener('click', closeDropdownOnOutsideClick);
                }, 0);
            }
        }

        // Close dropdown when clicking outside
        function closeDropdownOnOutsideClick(e) {
            const menu = document.getElementById('download-menu');
            const dropdown = menu.closest('.dropdown');

            if (!dropdown.contains(e.target)) {
                menu.classList.remove('show');
                document.removeEventListener('click', closeDropdownOnOutsideClick);
            }
        }

        // Copy as markdown
        function copyAsMarkdown() {
            const markdown = generateMarkdown();
            navigator.clipboard.writeText(markdown).then(() => {
                showToast('✅ Copied as Markdown! Paste into Claude Code', 'success');
            }).catch(err => {
                console.error('Copy failed:', err);
                showToast('Failed to copy markdown', 'error');
            });
        }

        // Download transcript in various formats
        function downloadTranscript(format) {
            // Close dropdown
            document.getElementById('download-menu').classList.remove('show');

            let content, mimeType, extension;
            const sessionName = formatSessionName(currentSession.folder, selectedTimezone)
                .replace(/[^a-zA-Z0-9-]/g, '-')
                .toLowerCase();

            switch (format) {
                case 'markdown':
                    content = generateMarkdown();
                    mimeType = 'text/markdown';
                    extension = 'md';
                    break;

                case 'text':
                    content = generatePlainText();
                    mimeType = 'text/plain';
                    extension = 'txt';
                    break;

                case 'json':
                    content = JSON.stringify(processedData, null, 2);
                    mimeType = 'application/json';
                    extension = 'json';
                    break;
            }

            // Create download
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `transcript-${sessionName}.${extension}`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showToast(`✅ Downloaded as ${extension.toUpperCase()}`, 'success');
        }

        // Generate markdown format
        function generateMarkdown() {
            const sessionDate = formatSessionName(currentSession.folder, selectedTimezone);
            const stats = processedData.stats;

            let markdown = `# Transcript: ${sessionDate}\n\n`;
            markdown += `**Duration:** ${formatDuration(stats.totalDuration)} | `;
            markdown += `**Words:** ${stats.totalWords} | `;
            markdown += `**WPM:** ${Math.round(stats.wordsPerMinute)}\n\n`;
            markdown += `---\n\n`;

            processedData.paragraphs.forEach((para, index) => {
                markdown += `## [${formatTime(para.start)}]\n\n`;
                markdown += `${para.text}\n\n`;
            });

            markdown += `---\n\n`;
            markdown += `*Transcribed with CloudDrive Transcription*\n`;

            return markdown;
        }

        // Generate plain text format
        function generatePlainText() {
            const sessionDate = formatSessionName(currentSession.folder, selectedTimezone);
            const stats = processedData.stats;

            let text = `Transcript: ${sessionDate}\n`;
            text += `Duration: ${formatDuration(stats.totalDuration)} | `;
            text += `Words: ${stats.totalWords} | `;
            text += `WPM: ${Math.round(stats.wordsPerMinute)}\n`;
            text += `${'='.repeat(60)}\n\n`;

            processedData.paragraphs.forEach((para, index) => {
                text += `[${formatTime(para.start)}]\n`;
                text += `${para.text}\n\n`;
            });

            text += `${'='.repeat(60)}\n`;
            text += `Transcribed with CloudDrive Transcription\n`;

            return text;
        }

        // Speaker Legend Functions
        const SPEAKER_COLORS = ['#dbeafe', '#dcfce7', '#fef3c7', '#f3e8ff', '#ffe4e6', '#e0f2fe'];

        function populateSpeakerList(speakers) {
            const section = document.getElementById('speakers-section');
            const list = document.getElementById('speaker-list');

            if (!speakers || speakers.length === 0) {
                section.style.display = 'none';
                return;
            }

            section.style.display = 'block';
            list.innerHTML = '';

            // Load saved names from processedData
            speakerNames = processedData.speaker_names || {};

            speakers.forEach((speaker, index) => {
                const colorIndex = index % 6;

                const row = document.createElement('div');
                row.className = 'speaker-row';
                row.dataset.speaker = speaker;

                // Build merge options
                const otherSpeakers = speakers.filter(s => s !== speaker);
                const mergeOptions = otherSpeakers.map(s =>
                    `<option value="${s}">${speakerNames[s] || s}</option>`
                ).join('');

                row.innerHTML = `
                    <div class="speaker-color-dot" style="background: ${SPEAKER_COLORS[colorIndex]};"></div>
                    <input type="text" class="speaker-name-input"
                           value="${speakerNames[speaker] || speaker}"
                           data-speaker="${speaker}"
                           placeholder="${speaker}"
                           oninput="onSpeakerNameChange(this)">
                    <select class="speaker-merge-select" data-speaker="${speaker}"
                            onchange="onMergeSpeaker(this)" title="Merge into another speaker">
                        <option value="">Merge</option>
                        ${mergeOptions}
                    </select>
                `;

                list.appendChild(row);
            });
        }

        function onSpeakerNameChange(input) {
            const speaker = input.dataset.speaker;
            const name = input.value.trim();
            speakerNames[speaker] = name || speaker;

            // Update speaker labels in transcript view
            updateSpeakerLabelsInTranscript();
        }

        function updateSpeakerLabelsInTranscript() {
            if (!processedData || !processedData.paragraphs) return;

            processedData.paragraphs.forEach((para, index) => {
                const speaker = para.speaker;
                if (!speaker) return;

                const paraDiv = document.getElementById(`para-${index}`);
                if (!paraDiv) return;

                const label = paraDiv.querySelector('.speaker-label');
                if (label) {
                    label.textContent = speakerNames[speaker] || speaker;
                }
            });
        }

        async function saveSpeakerNames() {
            // Store speaker names in processedData
            processedData.speaker_names = speakerNames;

            // Save via existing saveTranscript mechanism
            await saveTranscript();

            showToast('Speaker names saved!');
        }

        async function onMergeSpeaker(select) {
            const sourceSpk = select.dataset.speaker;
            const targetSpk = select.value;

            if (!targetSpk) return;

            const sourceName = speakerNames[sourceSpk] || sourceSpk;
            const targetName = speakerNames[targetSpk] || targetSpk;

            if (!confirm(`Merge "${sourceName}" into "${targetName}"?\n\nAll segments from ${sourceName} will be reassigned to ${targetName}.`)) {
                select.value = '';
                return;
            }

            // Update all paragraphs
            processedData.paragraphs.forEach(para => {
                if (para.speaker === sourceSpk) {
                    para.speaker = targetSpk;
                }
            });

            // Update segments if present
            if (processedData.segments) {
                processedData.segments.forEach(seg => {
                    if (seg.speaker === sourceSpk) {
                        seg.speaker = targetSpk;
                    }
                });
            }

            // Remove merged speaker from list
            const idx = processedData.speakers.indexOf(sourceSpk);
            if (idx > -1) {
                processedData.speakers.splice(idx, 1);
            }

            // Copy name if target doesn't have one
            if (!speakerNames[targetSpk] && speakerNames[sourceSpk]) {
                speakerNames[targetSpk] = speakerNames[sourceSpk];
            }
            delete speakerNames[sourceSpk];

            // Store updated speaker_names
            processedData.speaker_names = speakerNames;

            // Refresh the speaker list (removes merged speaker)
            populateSpeakerList(processedData.speakers);

            // Update all speaker labels in the transcript to use the target speaker's name
            updateSpeakerLabelsInTranscript();

            // Auto-save after merge so it persists
            await saveTranscript();

            showToast(`Merged ${sourceName} into ${targetName} (saved)`);
        }

        // Save transcript
        async function saveTranscript() {
            try {
                const userId = getUserId();
                const sessionFolder = currentSession.folder;

                // Save processed data
                const blob = new Blob([JSON.stringify(processedData, null, 2)], { type: 'application/json' });

                const uploadData = await apiCall('/api/s3/upload', {
                    method: 'POST',
                    body: JSON.stringify({
                        fileName: `audio/sessions/${sessionFolder}/transcription-processed.json`,
                        contentType: 'application/json',
                        fileSize: blob.size
                    })
                });

                await fetch(uploadData.uploadUrl, {
                    method: 'PUT',
                    body: blob,
                    headers: { 'Content-Type': 'application/json' }
                });

                showToast('Transcript saved successfully!');
            } catch (error) {
                console.error('Error saving:', error);
                showToast('Failed to save transcript', 'error');
            }
        }

        // UI Plugin Manager (extends base plugin manager)
        class UIPluginManager extends TranscriptPluginManager {
            constructor() {
                super();
            }

            showSearchDialog() {
                const modalBody = document.getElementById('modal-body');
                modalBody.innerHTML = `
                    <input type="text" id="search-query" class="search-input" placeholder="Enter search term..." style="width: 100%; margin-bottom: 12px;">
                    <label style="display: block; margin-bottom: 12px;">
                        <input type="checkbox" id="search-case"> Case sensitive
                    </label>
                    <label style="display: block; margin-bottom: 16px;">
                        <input type="checkbox" id="search-regex"> Regular expression
                    </label>
                    <button class="btn btn-primary" onclick="pluginManager.executeSearch()">Search</button>
                `;

                document.getElementById('modal-title').textContent = 'Search Transcript';
                document.getElementById('plugin-modal').classList.add('show');
            }

            async executeSearch() {
                const query = document.getElementById('search-query').value;
                const caseSensitive = document.getElementById('search-case').checked;
                const regex = document.getElementById('search-regex').checked;

                const results = await this.execute('search', {
                    paragraphs: processedData.paragraphs,
                    query,
                    options: { caseSensitive, regex }
                });

                // Highlight results
                results.results.forEach(r => {
                    const paraDiv = document.querySelector(`[data-para-index="${r.paragraphIndex}"]`);
                    if (paraDiv) {
                        paraDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        paraDiv.style.background = '#fef3c7';
                        setTimeout(() => { paraDiv.style.background = ''; }, 3000);
                    }
                });

                closeModal();
                showToast(`Found ${results.totalMatches} matches`);
            }

            showReplaceDialog() {
                const modalBody = document.getElementById('modal-body');
                modalBody.innerHTML = `
                    <input type="text" id="replace-find" class="search-input" placeholder="Find..." style="width: 100%; margin-bottom: 12px;">
                    <input type="text" id="replace-with" class="search-input" placeholder="Replace with..." style="width: 100%; margin-bottom: 12px;">
                    <label style="display: block; margin-bottom: 16px;">
                        <input type="checkbox" id="replace-all" checked> Replace all
                    </label>
                    <button class="btn btn-primary" onclick="pluginManager.executeReplace()">Replace</button>
                `;

                document.getElementById('modal-title').textContent = 'Find & Replace';
                document.getElementById('plugin-modal').classList.add('show');
            }

            async executeReplace() {
                const find = document.getElementById('replace-find').value;
                const replace = document.getElementById('replace-with').value;
                const replaceAll = document.getElementById('replace-all').checked;

                const results = await this.execute('replace', {
                    paragraphs: processedData.paragraphs,
                    find,
                    replace,
                    options: { replaceAll }
                });

                renderEditor();
                closeModal();
                showToast(`Replaced ${results.modifiedCount} occurrences`);
            }

            showHighlightDialog() {
                const modalBody = document.getElementById('modal-body');
                modalBody.innerHTML = `
                    <input type="text" id="highlight-keywords" class="search-input" placeholder="Enter keywords (comma separated)" style="width: 100%; margin-bottom: 16px;">
                    <button class="btn btn-primary" onclick="pluginManager.executeHighlight()">Highlight</button>
                `;

                document.getElementById('modal-title').textContent = 'Highlight Keywords';
                document.getElementById('plugin-modal').classList.add('show');
            }

            async executeHighlight() {
                const keywords = document.getElementById('highlight-keywords').value.split(',').map(k => k.trim());

                const results = await this.execute('highlight', {
                    paragraphs: processedData.paragraphs,
                    keywords
                });

                renderEditor();
                closeModal();
                showToast(`Highlighted ${results.highlightCount} instances`);
            }

            async extractActions() {
                const results = await this.execute('extract-actions', {
                    paragraphs: processedData.paragraphs
                });

                const modalBody = document.getElementById('modal-body');
                modalBody.innerHTML = `
                    <p><strong>Found ${results.actionCount} action items:</strong></p>
                    <div style="margin-top: 16px;">
                        ${results.actions.map(a => `
                            <div style="margin: 12px 0; padding: 12px; background: var(--gray-50); border-left: 3px solid var(--primary); border-radius: 4px;">
                                <p style="font-weight: 600;">${a.text}</p>
                                <p style="font-size: 12px; color: var(--gray-600); margin-top: 4px;">
                                    Time: ${formatTime(a.timestamp)} | Paragraph ${a.paragraphIndex + 1}
                                </p>
                            </div>
                        `).join('')}
                    </div>
                `;

                document.getElementById('modal-title').textContent = 'Action Items';
                document.getElementById('plugin-modal').classList.add('show');
            }

            async showWordFrequency() {
                const results = await this.execute('word-frequency', {
                    paragraphs: processedData.paragraphs,
                    minLength: 4,
                    excludeCommon: true
                });

                const modalBody = document.getElementById('modal-body');
                modalBody.innerHTML = `
                    <p><strong>Top 20 words:</strong></p>
                    <div style="margin-top: 16px;">
                        ${results.topWords.slice(0, 20).map((w, i) => `
                            <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: var(--gray-50); margin: 4px 0; border-radius: 4px;">
                                <span><strong>${i + 1}.</strong> ${w.word}</span>
                                <span style="background: var(--primary); color: white; padding: 2px 8px; border-radius: 4px; font-weight: 600;">${w.count}</span>
                            </div>
                        `).join('')}
                    </div>
                `;

                document.getElementById('modal-title').textContent = 'Word Frequency';
                document.getElementById('plugin-modal').classList.add('show');
            }

            async export(format) {
                const results = await this.execute('export', {
                    paragraphs: processedData.paragraphs,
                    format
                });

                const blob = new Blob([results.content], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `transcript-${currentSession.folder}.${format === 'plain' ? 'txt' : format}`;
                a.click();
                URL.revokeObjectURL(url);

                showToast(`Exported as ${format.toUpperCase()}`);
            }
        }

        // Utility functions
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function formatDuration(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function closeModal() {
            document.getElementById('plugin-modal').classList.remove('show');
        }

        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast ${type} show`;

            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        // Close modal on outside click
        document.getElementById('plugin-modal').addEventListener('click', (e) => {
            if (e.target.id === 'plugin-modal') {
                closeModal();
            }
        });

        // ====================================================================
        // Session Info Modal
        // ====================================================================

        const sessionInfoModal = {
            show() {
                if (!currentSession) {
                    showToast('No session loaded', 'error');
                    return;
                }

                const modal = document.getElementById('session-info-modal');
                const body = document.getElementById('session-info-body');

                // Get user ID
                const userId = getUserId();

                // Format session display name
                const displayName = formatSessionName(currentSession.folder, selectedTimezone);

                // Build copyable info
                const info = {
                    'Session ID': currentSession.folder,
                    'User ID': userId,
                    'Display Name': displayName,
                    'Metadata': currentSession.metadata ? JSON.stringify(currentSession.metadata, null, 2) : 'None'
                };

                // Build HTML with copyable fields
                let html = '<div style="font-family: monospace; font-size: 13px;">';

                for (const [key, value] of Object.entries(info)) {
                    const copyId = 'copy-' + key.toLowerCase().replace(/\s+/g, '-');
                    html += `
                        <div style="margin-bottom: 16px;">
                            <div style="font-weight: 600; color: var(--gray-700); margin-bottom: 4px; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px;">
                                ${key}
                            </div>
                            <div style="position: relative;">
                                <div id="${copyId}" style="
                                    background: var(--gray-100);
                                    padding: 12px;
                                    border-radius: 6px;
                                    border: 1px solid var(--gray-300);
                                    word-break: break-all;
                                    ${key === 'Metadata' ? 'white-space: pre-wrap;' : ''}
                                    cursor: text;
                                    user-select: all;
                                ">${value}</div>
                                <button onclick="sessionInfoModal.copy('${copyId}', '${key}')" style="
                                    position: absolute;
                                    top: 8px;
                                    right: 8px;
                                    background: white;
                                    border: 1px solid var(--gray-300);
                                    border-radius: 4px;
                                    padding: 4px 8px;
                                    font-size: 11px;
                                    cursor: pointer;
                                    color: var(--gray-700);
                                    font-weight: 500;
                                    transition: all 0.2s;
                                " onmouseover="this.style.background='var(--gray-100)'" onmouseout="this.style.background='white'">
                                    📋 Copy
                                </button>
                            </div>
                        </div>
                    `;
                }

                html += '</div>';

                body.innerHTML = html;
                modal.style.display = 'flex';
            },

            copy(elementId, label) {
                const element = document.getElementById(elementId);
                const text = element.textContent;

                navigator.clipboard.writeText(text).then(() => {
                    showToast(`${label} copied to clipboard`, 'success');
                }).catch(err => {
                    console.error('Failed to copy:', err);
                    showToast('Failed to copy to clipboard', 'error');
                });
            },

            close() {
                const modal = document.getElementById('session-info-modal');
                modal.style.display = 'none';
            }
        };

        // Close session info modal on outside click
        document.getElementById('session-info-modal').addEventListener('click', (e) => {
            if (e.target.id === 'session-info-modal') {
                sessionInfoModal.close();
            }
        });

        // ====================================================================
        // AI Timeline Navigator
        // ====================================================================

        class AITimelineNavigator {
            constructor() {
                this.aiAnalysis = null;
                this.activeFilter = 'all';
                this.totalDuration = 0;
                this.detectedQuestions = null;
                this.colorMap = {
                    highlights: '#8b5cf6',
                    questions: '#ec4899',
                    actionItems: '#ef4444',
                    keyTerms: '#3b82f6',
                    keyThemes: '#f59e0b',
                    topicChanges: '#10b981'
                };
            }

            reset() {
                // Reset all state when switching sessions
                this.aiAnalysis = null;
                this.activeFilter = 'all';
                this.totalDuration = 0;
                this.detectedQuestions = null;

                // Hide the AI navigation container
                const container = document.getElementById('ai-nav-container');
                if (container) {
                    container.style.display = 'none';
                }

                // Clear timeline markers
                const track = document.getElementById('timeline-track');
                if (track) {
                    track.innerHTML = '';
                }

                // Reset all count badges to 0
                ['all', 'highlights', 'questions', 'actionItems', 'keyTerms', 'keyThemes', 'topicChanges'].forEach(type => {
                    const badge = document.getElementById(`count-${type}`);
                    if (badge) badge.textContent = '0';
                });

                // Reset active tab to "all"
                document.querySelectorAll('.ai-nav-tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                const allTab = document.querySelector('.ai-nav-tab[data-type="all"]');
                if (allTab) {
                    allTab.classList.add('active');
                }
            }

            async loadAnalysis() {
                if (!currentSession) return false;

                const userId = getUserId();
                const sessionFolder = currentSession.folder;
                const sessionPath = `users/${userId}/audio/sessions/${sessionFolder}`;

                try {
                    // Try to load AI analysis
                    const analysisKey = `${sessionPath}/transcription-ai-analysis.json`;
                    const downloadData = await apiCall(`/api/s3/download/${encodeURIComponent(analysisKey)}`);
                    const response = await fetch(downloadData.downloadUrl);

                    if (response.ok) {
                        this.aiAnalysis = await response.json();
                        console.log('✅ AI analysis loaded:', this.aiAnalysis);
                        return true;
                    }
                } catch (error) {
                    console.log('No AI analysis available for this session');
                    return false;
                }

                return false;
            }

            detectQuestions() {
                // Detect all questions in the transcript
                if (!processedData || !processedData.paragraphs) return [];

                const questions = [];
                const questionPatterns = [
                    /\?$/,  // Ends with question mark
                    /^(what|where|when|why|who|whom|which|whose|how)\b/i,  // Question words at start
                    /^(is|are|was|were|do|does|did|can|could|will|would|should|have|has|had)\b/i,  // Auxiliary verbs at start
                ];

                processedData.paragraphs.forEach((para, index) => {
                    const text = para.text.trim();
                    const paraDuration = para.end - para.start;

                    // Check if paragraph contains questions
                    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);

                    // Calculate approximate position of each sentence within the paragraph
                    let charsSoFar = 0;
                    const totalChars = text.length;

                    sentences.forEach(sentence => {
                        sentence = sentence.trim();

                        // Check if it's a question
                        const isQuestion = questionPatterns.some(pattern => pattern.test(sentence)) ||
                                         sentence.includes('?');

                        if (isQuestion) {
                            // Estimate time position based on character position in paragraph
                            const sentencePosition = charsSoFar / totalChars;
                            const estimatedTime = para.start + (paraDuration * sentencePosition);

                            questions.push({
                                timeCode: estimatedTime,  // Estimated position within paragraph
                                text: sentence,
                                summary: sentence.length > 100 ? sentence.substring(0, 97) + '...' : sentence,
                                paragraphIndex: index,
                                type: 'questions'
                            });
                        }

                        // Update character count for next sentence
                        charsSoFar += sentence.length + 1; // +1 for the delimiter
                    });
                });

                this.detectedQuestions = questions;
                return questions;
            }

            render() {
                if (!this.aiAnalysis || !processedData) {
                    // Hide AI navigation if no analysis
                    document.getElementById('ai-nav-container').style.display = 'none';
                    return;
                }

                // Show AI navigation
                document.getElementById('ai-nav-container').style.display = 'block';

                this.totalDuration = processedData.stats.totalDuration;

                // Detect questions from transcript
                this.detectQuestions();

                // Update duration labels
                document.getElementById('timeline-duration').textContent = formatDuration(this.totalDuration);
                document.getElementById('timeline-end-label').textContent = formatDuration(this.totalDuration);

                // Update count badges
                this.updateCounts();

                // Render markers
                this.renderMarkers();
            }

            updateCounts() {
                // For topicChanges, prefer the topic count from topic-segmented file (processedData.metadata.topicCount)
                // over AI analysis topicChanges, since the segmentation is more granular
                const topicCount = processedData?.metadata?.topicCount ||
                                   processedData?.topicStats?.topicCount ||
                                   this.aiAnalysis.topicChanges?.length || 0;

                const counts = {
                    highlights: this.aiAnalysis.highlights?.length || 0,
                    questions: this.detectedQuestions?.length || 0,
                    actionItems: this.aiAnalysis.actionItems?.length || 0,
                    keyTerms: this.aiAnalysis.keyTerms?.length || 0,
                    keyThemes: this.aiAnalysis.keyThemes?.length || 0,
                    topicChanges: topicCount
                };

                counts.all = Object.values(counts).reduce((a, b) => a + b, 0);

                Object.keys(counts).forEach(type => {
                    const badge = document.getElementById(`count-${type}`);
                    if (badge) badge.textContent = counts[type];
                });
            }

            filterByType(type) {
                console.log('🎯 filterByType called with:', type);
                this.activeFilter = type;

                // Update active tab
                document.querySelectorAll('.ai-nav-tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                document.querySelector(`.ai-nav-tab[data-type="${type}"]`).classList.add('active');

                // Show configuration panel for this category (if not "all")
                console.log('🔍 Checking if should show config:', {
                    type,
                    isNotAll: type !== 'all',
                    hasConfigPanel: !!window.aiConfigPanel,
                    aiConfigPanel: window.aiConfigPanel
                });

                if (type !== 'all' && window.aiConfigPanel) {
                    console.log('✅ Calling aiConfigPanel.showCategory()');
                    aiConfigPanel.showCategory(type);
                } else {
                    console.log('❌ NOT calling showCategory. Reasons:', {
                        isAll: type === 'all',
                        noConfigPanel: !window.aiConfigPanel
                    });
                }

                // Re-render markers
                this.renderMarkers();
            }

            renderMarkers() {
                const track = document.getElementById('timeline-track');
                track.innerHTML = '';

                const items = this.getFilteredItems();

                items.forEach(item => {
                    const marker = this.createMarker(item);
                    track.appendChild(marker);
                });
            }

            getFilteredItems() {
                if (!this.aiAnalysis) return [];

                let items = [];

                if (this.activeFilter === 'all') {
                    // Include all types
                    ['highlights', 'questions', 'actionItems', 'keyTerms', 'keyThemes', 'topicChanges'].forEach(type => {
                        if (type === 'questions' && this.detectedQuestions) {
                            items.push(...this.detectedQuestions);
                        } else if (this.aiAnalysis[type]) {
                            items.push(...this.aiAnalysis[type].map(item => ({ ...item, type })));
                        }
                    });
                } else if (this.activeFilter === 'questions') {
                    // Show detected questions
                    if (this.detectedQuestions) {
                        items = this.detectedQuestions;
                    }
                } else {
                    // Only include selected type from AI analysis
                    if (this.aiAnalysis[this.activeFilter]) {
                        items = this.aiAnalysis[this.activeFilter].map(item => ({ ...item, type: this.activeFilter }));
                    }
                }

                return items;
            }

            createMarker(item) {
                const marker = document.createElement('div');
                marker.className = 'timeline-marker';

                const startTime = item.timeCodeStart || item.timeCode || 0;
                const endTime = item.timeCodeEnd || startTime;

                // Position marker
                const leftPercent = (startTime / this.totalDuration) * 100;
                marker.style.left = `${leftPercent}%`;

                // Color by type
                marker.style.backgroundColor = this.colorMap[item.type] || '#666';

                // Segments vs points
                if (endTime > startTime) {
                    // Segment (like themes)
                    const widthPercent = ((endTime - startTime) / this.totalDuration) * 100;
                    marker.style.width = `${Math.max(widthPercent, 0.5)}%`;
                    marker.classList.add('segment');
                } else {
                    // Point marker
                    marker.style.width = '4px';
                }

                // Tooltip data
                marker.dataset.time = startTime;
                marker.dataset.summary = item.summary || item.text || item.term || item.theme || 'No description';

                // Click to jump
                marker.onclick = () => this.jumpToTime(startTime, item);

                // Hover tooltip
                marker.onmouseenter = (e) => this.showTooltip(e, item, startTime);
                marker.onmouseleave = () => this.hideTooltip();

                return marker;
            }

            jumpToTime(timeCode, item) {
                let paraIndex;

                // For questions, use the stored paragraph index directly
                if (item.type === 'questions' && item.paragraphIndex !== undefined) {
                    paraIndex = item.paragraphIndex;
                } else {
                    // Find paragraph that contains this time
                    const paragraph = processedData.paragraphs.find(p =>
                        timeCode >= p.start && timeCode <= p.end
                    );

                    if (!paragraph) return;
                    paraIndex = processedData.paragraphs.indexOf(paragraph);
                }

                const paraEl = document.querySelector(`#para-${paraIndex}`);

                if (paraEl) {
                    const textEl = paraEl.querySelector('.paragraph-text');

                    // Get the search text based on item type
                    const searchText = item.text || item.term || null;

                    // For items with specific text (questions, action items, key terms), search for it
                    if (searchText) {
                        // First scroll to paragraph
                        paraEl.scrollIntoView({ behavior: 'smooth', block: 'start' });

                        // Use browser's find-in-page API to search and highlight
                        setTimeout(() => {
                            // Create a temporary range to find the text
                            const textContent = textEl.textContent;
                            const searchIndex = textContent.indexOf(searchText);

                            if (searchIndex !== -1) {
                                // Use window.find() if available (works in most browsers)
                                if (window.find) {
                                    window.find(searchText);
                                }

                                // Alternative: Create a text highlight using range
                                const range = document.createRange();
                                const walker = document.createTreeWalker(
                                    textEl,
                                    NodeFilter.SHOW_TEXT,
                                    null,
                                    false
                                );

                                let charCount = 0;
                                let startNode = null;
                                let startOffset = 0;
                                let endNode = null;
                                let endOffset = 0;

                                while (walker.nextNode()) {
                                    const node = walker.currentNode;
                                    const nodeLength = node.textContent.length;

                                    if (charCount + nodeLength >= searchIndex && !startNode) {
                                        startNode = node;
                                        startOffset = searchIndex - charCount;
                                    }

                                    if (charCount + nodeLength >= searchIndex + searchText.length) {
                                        endNode = node;
                                        endOffset = searchIndex + searchText.length - charCount;
                                        break;
                                    }

                                    charCount += nodeLength;
                                }

                                if (startNode && endNode) {
                                    range.setStart(startNode, startOffset);
                                    range.setEnd(endNode, endOffset);

                                    // Scroll the range into view
                                    const rect = range.getBoundingClientRect();
                                    const scrollTop = window.scrollY + rect.top - (window.innerHeight / 2);
                                    window.scrollTo({ top: scrollTop, behavior: 'smooth' });

                                    // Create temporary highlight
                                    const span = document.createElement('span');
                                    span.style.backgroundColor = '#fbbf24';
                                    span.style.transition = 'background-color 0.3s';
                                    range.surroundContents(span);

                                    setTimeout(() => {
                                        span.style.backgroundColor = '';
                                        setTimeout(() => {
                                            // Unwrap the span
                                            const parent = span.parentNode;
                                            while (span.firstChild) {
                                                parent.insertBefore(span.firstChild, span);
                                            }
                                            parent.removeChild(span);
                                        }, 300);
                                    }, 2000);
                                }
                            } else {
                                // Text not found, just highlight paragraph
                                textEl.classList.add('ai-highlighted');
                                setTimeout(() => textEl.classList.remove('ai-highlighted'), 2000);
                            }
                        }, 300);
                    } else {
                        // For items without specific text, just scroll to paragraph and highlight
                        paraEl.scrollIntoView({ behavior: 'smooth', block: 'center' });

                        textEl.classList.add('ai-highlighted');
                        setTimeout(() => textEl.classList.remove('ai-highlighted'), 2000);
                    }

                    // If audio is playing, seek to time
                    if (currentAudio) {
                        currentAudio.currentTime = timeCode;
                    }
                }
            }

            showTooltip(event, item, timeCode) {
                const tooltip = document.getElementById('timeline-tooltip');
                const timeEl = document.getElementById('tooltip-time');
                const summaryEl = document.getElementById('tooltip-summary');

                timeEl.textContent = formatTime(timeCode);
                summaryEl.textContent = item.summary || item.text || item.term || item.theme || item.toTopic || 'No description';

                // Position tooltip
                const rect = event.target.getBoundingClientRect();
                tooltip.style.left = `${rect.left}px`;
                tooltip.style.top = `${rect.top - 80}px`;

                tooltip.classList.add('show');
            }

            hideTooltip() {
                const tooltip = document.getElementById('timeline-tooltip');
                tooltip.classList.remove('show');
            }
        }

        // Initialize AI Navigator
        let aiNavigator = new AITimelineNavigator();

        // ====================================================================
        // AI Configuration Panel
        // ====================================================================

        class PromptEditor {
            constructor() {
                this.isExpanded = false;
            }

            toggleExpand() {
                const textarea = document.getElementById('category-prompt');
                const button = document.querySelector('.expand-button');

                if (!this.isExpanded) {
                    textarea.style.height = '300px';
                    button.textContent = '▲ Collapse';
                    this.isExpanded = true;
                } else {
                    textarea.style.height = '80px';
                    button.textContent = '▼ Expand';
                    this.isExpanded = false;
                }
            }
        }

        class AIConfigPanel {
            constructor() {
                this.currentCategory = null;
                this.config = null;
                this.defaultPrompts = null;
                this.isDirty = false;
                this.originalValues = {};
            }

            async init() {
                await this.loadDefaultPrompts();
                this.attachEventListeners();
            }

            async loadDefaultPrompts() {
                try {
                    const response = await fetch('/ai-prompts.json');
                    if (response.ok) {
                        this.defaultPrompts = await response.json();
                        console.log('✅ Loaded default AI prompts');
                    }
                } catch (error) {
                    console.error('Error loading default prompts:', error);
                }
            }

            async loadConfig() {
                // Try to load existing AI analysis to get metadata
                const userId = getUserId();
                const sessionFolder = currentSession.folder;
                const sessionPath = `users/${userId}/audio/sessions/${sessionFolder}`;
                const analysisKey = `${sessionPath}/transcription-ai-analysis.json`;

                try {
                    const downloadData = await apiCall(`/api/s3/download/${encodeURIComponent(analysisKey)}`);
                    const response = await fetch(downloadData.downloadUrl);

                    if (response.ok) {
                        const analysis = await response.json();
                        // Extract metadata from analysis
                        this.config = {
                            version: "2.0",
                            sessionId: currentSession.folder,
                            lastModified: analysis._meta?.lastModified || new Date().toISOString(),
                            categories: this.buildConfigFromDefaults(),
                            _meta: analysis._meta || {}
                        };

                        // Update metadata if available
                        if (analysis._meta) {
                            Object.keys(this.config.categories).forEach(cat => {
                                if (analysis[cat]) {
                                    this.config.categories[cat].metadata.itemCount = analysis[cat].length;
                                }
                            });
                        }

                        return;
                    }
                } catch (error) {
                    console.log('No AI analysis found, using defaults');
                }

                // Initialize with defaults
                this.config = {
                    version: "2.0",
                    sessionId: currentSession?.folder || '',
                    lastModified: new Date().toISOString(),
                    categories: this.buildConfigFromDefaults(),
                    _meta: {
                        totalCost: 0,
                        totalTokens: 0
                    }
                };
            }

            buildConfigFromDefaults() {
                const categories = {};

                if (this.defaultPrompts?.templates) {
                    Object.keys(this.defaultPrompts.templates).forEach(category => {
                        const template = this.defaultPrompts.templates[category];
                        categories[category] = {
                            displayName: template.displayName,
                            enabled: true,
                            prompt: template.prompt,
                            settings: {
                                model: "claude-3-5-haiku-20241022",
                                maxTokens: 8000,
                                ...template.settings
                            },
                            metadata: {
                                lastAnalyzed: null,
                                itemCount: 0,
                                tokensUsed: 0,
                                costUSD: 0
                            }
                        };
                    });
                }

                return categories;
            }

            async showCategory(categoryId) {
                console.log('🔧 AIConfigPanel.showCategory called with:', categoryId);
                this.currentCategory = categoryId;

                // Load config if not loaded
                if (!this.config) {
                    console.log('📥 Loading config...');
                    await this.loadConfig();
                }

                // Transition: hide session info, show config panel
                const sessionInfo = document.getElementById('session-info');
                const configPanel = document.getElementById('ai-config-panel');

                console.log('🔄 Transitioning panels:', {
                    sessionInfo: !!sessionInfo,
                    configPanel: !!configPanel,
                    sessionInfoDisplay: sessionInfo?.style.display,
                    configPanelDisplay: configPanel?.style.display
                });

                if (!sessionInfo || !configPanel) {
                    console.error('❌ Panel elements not found!');
                    return;
                }

                sessionInfo.style.display = 'none';
                configPanel.style.display = 'block';

                console.log('✅ Panels transitioned, rendering...');
                this.render();
                console.log('✅ Render complete');
            }

            close() {
                // Transition: show session info, hide config panel
                const sessionInfo = document.getElementById('session-info');
                const configPanel = document.getElementById('ai-config-panel');

                // Warn if unsaved changes
                if (this.isDirty) {
                    if (!confirm('You have unsaved changes. Close anyway?')) {
                        return;
                    }
                    this.isDirty = false;
                }

                configPanel.style.display = 'none';
                sessionInfo.style.display = 'block';

                this.currentCategory = null;
            }

            render() {
                if (!this.currentCategory || !this.config) return;

                const categoryConfig = this.config.categories[this.currentCategory];
                if (!categoryConfig) return;

                // Update category name input
                document.getElementById('category-name').value = categoryConfig.displayName;

                // Update prompt editor
                document.getElementById('category-prompt').value = categoryConfig.prompt;

                // Update settings
                document.getElementById('setting-model').value = categoryConfig.settings.model;
                document.getElementById('setting-max-items').value = categoryConfig.settings.maxItems || 15;

                // Render category-specific settings
                this.renderCategorySpecificSettings(this.currentCategory, categoryConfig.settings);

                // Update status
                const metadata = categoryConfig.metadata;
                document.getElementById('last-analyzed-time').textContent =
                    metadata.lastAnalyzed ? this.formatRelativeTime(metadata.lastAnalyzed) : 'Never';
                document.getElementById('estimated-cost').textContent =
                    `$${(metadata.costUSD || 0).toFixed(4)}`;
                document.getElementById('current-count').textContent =
                    `${metadata.itemCount || 0} items`;

                // Store original values for dirty detection
                this.originalValues = {
                    displayName: categoryConfig.displayName,
                    prompt: categoryConfig.prompt,
                    settings: JSON.stringify(categoryConfig.settings)
                };

                this.isDirty = false;
                this.updateSaveButton();
            }

            renderCategorySpecificSettings(category, settings) {
                const container = document.getElementById('category-specific-settings');
                container.innerHTML = '';

                // Render settings specific to each category
                switch(category) {
                    case 'highlights':
                        container.innerHTML = `
                            <div class="setting-item">
                                <label for="setting-min-importance">Min Importance:</label>
                                <input type="number" id="setting-min-importance"
                                       min="0" max="1" step="0.1"
                                       value="${settings.minImportance || 0.7}">
                            </div>
                        `;
                        break;
                    case 'actionItems':
                        container.innerHTML = `
                            <div class="setting-item">
                                <label for="setting-min-priority">Min Priority:</label>
                                <select id="setting-min-priority">
                                    <option value="low" ${settings.minPriority === 'low' ? 'selected' : ''}>Low</option>
                                    <option value="medium" ${settings.minPriority === 'medium' ? 'selected' : ''}>Medium</option>
                                    <option value="high" ${settings.minPriority === 'high' ? 'selected' : ''}>High</option>
                                </select>
                            </div>
                        `;
                        break;
                    case 'keyTerms':
                        container.innerHTML = `
                            <div class="setting-item">
                                <label for="setting-first-mention-only">
                                    <input type="checkbox" id="setting-first-mention-only"
                                           ${settings.firstMentionOnly !== false ? 'checked' : ''}>
                                    First Mention Only
                                </label>
                            </div>
                        `;
                        break;
                    case 'keyThemes':
                        container.innerHTML = `
                            <div class="setting-item">
                                <label for="setting-min-intensity">Min Intensity:</label>
                                <input type="number" id="setting-min-intensity"
                                       min="0" max="1" step="0.1"
                                       value="${settings.minIntensity || 0.5}">
                            </div>
                            <div class="setting-item">
                                <label for="setting-min-duration">Min Duration (sec):</label>
                                <input type="number" id="setting-min-duration"
                                       min="0" step="5"
                                       value="${settings.minDuration || 30}">
                            </div>
                        `;
                        break;
                    case 'topicChanges':
                        container.innerHTML = `
                            <div class="setting-item">
                                <label for="setting-include-implicit">
                                    <input type="checkbox" id="setting-include-implicit"
                                           ${settings.includeImplicit !== false ? 'checked' : ''}>
                                    Include Implicit Transitions
                                </label>
                            </div>
                        `;
                        break;
                }
            }

            attachEventListeners() {
                // Detect changes to mark dirty
                const inputs = ['category-name', 'category-prompt', 'setting-model', 'setting-max-items'];

                inputs.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {
                        el.addEventListener('input', () => this.markDirty());
                        el.addEventListener('change', () => this.markDirty());
                    }
                });

                // Use event delegation for dynamically added category-specific settings
                document.addEventListener('change', (e) => {
                    if (e.target.id.startsWith('setting-')) {
                        this.markDirty();
                    }
                });
            }

            markDirty() {
                this.isDirty = true;
                this.updateSaveButton();

                // Add visual indicator to prompt
                const promptEditor = document.getElementById('category-prompt');
                if (promptEditor) {
                    promptEditor.classList.add('dirty');
                }
            }

            updateSaveButton() {
                const saveBtn = document.querySelector('.btn-save');
                if (saveBtn) {
                    if (this.isDirty) {
                        saveBtn.disabled = false;
                        saveBtn.classList.add('dirty');
                    } else {
                        saveBtn.disabled = true;
                        saveBtn.classList.remove('dirty');
                    }
                }
            }

            async saveConfig() {
                if (!this.currentCategory) return;

                showToast('Save functionality coming in Phase 3 - backend API', 'info');
                console.log('Config to save:', this.config);

                // TODO: Implement S3 upload in Phase 3
                this.isDirty = false;
                this.updateSaveButton();
            }

            async reanalyzeCategory() {
                if (!this.currentCategory) return;

                showToast('Re-analysis functionality coming in Phase 3 - backend API', 'info');
                console.log('Re-analyze category:', this.currentCategory);

                // TODO: Implement backend API call in Phase 3
            }

            resetToDefault() {
                if (!this.currentCategory || !this.defaultPrompts) return;

                if (!confirm('Reset this category to default settings?')) {
                    return;
                }

                const template = this.defaultPrompts.templates[this.currentCategory];
                if (template) {
                    const categoryConfig = this.config.categories[this.currentCategory];
                    categoryConfig.displayName = template.displayName;
                    categoryConfig.prompt = template.prompt;
                    categoryConfig.settings = {
                        model: "claude-3-5-haiku-20241022",
                        maxTokens: 8000,
                        ...template.settings
                    };

                    this.render();
                    this.markDirty();
                }
            }

            formatRelativeTime(isoString) {
                const date = new Date(isoString);
                const now = new Date();
                const seconds = Math.floor((now - date) / 1000);

                if (seconds < 60) return 'Just now';
                if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
                if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
                return `${Math.floor(seconds / 86400)}d ago`;
            }
        }

        // Initialize AI Config Panel and Prompt Editor
        // Make them global so they can be accessed from onclick handlers
        window.aiConfigPanel = new AIConfigPanel();
        window.promptEditor = new PromptEditor();

        // Initialize config panel when page loads
        aiConfigPanel.init();

        // Add scroll effect to AI navigation
        let lastScrollTop = 0;

        // Listen on window scroll or main content wrapper scroll
        window.addEventListener('scroll', function() {
            const aiNav = document.getElementById('ai-nav-container');
            if (!aiNav || aiNav.style.display === 'none') return;

            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

            if (scrollTop > 100) {
                aiNav.classList.add('scrolled');
            } else {
                aiNav.classList.remove('scrolled');
            }

            lastScrollTop = scrollTop;
        });

        // Also listen on main content wrapper if it scrolls
        const mainContent = document.querySelector('.main-content-wrapper');
        if (mainContent) {
            mainContent.addEventListener('scroll', function() {
                const aiNav = document.getElementById('ai-nav-container');
                if (!aiNav || aiNav.style.display === 'none') return;

                const scrollTop = mainContent.scrollTop;

                if (scrollTop > 50) {
                    aiNav.classList.add('scrolled');
                } else {
                    aiNav.classList.remove('scrolled');
                }
            });
        }

    </script>
</body>
</html>
