<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collaborative Transcript Editor - CloudDrive</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <!-- Build: 2025-11-17-00:53 -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://unpkg.com; style-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; connect-src 'self' https://*.execute-api.us-east-2.amazonaws.com https://*.cloudfront.net https://*.s3.us-east-2.amazonaws.com https://*.s3.amazonaws.com; media-src 'self' blob: https:; img-src 'self' data: https:; font-src 'self' data: https://cdnjs.cloudflare.com; worker-src 'self' blob:;">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --primary-light: #dbeafe;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --gray-50: #f9fafb;
            --gray-100: #f3f4f6;
            --gray-200: #e5e7eb;
            --gray-300: #d1d5db;
            --gray-400: #9ca3af;
            --gray-500: #6b7280;
            --gray-600: #4b5563;
            --gray-700: #374151;
            --gray-800: #1f2937;
            --gray-900: #111827;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--gray-50);
            color: var(--gray-900);
        }

        /* Header */
        .header {
            background: white;
            border-bottom: 1px solid var(--gray-200);
            padding: 16px 24px;
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 20px;
            font-weight: 700;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .breadcrumb-nav {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .breadcrumb-link {
            display: flex;
            align-items: center;
            gap: 6px;
            color: var(--primary);
            text-decoration: none;
            padding: 6px 12px;
            border-radius: 6px;
            transition: all 0.2s;
            cursor: pointer;
        }

        .breadcrumb-link:hover {
            background: var(--primary-light);
        }

        .breadcrumb-link i {
            font-size: 16px;
        }

        .breadcrumb-separator {
            color: var(--gray-400);
            font-size: 12px;
        }

        .breadcrumb-current {
            color: var(--gray-700);
            font-weight: 600;
        }

        .header-actions {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        /* Two-Panel Layout */
        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 24px;
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 24px;
            min-height: calc(100vh - 80px);
        }

        /* Sidebar */
        .sidebar {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            height: fit-content;
            position: sticky;
            top: 100px;
        }

        .sidebar-section {
            margin-bottom: 24px;
        }

        .sidebar-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--gray-700);
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .plugin-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .plugin-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            border: 1px solid var(--gray-200);
            border-radius: 6px;
            background: white;
            color: var(--gray-700);
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            text-align: left;
        }

        .plugin-btn:hover {
            background: var(--gray-50);
            border-color: var(--primary);
            color: var(--primary);
        }

        .plugin-btn.active {
            background: var(--primary-light);
            border-color: var(--primary);
            color: var(--primary);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .stat-card {
            background: var(--gray-50);
            padding: 12px;
            border-radius: 6px;
            border: 1px solid var(--gray-200);
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--primary);
        }

        .stat-label {
            font-size: 12px;
            color: var(--gray-600);
            margin-top: 4px;
        }

        /* Editor Panel */
        .editor-panel {
            background: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .editor-toolbar {
            background: var(--gray-50);
            border-bottom: 1px solid var(--gray-200);
            padding: 12px 20px;
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .toolbar-group {
            display: flex;
            gap: 6px;
            align-items: center;
            padding-right: 12px;
            border-right: 1px solid var(--gray-300);
        }

        .toolbar-group:last-child {
            border-right: none;
        }

        .toolbar-btn {
            padding: 6px 12px;
            border-radius: 6px;
            border: 1px solid var(--gray-300);
            background: white;
            color: var(--gray-700);
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .toolbar-btn:hover {
            background: var(--gray-100);
            border-color: var(--primary);
        }

        .toolbar-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .search-box {
            flex: 1;
            min-width: 250px;
            max-width: 400px;
        }

        .search-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--gray-300);
            border-radius: 6px;
            font-size: 14px;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px var(--primary-light);
        }

        /* Dropdown Menu */
        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 4px;
            background: white;
            border: 1px solid var(--gray-300);
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            min-width: 180px;
            z-index: 1000;
        }

        .dropdown-menu.show {
            display: block;
        }

        .dropdown-item {
            display: block;
            width: 100%;
            padding: 10px 16px;
            border: none;
            background: white;
            text-align: left;
            font-size: 14px;
            color: var(--gray-700);
            cursor: pointer;
            transition: background 0.2s;
        }

        .dropdown-item:first-child {
            border-radius: 6px 6px 0 0;
        }

        .dropdown-item:last-child {
            border-radius: 0 0 6px 6px;
        }

        .dropdown-item:hover {
            background: var(--gray-100);
        }

        /* Editor Content */
        .editor-content {
            padding: 32px;
            max-width: 900px;
            margin: 0 auto;
        }

        .paragraph-container {
            margin-bottom: 32px;
            position: relative;
            padding-left: 48px;
            display: flex;
            flex-direction: column;
        }

        .paragraph-number {
            position: absolute;
            left: 0;
            top: 0;
            width: 36px;
            height: 36px;
            background: var(--gray-100);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
            color: var(--gray-600);
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .paragraph-number:hover {
            background: var(--primary);
            color: white;
        }

        .paragraph-text {
            line-height: 1.8;
            font-size: 16px;
            color: var(--gray-800);
            padding: 16px;
            border-radius: 8px;
            border: 2px solid transparent;
            transition: all 0.2s;
            outline: none;
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }

        .paragraph-text:hover {
            background: var(--gray-50);
        }

        .paragraph-text:focus {
            border-color: var(--primary);
            background: white;
            box-shadow: 0 0 0 3px var(--primary-light);
        }

        .paragraph-text.playing {
            background: #fef3c7;
            border-color: #f59e0b;
        }

        .paragraph-text.edited {
            border-left: 4px solid var(--success);
        }

        .paragraph-meta {
            display: flex;
            gap: 12px;
            margin-top: 8px;
            font-size: 12px;
            color: var(--gray-500);
            padding-left: 16px;
            user-select: none !important;
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            pointer-events: all;
        }

        .paragraph-meta * {
            user-select: none !important;
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .chunk-badge {
            background: var(--primary-light);
            color: var(--primary);
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .chunk-badge:hover {
            background: var(--primary);
            color: white;
        }

        .audio-btn {
            background: var(--success);
            color: white;
            border: none;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            transition: all 0.2s;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .audio-btn:hover {
            background: #059669;
        }

        /* Original Text Dropdown */
        .original-text-toggle {
            background: var(--gray-100);
            border: 1px solid var(--gray-300);
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            color: var(--gray-600);
            transition: all 0.2s;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .original-text-toggle:hover {
            background: var(--gray-200);
        }

        .original-text-content {
            display: none;
            margin-top: 12px;
            padding: 12px;
            background: var(--gray-50);
            border-left: 3px solid var(--gray-400);
            border-radius: 4px;
            font-size: 14px;
            color: var(--gray-600);
            font-style: italic;
        }

        .original-text-content.show {
            display: block;
        }

        /* Word Highlighting */
        .word-highlight {
            padding: 2px 4px;
            border-radius: 3px;
            cursor: pointer;
            transition: background-color 0.15s, color 0.15s;
            display: inline-block;
        }

        .word-highlight:hover {
            background: #fef08a;
        }

        .word-highlight.playing {
            background: #fbbf24;
            color: #78350f;
            font-weight: 500;
        }

        /* Plugin Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 24px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 16px;
        }

        .modal-close {
            float: right;
            cursor: pointer;
            font-size: 24px;
            color: var(--gray-500);
        }

        .modal-close:hover {
            color: var(--gray-700);
        }

        /* Loading & Toast */
        .loading {
            text-align: center;
            padding: 48px;
            color: var(--gray-600);
        }

        .spinner {
            border: 3px solid var(--gray-200);
            border-top: 3px solid var(--primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .toast {
            position: fixed;
            bottom: 24px;
            right: 24px;
            background: var(--success);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s;
            z-index: 3000;
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }

        .toast.error {
            background: var(--danger);
        }

        /* Button Styles */
        .btn {
            padding: 10px 18px;
            border-radius: 6px;
            border: 1px solid var(--gray-300);
            background: white;
            color: var(--gray-700);
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .btn:hover {
            background: var(--gray-50);
        }

        .btn-primary {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .btn-primary:hover {
            background: var(--primary-dark);
        }

        /* AI Timeline Navigation Styles */
        .ai-nav-container {
            position: sticky;
            top: 64px; /* Below header */
            z-index: 90;
            background: white;
            border-radius: 0 0 12px 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            margin-bottom: 24px;
            margin-top: -64px; /* Pull up under header */
            padding-top: 64px; /* Space for header */
        }

        /* Add slight padding when scrolled */
        .ai-nav-container.scrolled {
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
        }

        /* Main content wrapper for scroll context */
        .main-content-wrapper {
            flex: 1;
            min-height: 0;
            overflow-y: auto;
        }

        /* Editor panel needs to allow scrolling */
        .editor-panel {
            background: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            overflow: visible;
        }

        .ai-nav-tabs {
            display: flex;
            gap: 8px;
            padding: 16px;
            background: var(--gray-50);
            border-bottom: 1px solid var(--gray-200);
            overflow-x: auto;
        }

        .ai-nav-tab {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 16px;
            border: 2px solid transparent;
            border-radius: 8px;
            background: white;
            color: var(--gray-700);
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .ai-nav-tab:hover {
            border-color: var(--gray-300);
            background: var(--gray-100);
        }

        .ai-nav-tab.active {
            color: white;
            border-color: currentColor;
        }

        .ai-nav-tab.active.highlights { background: #8b5cf6; }
        .ai-nav-tab.active.questions { background: #ec4899; }
        .ai-nav-tab.active.actionItems { background: #ef4444; }
        .ai-nav-tab.active.keyTerms { background: #3b82f6; }
        .ai-nav-tab.active.keyThemes { background: #f59e0b; }
        .ai-nav-tab.active.topicChanges { background: #10b981; }
        .ai-nav-tab.active.all { background: var(--primary); }

        .ai-count-badge {
            background: rgba(255,255,255,0.3);
            color: inherit;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        .ai-nav-tab.active .ai-count-badge {
            background: rgba(255,255,255,0.25);
        }

        .timeline-container {
            padding: 24px;
            background: white;
        }

        .timeline-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .timeline-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--gray-700);
        }

        .timeline-duration {
            font-size: 13px;
            color: var(--gray-500);
        }

        .timeline-track-wrapper {
            position: relative;
            height: 60px;
            background: var(--gray-100);
            border-radius: 8px;
            overflow: visible;
        }

        .timeline-track {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .timeline-marker {
            position: absolute;
            top: 0;
            width: 4px;
            height: 100%;
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .timeline-marker:hover {
            width: 8px;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .timeline-marker.segment {
            height: 100%;
            opacity: 0.4;
        }

        .timeline-marker.segment:hover {
            opacity: 0.6;
        }

        .timeline-time-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 11px;
            color: var(--gray-500);
        }

        .timeline-tooltip {
            position: fixed;
            background: var(--gray-900);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            max-width: 320px;
            z-index: 2000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .timeline-tooltip.show {
            opacity: 1;
        }

        .tooltip-time {
            font-weight: 600;
            color: #fbbf24;
            margin-bottom: 6px;
        }

        .tooltip-summary {
            line-height: 1.5;
        }

        .ai-highlighted {
            animation: highlight-pulse 2s ease-in-out;
        }

        @keyframes highlight-pulse {
            0%, 100% { background: var(--gray-50); }
            50% { background: #fef3c7; }
        }

        /* Question highlighting styles - alternating shades */
        .question-highlight {
            font-weight: 700;
            padding: 2px 0;
        }

        .question-highlight.shade-1 {
            color: #ec4899;  /* Base pink */
        }

        .question-highlight.shade-2 {
            color: #db2777;  /* Darker pink */
        }

        .question-highlight.shade-3 {
            color: #f472b6;  /* Lighter pink */
        }

        .question-highlight.shade-4 {
            color: #be185d;  /* Deep pink */
        }

        .question-paragraph {
            margin-top: 24px !important;
            margin-bottom: 24px !important;
            padding-top: 16px;
            padding-bottom: 16px;
            border-left: 4px solid #ec4899;
            background: #fdf2f8;
        }

        .ai-loading-state {
            text-align: center;
            padding: 32px;
            color: var(--gray-600);
        }

        .ai-empty-state {
            text-align: center;
            padding: 32px;
            color: var(--gray-500);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .main-container {
                grid-template-columns: 1fr;
            }

            .sidebar {
                position: relative;
                top: 0;
            }

            .ai-nav-tabs {
                overflow-x: scroll;
            }

            .timeline-track-wrapper {
                height: 80px;
            }
        }

        /* ====================================================================
           AI Configuration Panel
           ==================================================================== */

        .config-header {
            padding: 16px;
            border-bottom: 1px solid var(--gray-200);
        }

        .back-button {
            background: none;
            border: none;
            color: var(--gray-500);
            cursor: pointer;
            font-size: 14px;
            padding: 6px 12px;
            margin-bottom: 8px;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .back-button:hover {
            color: var(--gray-900);
            background: var(--gray-100);
        }

        .config-section {
            padding: 16px;
            border-bottom: 1px solid var(--gray-100);
        }

        .category-name-input {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid var(--gray-200);
            border-radius: 6px;
            font-size: 14px;
            margin-top: 4px;
            transition: border-color 0.2s;
        }

        .category-name-input:focus {
            border-color: var(--primary);
            outline: none;
        }

        .hint {
            color: var(--gray-500);
            font-size: 12px;
            font-style: italic;
            display: block;
            margin-top: 4px;
        }

        /* Prompt Editor */
        .prompt-editor-wrapper {
            position: relative;
            margin-top: 4px;
        }

        .prompt-editor {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--gray-200);
            border-radius: 6px;
            font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
            resize: vertical;
            min-height: 80px;
            max-height: 400px;
            transition: border-color 0.2s;
        }

        .prompt-editor:focus {
            border-color: #8b5cf6;
            outline: none;
        }

        .prompt-editor.dirty {
            border-left: 4px solid var(--warning);
        }

        .expand-button {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: white;
            border: 1px solid var(--gray-300);
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .expand-button:hover {
            background: var(--gray-100);
            border-color: var(--gray-400);
        }

        /* Settings Grid */
        .settings-grid {
            display: grid;
            gap: 12px;
            margin-top: 8px;
        }

        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .setting-item label {
            font-size: 12px;
            color: var(--gray-600);
            font-weight: 500;
        }

        .setting-item select,
        .setting-item input[type="number"],
        .setting-item input[type="text"] {
            padding: 6px 10px;
            border: 1px solid var(--gray-300);
            border-radius: 4px;
            font-size: 13px;
            transition: border-color 0.2s;
        }

        .setting-item select:focus,
        .setting-item input:focus {
            border-color: var(--primary);
            outline: none;
        }

        .setting-item input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        /* Status Section */
        .status-section {
            background: var(--gray-50);
        }

        .status-info {
            background: white;
            border-radius: 6px;
            padding: 12px;
            margin-top: 8px;
            border: 1px solid var(--gray-200);
        }

        .status-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            font-size: 13px;
        }

        .status-row span:first-child {
            color: var(--gray-600);
        }

        .status-row span:last-child {
            font-weight: 600;
            color: var(--gray-900);
        }

        /* Action Buttons */
        .config-actions {
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .btn-reanalyze {
            background: linear-gradient(135deg, #8b5cf6, #6d28d9);
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .btn-reanalyze:hover:not(:disabled) {
            background: linear-gradient(135deg, #7c3aed, #5b21b6);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
        }

        .btn-reanalyze:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-save {
            background: white;
            border: 2px solid var(--gray-200);
            padding: 10px 16px;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .btn-save:not([disabled]):hover {
            border-color: var(--primary);
            background: var(--primary-light);
        }

        .btn-save[disabled] {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-save.dirty {
            border-color: var(--warning);
            background: #fffbeb;
        }

        .btn-reset {
            background: none;
            border: none;
            color: var(--gray-600);
            padding: 8px;
            cursor: pointer;
            font-size: 13px;
            transition: color 0.2s;
        }

        .btn-reset:hover {
            color: var(--gray-900);
        }

        /* Progress Indicator */
        .progress-container {
            padding: 16px;
            background: #f0f9ff;
            border-top: 2px solid var(--primary);
            text-align: center;
        }

        .progress-spinner {
            width: 24px;
            height: 24px;
            border: 3px solid #dbeafe;
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .progress-text {
            font-size: 13px;
            color: #1e40af;
            font-weight: 500;
        }

        /* Transitions */
        #session-info,
        #ai-config-panel {
            transition: opacity 0.3s ease-in-out;
        }

        #session-info.hiding,
        #ai-config-panel.hiding {
            opacity: 0;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="header-content">
            <div class="breadcrumb-nav">
                <a href="index.html" class="breadcrumb-link">
                    <i class="fas fa-home"></i>
                    Dashboard
                </a>
                <span class="breadcrumb-separator">‚Ä∫</span>
                <span class="breadcrumb-current">Collaborative Transcript Editor</span>
            </div>
            <div class="header-actions">
                <select id="timezone-selector" style="padding: 8px 12px; border: 1px solid var(--gray-300); border-radius: 6px; font-size: 14px; background: white; cursor: pointer; margin-right: 12px;">
                    <option value="UTC">UTC</option>
                    <option value="America/New_York">Eastern (ET)</option>
                    <option value="America/Chicago">Central (CT)</option>
                    <option value="America/Denver">Mountain (MT)</option>
                    <option value="America/Los_Angeles">Pacific (PT)</option>
                    <option value="America/Phoenix">Arizona (MST)</option>
                    <option value="America/Anchorage">Alaska (AKT)</option>
                    <option value="Pacific/Honolulu">Hawaii (HST)</option>
                    <option value="Europe/London">London (GMT/BST)</option>
                    <option value="Europe/Paris">Paris (CET)</option>
                    <option value="Europe/Berlin">Berlin (CET)</option>
                    <option value="Asia/Tokyo">Tokyo (JST)</option>
                    <option value="Asia/Shanghai">Shanghai (CST)</option>
                    <option value="Asia/Dubai">Dubai (GST)</option>
                    <option value="Australia/Sydney">Sydney (AEDT)</option>
                </select>
                <span id="user-email" style="color: var(--gray-600); font-size: 14px;"></span>
                <button class="btn" id="logout-btn">Logout</button>
            </div>
        </div>
    </div>

    <!-- Loading State -->
    <div id="loading" class="loading">
        <div class="spinner"></div>
        <div>Loading and processing transcript...</div>
    </div>

    <!-- Main Container -->
    <div id="main-container" class="main-container" style="display: none;">
        <!-- Sidebar -->
        <div class="sidebar">
            <!-- Session Info (default view) -->
            <div id="session-info">
            <!-- Session Selector -->
            <div class="sidebar-section">
                <div class="sidebar-title">Session</div>
                <select id="session-selector" style="width: 100%; padding: 8px 12px; border: 1px solid var(--gray-300); border-radius: 6px; font-size: 14px; background: white; cursor: pointer;">
                    <option value="">Loading sessions...</option>
                </select>
            </div>

            <!-- Stats -->
            <div class="sidebar-section">
                <div class="sidebar-title">Statistics</div>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="stat-paragraphs">0</div>
                        <div class="stat-label">Paragraphs</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="stat-words">0</div>
                        <div class="stat-label">Words</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="stat-duration">0:00</div>
                        <div class="stat-label">Duration</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="stat-wpm">0</div>
                        <div class="stat-label">WPM</div>
                    </div>
                </div>
            </div>

            <!-- Actions -->
            <div class="sidebar-section">
                <div class="sidebar-title">Actions</div>
                <div class="plugin-list">
                    <button class="plugin-btn" onclick="pluginManager.showSearchDialog()">
                        üîç Search
                    </button>
                    <button class="plugin-btn" onclick="pluginManager.showReplaceDialog()">
                        üîÑ Find & Replace
                    </button>
                    <button class="plugin-btn" onclick="pluginManager.showHighlightDialog()">
                        ‚ú® Highlight Keywords
                    </button>
                    <button class="plugin-btn" onclick="pluginManager.extractActions()">
                        ‚úÖ Extract Action Items
                    </button>
                    <button class="plugin-btn" onclick="pluginManager.showWordFrequency()">
                        üìä Word Frequency
                    </button>
                </div>
            </div>

            <!-- Export -->
            <div class="sidebar-section">
                <div class="sidebar-title">Export</div>
                <div class="plugin-list">
                    <button class="plugin-btn" onclick="pluginManager.export('plain')">
                        üìÑ Plain Text
                    </button>
                    <button class="plugin-btn" onclick="pluginManager.export('markdown')">
                        üìù Markdown
                    </button>
                    <button class="plugin-btn" onclick="pluginManager.export('srt')">
                        üé¨ SRT Subtitles
                    </button>
                    <button class="plugin-btn" onclick="pluginManager.export('json')">
                        üíæ JSON
                    </button>
                </div>
            </div>

            <!-- Save -->
            <button class="btn btn-primary" style="width: 100%;" onclick="saveTranscript()">
                üíæ Save Changes
            </button>
            </div>
            <!-- End Session Info -->

            <!-- AI Configuration Panel (hidden by default) -->
            <div id="ai-config-panel" style="display: none;">
                <!-- Header -->
                <div class="config-header">
                    <button onclick="aiConfigPanel.close()" class="back-button">
                        ‚Üê Back to Session
                    </button>
                    <h3 style="margin: 0; font-size: 16px; color: var(--gray-900);">‚ú® AI Category Configuration</h3>
                </div>

                <!-- Category Name -->
                <div class="config-section">
                    <label for="category-name" style="display: block; font-weight: 600; font-size: 13px; margin-bottom: 4px; color: var(--gray-700);">Tab Name:</label>
                    <input type="text" id="category-name" class="category-name-input" placeholder="e.g., Key Interviewer Questions">
                    <small class="hint">This name appears in the timeline tab</small>
                </div>

                <!-- Prompt Editor -->
                <div class="config-section">
                    <label for="category-prompt" style="display: block; font-weight: 600; font-size: 13px; margin-bottom: 4px; color: var(--gray-700);">Prompt:</label>
                    <div class="prompt-editor-wrapper">
                        <textarea id="category-prompt" class="prompt-editor" rows="4"></textarea>
                        <button onclick="promptEditor.toggleExpand()" class="expand-button">
                            ‚ñº Expand
                        </button>
                    </div>
                </div>

                <!-- Settings -->
                <div class="config-section">
                    <label style="display: block; font-weight: 600; font-size: 13px; margin-bottom: 8px; color: var(--gray-700);">Settings:</label>
                    <div class="settings-grid">
                        <div class="setting-item">
                            <label for="setting-model">Model:</label>
                            <select id="setting-model">
                                <option value="claude-3-5-haiku-20241022">Claude 3.5 Haiku (Fast)</option>
                                <option value="claude-3-5-sonnet-20241022">Claude 3.5 Sonnet (Best)</option>
                            </select>
                        </div>

                        <div class="setting-item">
                            <label for="setting-max-items">Max Items:</label>
                            <input type="number" id="setting-max-items" min="1" max="50" value="15">
                        </div>

                        <!-- Category-specific settings rendered dynamically -->
                        <div id="category-specific-settings"></div>
                    </div>
                </div>

                <!-- Status -->
                <div class="config-section status-section">
                    <label style="display: block; font-weight: 600; font-size: 13px; margin-bottom: 8px; color: var(--gray-700);">Status:</label>
                    <div class="status-info">
                        <div class="status-row">
                            <span>Last analyzed:</span>
                            <span id="last-analyzed-time">Never</span>
                        </div>
                        <div class="status-row">
                            <span>Estimated cost:</span>
                            <span id="estimated-cost">$0.0000</span>
                        </div>
                        <div class="status-row">
                            <span>Current count:</span>
                            <span id="current-count">0 items</span>
                        </div>
                    </div>
                </div>

                <!-- Actions -->
                <div class="config-actions">
                    <button onclick="aiConfigPanel.reanalyzeCategory()" class="btn-primary btn-reanalyze">
                        üîÑ Re-analyze This Category
                    </button>

                    <button onclick="aiConfigPanel.saveConfig()" class="btn-secondary btn-save" disabled>
                        üíæ Save Configuration
                    </button>

                    <button onclick="aiConfigPanel.resetToDefault()" class="btn-text btn-reset">
                        Reset to Default
                    </button>
                </div>

                <!-- Progress Indicator (shown during re-analysis) -->
                <div id="reanalysis-progress" class="progress-container" style="display: none;">
                    <div class="progress-spinner"></div>
                    <div class="progress-text">
                        Re-analyzing... <span id="progress-eta">~10s</span>
                    </div>
                </div>
            </div>
            <!-- End AI Config Panel -->
        </div>

        <!-- Main Content Column -->
        <div class="main-content-wrapper" style="display: flex; flex-direction: column; position: relative; overflow: visible;">
            <!-- AI Timeline Navigation (Sticky) -->
            <div id="ai-nav-container" class="ai-nav-container" style="display: none;">
                <!-- Navigation Tabs -->
                <div class="ai-nav-tabs">
                    <button class="ai-nav-tab all active" onclick="aiNavigator.filterByType('all')" data-type="all">
                        üåê All
                        <span class="ai-count-badge" id="count-all">0</span>
                    </button>
                    <button class="ai-nav-tab highlights" onclick="aiNavigator.filterByType('highlights')" data-type="highlights">
                        ‚ú® Highlights
                        <span class="ai-count-badge" id="count-highlights">0</span>
                    </button>
                    <button class="ai-nav-tab questions" onclick="aiNavigator.filterByType('questions')" data-type="questions">
                        ‚ùì Questions
                        <span class="ai-count-badge" id="count-questions">0</span>
                    </button>
                    <button class="ai-nav-tab actionItems" onclick="aiNavigator.filterByType('actionItems')" data-type="actionItems">
                        ‚úÖ Action Items
                        <span class="ai-count-badge" id="count-actionItems">0</span>
                    </button>
                    <button class="ai-nav-tab keyTerms" onclick="aiNavigator.filterByType('keyTerms')" data-type="keyTerms">
                        üìö Key Terms
                        <span class="ai-count-badge" id="count-keyTerms">0</span>
                    </button>
                    <button class="ai-nav-tab keyThemes" onclick="aiNavigator.filterByType('keyThemes')" data-type="keyThemes">
                        üéØ Themes
                        <span class="ai-count-badge" id="count-keyThemes">0</span>
                    </button>
                    <button class="ai-nav-tab topicChanges" onclick="aiNavigator.filterByType('topicChanges')" data-type="topicChanges">
                        üîÄ Topic Changes
                        <span class="ai-count-badge" id="count-topicChanges">0</span>
                    </button>
                </div>

                <!-- Timeline Track -->
                <div class="timeline-container">
                    <div class="timeline-header">
                        <div class="timeline-title">Interactive Timeline</div>
                        <div class="timeline-duration" id="timeline-duration">0:00</div>
                    </div>
                    <div class="timeline-track-wrapper">
                        <div class="timeline-track" id="timeline-track">
                            <!-- Markers added dynamically -->
                        </div>
                    </div>
                    <div class="timeline-time-labels">
                        <span>0:00</span>
                        <span id="timeline-end-label">0:00</span>
                    </div>
                </div>
            </div>

            <!-- Editor Panel -->
            <div class="editor-panel">
            <div class="editor-toolbar">
                <div class="toolbar-group">
                    <button class="toolbar-btn" id="edit-mode-btn" title="Toggle Edit Mode" onclick="toggleEditMode()">
                        ‚úèÔ∏è Edit Mode: OFF
                    </button>
                </div>

                <div class="toolbar-group">
                    <button class="toolbar-btn" title="Undo" onclick="document.execCommand('undo')" id="undo-btn" disabled>
                        ‚Ü∂
                    </button>
                    <button class="toolbar-btn" title="Redo" onclick="document.execCommand('redo')" id="redo-btn" disabled>
                        ‚Ü∑
                    </button>
                </div>

                <div class="toolbar-group">
                    <button class="toolbar-btn" title="Bold" onclick="document.execCommand('bold')" id="bold-btn" disabled>
                        <strong>B</strong>
                    </button>
                    <button class="toolbar-btn" title="Italic" onclick="document.execCommand('italic')" id="italic-btn" disabled>
                        <em>I</em>
                    </button>
                    <button class="toolbar-btn" title="Underline" onclick="document.execCommand('underline')" id="underline-btn" disabled>
                        <u>U</u>
                    </button>
                </div>

                <div class="search-box">
                    <input type="text" class="search-input" id="quick-search" placeholder="Quick search..." onkeyup="quickSearch(this.value)">
                </div>

                <div class="toolbar-group">
                    <div class="dropdown">
                        <button class="toolbar-btn" onclick="toggleDownloadMenu()">
                            ‚¨áÔ∏è Download
                        </button>
                        <div class="dropdown-menu" id="download-menu">
                            <button class="dropdown-item" onclick="downloadTranscript('markdown')">
                                üìù Markdown (.md)
                            </button>
                            <button class="dropdown-item" onclick="downloadTranscript('text')">
                                üìÑ Plain Text (.txt)
                            </button>
                            <button class="dropdown-item" onclick="downloadTranscript('json')">
                                üìä JSON (.json)
                            </button>
                        </div>
                    </div>
                    <button class="toolbar-btn" onclick="copyAsMarkdown()">
                        üìã Copy MD
                    </button>
                </div>

                <button class="toolbar-btn" onclick="copyAllText()">
                    üìã Copy All
                </button>
            </div>

            <div class="editor-content" id="editor-content">
                <!-- Paragraphs will be rendered here -->
            </div>
        </div>
    </div>

    <!-- Plugin Modal -->
    <div id="plugin-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeModal()">&times;</span>
            <h2 class="modal-title" id="modal-title">Plugin</h2>
            <div id="modal-body"></div>
        </div>
    </div>

    <!-- Toast -->
    <div id="toast" class="toast"></div>

    <!-- AI Timeline Tooltip -->
    <div id="timeline-tooltip" class="timeline-tooltip">
        <div class="tooltip-time" id="tooltip-time"></div>
        <div class="tooltip-summary" id="tooltip-summary"></div>
    </div>

    <!-- Preprocessor Scripts - Version 2 for cache busting -->
    <script src="https://d2l28rla2hk7np.cloudfront.net/transcript-preprocessor-boundary.js?v=2" onerror="console.error('Failed to load transcript-preprocessor-boundary.js')"></script>
    <script src="https://d2l28rla2hk7np.cloudfront.net/transcript-preprocessor-simple.js?v=2" onerror="console.error('Failed to load transcript-preprocessor-simple.js')"></script>
    <script src="https://d2l28rla2hk7np.cloudfront.net/transcript-preprocessor.js?v=2" onerror="console.error('Failed to load transcript-preprocessor.js')"></script>
    <script src="https://d2l28rla2hk7np.cloudfront.net/transcript-plugins.js?v=2" onerror="console.error('Failed to load transcript-plugins.js')"></script>

    <script>
        // Verify scripts loaded
        window.addEventListener('DOMContentLoaded', () => {
            console.log('=== Script Loading Status ===');
            console.log('TranscriptPreprocessor:', typeof window.TranscriptPreprocessor);
            console.log('TranscriptPreprocessorBoundary:', typeof window.TranscriptPreprocessorBoundary);
            console.log('TranscriptPreprocessorSimple:', typeof window.TranscriptPreprocessorSimple);
            console.log('TranscriptPluginManager:', typeof window.TranscriptPluginManager);
            console.log('============================');
        });
    </script>

    <script>
        // Configuration
        const config = {
            userPoolId: 'us-east-2_6sN45GbIh',
            userPoolClientId: '7sjtp1gd6buhs3a7b362pvod3a',
            identityPoolId: 'us-east-2:43b4ec02-d7c0-4c8b-a188-27b9d1f16287',
            region: 'us-east-2',
            apiUrl: 'https://5x0ygivhe1.execute-api.us-east-2.amazonaws.com/dev',
            s3ApiUrl: 'https://5x0ygivhe1.execute-api.us-east-2.amazonaws.com/dev',
            appUrl: 'https://d2l28rla2hk7np.cloudfront.net'
        };

        let transcriptData = null;
        let processedData = null;
        let currentSession = null;
        let preprocessor = null;
        let pluginManager = null;
        let audioCache = new Map();

        // Audio playback state
        let currentAudio = null;
        let currentPlayingIndex = null;
        let currentPlayButton = null;
        let wordHighlightInterval = null;

        // Auth functions
        function getAuthToken() {
            return localStorage.getItem('id_token');
        }

        function getUserEmail() {
            try {
                const token = getAuthToken();
                if (token) {
                    const payload = JSON.parse(atob(token.split('.')[1]));
                    return payload.email || payload.sub || 'User';
                }
            } catch (e) {
                console.error('Error parsing token:', e);
            }
            return 'User';
        }

        function getUserId() {
            try {
                const token = getAuthToken();
                if (token) {
                    const payload = JSON.parse(atob(token.split('.')[1]));
                    return payload.sub;
                }
            } catch (e) {
                console.error('Error parsing token for userId:', e);
            }
            return null;
        }

        function logout() {
            localStorage.clear();
            window.location.href = 'index.html';
        }

        // API calls
        async function apiCall(endpoint, options = {}) {
            const token = getAuthToken();
            const response = await fetch(`${config.apiUrl}${endpoint}`, {
                ...options,
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json',
                    ...options.headers
                }
            });

            if (!response.ok) {
                throw new Error(`API call failed: ${response.statusText}`);
            }

            return await response.json();
        }

        // Initialize
        window.addEventListener('DOMContentLoaded', async () => {
            const token = getAuthToken();
            if (!token) {
                window.location.href = 'index.html';
                return;
            }

            // Validate token
            try {
                const payload = JSON.parse(atob(token.split('.')[1]));
                const now = Math.floor(Date.now() / 1000);
                if (payload.exp && payload.exp < now) {
                    localStorage.clear();
                    window.location.href = 'index.html';
                    return;
                }
            } catch (e) {
                window.location.href = 'index.html';
                return;
            }

            document.getElementById('user-email').textContent = getUserEmail();
            document.getElementById('logout-btn').onclick = logout;

            // Initialize preprocessor and plugin manager
            console.log('Initializing TranscriptPreprocessor (boundary mode)...');
            preprocessor = new TranscriptPreprocessorBoundary({
                maxBoundaryWords: 10  // Only option for boundary preprocessor
            });
            console.log('Preprocessor initialized:', preprocessor);

            pluginManager = new UIPluginManager();

            // Setup timezone selector
            setupTimezoneSelector();

            await loadLatestSession();
        });

        // Setup timezone selector with auto-detection
        function setupTimezoneSelector() {
            const selector = document.getElementById('timezone-selector');

            // Try to auto-detect user's timezone
            try {
                const userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                console.log('Detected user timezone:', userTimezone);

                // Check if detected timezone is in our list
                const option = Array.from(selector.options).find(opt => opt.value === userTimezone);
                if (option) {
                    selector.value = userTimezone;
                    selectedTimezone = userTimezone;
                    console.log('Set timezone to detected:', userTimezone);
                } else {
                    // Default to UTC
                    selectedTimezone = 'UTC';
                }
            } catch (e) {
                console.error('Failed to detect timezone:', e);
                selectedTimezone = 'UTC';
            }

            // Add change handler
            selector.onchange = (e) => {
                selectedTimezone = e.target.value;
                console.log('Timezone changed to:', selectedTimezone);

                // Update session selector display names
                populateSessionSelector();

                showToast(`Timezone changed to ${selectedTimezone}`, 'success');
            };
        }

        // Store all sessions
        let allSessions = [];
        let selectedTimezone = 'UTC'; // Default timezone

        // Parse session folder timestamp
        // Formats: session_YYYY-MM-DDTHH_MM_SS_MMMZ (new)
        //      or: YYYY-MM-DD-session_YYYY-MM-DDTHH_MM_SS_MMMZ (legacy)
        function parseSessionTimestamp(folderName) {
            try {
                // Extract timestamp from folder name
                const match = folderName.match(/session_(\d{4})-(\d{2})-(\d{2})T(\d{2})_(\d{2})_(\d{2})_(\d{3})Z/);
                if (!match) return null;

                const [, year, month, day, hour, minute, second, ms] = match;
                // Create UTC date string
                const isoString = `${year}-${month}-${day}T${hour}:${minute}:${second}.${ms}Z`;
                return new Date(isoString);
            } catch (e) {
                console.error('Failed to parse session timestamp:', folderName, e);
                return null;
            }
        }

        // Format session display name with timezone conversion
        function formatSessionName(folderName, timezone) {
            const date = parseSessionTimestamp(folderName);
            if (!date) {
                // Fallback to original format
                return folderName.replace('session_', '').replace(/-session_/g, ' ');
            }

            try {
                // Create a more readable format: "Nov 18, 2025 8:35 PM PST"
                const dateOptions = {
                    timeZone: timezone,
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric'
                };

                const timeOptions = {
                    timeZone: timezone,
                    hour: 'numeric',
                    minute: '2-digit',
                    hour12: true
                };

                const datePart = new Intl.DateTimeFormat('en-US', dateOptions).format(date);
                const timePart = new Intl.DateTimeFormat('en-US', timeOptions).format(date);

                // Get timezone abbreviation
                const tzAbbr = timezone === 'UTC' ? 'UTC' :
                              new Intl.DateTimeFormat('en-US', { timeZone: timezone, timeZoneName: 'short' })
                                .formatToParts(date)
                                .find(part => part.type === 'timeZoneName')?.value || '';

                return `${datePart} ${timePart} ${tzAbbr}`;
            } catch (e) {
                console.error('Failed to format session name:', e);
                return folderName.replace('session_', '').replace(/-session_/g, ' ');
            }
        }

        // Load latest session
        async function loadLatestSession() {
            try {
                console.log('Loading latest session...');
                const data = await apiCall('/api/audio/sessions');
                console.log('Sessions loaded:', data.sessions?.length || 0);

                if (!data.sessions || data.sessions.length === 0) {
                    // Show empty state for no sessions
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('main-container').style.display = 'grid';

                    const editorContent = document.querySelector('.editor-content');
                    editorContent.innerHTML = `
                        <div style="text-align: center; padding: 64px 32px; color: var(--gray-500);">
                            <div style="font-size: 48px; margin-bottom: 16px;">üéôÔ∏è</div>
                            <h2 style="color: var(--gray-700); margin-bottom: 8px;">No Transcripts Found</h2>
                            <p>You haven't recorded any sessions yet.</p>
                            <p style="margin-top: 16px;">Start by recording a new session in the audio recorder.</p>
                        </div>
                    `;
                    showToast('No sessions found', 'error');
                    return;
                }

                // Filter sessions to only include those with transcriptions
                console.log('Filtering sessions with transcriptions...');
                const userId = getUserId();
                const sessionsWithTranscripts = await filterSessionsWithTranscripts(data.sessions, userId);

                console.log('Sessions with transcripts:', sessionsWithTranscripts.length);

                if (sessionsWithTranscripts.length === 0) {
                    // Show empty state
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('main-container').style.display = 'grid';

                    const editorContent = document.querySelector('.editor-content');
                    editorContent.innerHTML = `
                        <div style="text-align: center; padding: 64px 32px; color: var(--gray-500);">
                            <div style="font-size: 48px; margin-bottom: 16px;">üìù</div>
                            <h2 style="color: var(--gray-700); margin-bottom: 8px;">No Transcriptions Available</h2>
                            <p>None of your sessions have been transcribed yet.</p>
                            <p style="margin-top: 16px;">Run batch transcription to generate transcripts.</p>
                        </div>
                    `;
                    showToast('No transcribed sessions found', 'error');
                    return;
                }

                // Store filtered sessions and populate dropdown
                allSessions = sessionsWithTranscripts;
                populateSessionSelector();

                // Load the first session
                currentSession = sessionsWithTranscripts[0];
                console.log('Current session:', currentSession);
                await loadAndProcessTranscript();
            } catch (error) {
                console.error('Error loading session:', error);
                showToast('Failed to load session: ' + error.message, 'error');
            }
        }

        // Filter sessions to only include those with transcription files
        async function filterSessionsWithTranscripts(sessions, userId) {
            const checks = await Promise.all(
                sessions.map(async (session) => {
                    try {
                        const sessionPath = `users/${userId}/audio/sessions/${session.folder}`;

                        // Check for preprocessed file first (fastest)
                        try {
                            const processedKey = `${sessionPath}/transcription-processed.json`;
                            await apiCall(`/api/s3/download/${encodeURIComponent(processedKey)}`);
                            return { session, hasTranscript: true };
                        } catch {
                            // No preprocessed file, check for individual chunks
                            const listResponse = await apiCall(`/api/s3/list?prefix=audio/sessions/${session.folder}/&userScope=true`);
                            const hasChunks = listResponse.files.some(f =>
                                f.displayKey.includes('transcription-chunk-') && f.displayKey.endsWith('.json')
                            );
                            return { session, hasTranscript: hasChunks };
                        }
                    } catch {
                        return { session, hasTranscript: false };
                    }
                })
            );

            return checks
                .filter(result => result.hasTranscript)
                .map(result => result.session);
        }

        // Populate session selector dropdown
        function populateSessionSelector() {
            const selector = document.getElementById('session-selector');
            selector.innerHTML = '';

            allSessions.forEach((session, index) => {
                const option = document.createElement('option');
                option.value = index;

                // Format session display name with timezone conversion
                option.textContent = formatSessionName(session.folder, selectedTimezone);

                selector.appendChild(option);
            });

            // Add change handler
            selector.onchange = async (e) => {
                const selectedIndex = parseInt(e.target.value);
                if (selectedIndex >= 0 && selectedIndex < allSessions.length) {
                    currentSession = allSessions[selectedIndex];
                    console.log('Switched to session:', currentSession);

                    // Stop any playing audio from previous session
                    stopAudio();

                    // Clear audio cache to prevent playing cached audio from previous session
                    audioCache.clear();

                    // Reset AI timeline navigator to clear previous session's data
                    aiNavigator.reset();

                    // Show loading state
                    document.getElementById('loading').style.display = 'flex';
                    document.getElementById('main-container').style.display = 'none';

                    // Load new session
                    await loadAndProcessTranscript();
                }
            };

            // Check for preprocessed files in background (non-blocking)
            checkPreprocessedFiles();
        }

        // Check which sessions have preprocessed files (runs in background)
        async function checkPreprocessedFiles() {
            const userId = getUserId();
            const selector = document.getElementById('session-selector');

            for (let index = 0; index < allSessions.length; index++) {
                const session = allSessions[index];
                try {
                    const sessionPath = `users/${userId}/audio/sessions/${session.folder}`;
                    const processedKey = `${sessionPath}/transcription-processed.json`;
                    await apiCall(`/api/s3/download/${encodeURIComponent(processedKey)}`);

                    // Update option to show lightning bolt
                    const option = selector.options[index];
                    if (option) {
                        const sessionDate = formatSessionName(session.folder, selectedTimezone);
                        option.textContent = `‚ö° ${sessionDate}`;
                    }
                } catch {
                    // No preprocessed file, keep as-is
                }
            }
        }

        // Load and process transcript
        async function loadAndProcessTranscript() {
            try {
                console.log('Loading and processing transcript...');
                const userId = getUserId();
                const sessionFolder = currentSession.folder;
                console.log('User ID:', userId);
                console.log('Session folder:', sessionFolder);

                // Construct full S3 path
                const sessionPath = `users/${userId}/audio/sessions/${sessionFolder}`;
                console.log('Full session path:', sessionPath);

                // FAST PATH: Try to load pre-processed file first
                console.log('Checking for pre-processed transcript...');
                const processedKey = `${sessionPath}/transcription-processed.json`;

                try {
                    const downloadData = await apiCall(`/api/s3/download/${encodeURIComponent(processedKey)}`);
                    const response = await fetch(downloadData.downloadUrl);

                    if (response.ok) {
                        console.log('‚úÖ Found pre-processed transcript - loading instantly!');
                        processedData = await response.json();

                        // Render
                        renderEditor();

                        // Try to load AI analysis
                        await loadAIAnalysis();

                        // Hide loading, show content
                        document.getElementById('loading').style.display = 'none';
                        document.getElementById('main-container').style.display = 'grid';

                        showToast(`Loaded ${processedData.paragraphs.length} paragraphs (pre-processed)`);
                        return; // Done! Exit early
                    }
                } catch (preprocessError) {
                    console.log('Pre-processed file not found, falling back to chunk loading...');
                }

                // FALLBACK PATH: Load individual chunks (slower, but works for in-progress transcriptions)
                console.log('Listing transcription chunk files...');
                const listResponse = await apiCall(`/api/s3/list?prefix=audio/sessions/${sessionFolder}/&userScope=true`);

                const chunkFiles = listResponse.files
                    .filter(f => f.displayKey.includes('transcription-chunk-') && f.displayKey.endsWith('.json'))
                    .sort((a, b) => {
                        const aNum = parseInt(a.displayKey.match(/chunk-(\d+)\.json/)?.[1] || '0');
                        const bNum = parseInt(b.displayKey.match(/chunk-(\d+)\.json/)?.[1] || '0');
                        return aNum - bNum;
                    });

                console.log('Found chunk files:', chunkFiles.length);
                console.log('Chunk files:', chunkFiles.map(f => f.displayKey).join(', '));

                if (chunkFiles.length === 0) {
                    // No transcription files - show empty state
                    console.log('No transcription files found - showing empty state');

                    // Show main container so user can select different session
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('main-container').style.display = 'grid';

                    // Show message in editor area
                    const editorContent = document.querySelector('.editor-content');
                    editorContent.innerHTML = `
                        <div style="text-align: center; padding: 64px 32px; color: var(--gray-500);">
                            <div style="font-size: 48px; margin-bottom: 16px;">üìù</div>
                            <h2 style="color: var(--gray-700); margin-bottom: 8px;">No Transcription Available</h2>
                            <p>This session hasn't been transcribed yet.</p>
                            <p style="margin-top: 16px;">Select a different session from the dropdown above, or run batch transcription.</p>
                        </div>
                    `;

                    showToast('No transcription files found for this session', 'error');
                    return;
                }

                // Load all chunks IN PARALLEL (much faster than sequential)
                console.log('Loading chunk data in parallel...');
                const chunkPromises = chunkFiles.map(async (chunkFile) => {
                    const downloadData = await apiCall(`/api/s3/download/${encodeURIComponent(chunkFile.key)}`);
                    const response = await fetch(downloadData.downloadUrl);

                    if (response.ok) {
                        const chunkData = await response.json();
                        const chunkNum = parseInt(chunkFile.displayKey.match(/chunk-(\d+)\.json/)?.[1] || '0');
                        return {
                            chunkIndex: chunkNum,
                            chunkId: `chunk-${String(chunkNum).padStart(3, '0')}`,
                            ...chunkData
                        };
                    }
                    return null;
                });

                const chunks = (await Promise.all(chunkPromises)).filter(c => c !== null);

                // Process with preprocessor
                console.log('Processing chunks with boundary deduplication...');
                processedData = preprocessor.process(chunks);

                // Render
                renderEditor();

                // Try to load AI analysis
                await loadAIAnalysis();

                // Hide loading, show content
                document.getElementById('loading').style.display = 'none';
                document.getElementById('main-container').style.display = 'grid';

                showToast(`Processed ${processedData.paragraphs.length} paragraphs from ${chunks.length} chunks (slower fallback - run 518 script to speed up)`);
            } catch (error) {
                console.error('Error loading transcript:', error);
                showToast('Failed to load transcript: ' + error.message, 'error');
            }
        }

        // Load AI analysis if available
        async function loadAIAnalysis() {
            try {
                const hasAnalysis = await aiNavigator.loadAnalysis();
                if (hasAnalysis) {
                    aiNavigator.render();
                    console.log('‚úÖ AI Timeline Navigation enabled');
                } else {
                    console.log('‚ÑπÔ∏è  No AI analysis - timeline hidden');
                }
            } catch (error) {
                console.error('Error loading AI analysis:', error);
                // Hide timeline if error
                document.getElementById('ai-nav-container').style.display = 'none';
            }
        }

        // Format questions in a paragraph (initial render, no word timing)
        function formatQuestionsInParagraph(textDiv, para) {
            const text = para.text;
            const questionPatterns = [
                /\?$/,  // Ends with question mark
                /^(what|where|when|why|who|whom|which|whose|how)\b/i,
                /^(is|are|was|were|do|does|did|can|could|will|would|should|have|has|had)\b/i,
            ];

            // Split into sentences keeping punctuation attached
            const sentences = text.split(/(?<=[.!?])\s+/);
            let hasQuestion = false;
            let formattedHTML = '';
            let questionIndex = 0;  // Track question number for alternating colors

            sentences.forEach((sentence, i) => {
                const trimmed = sentence.trim();
                if (!trimmed) return;

                // Check if this sentence is a question
                const isQuestion = questionPatterns.some(pattern => pattern.test(trimmed)) ||
                                 trimmed.includes('?');

                if (isQuestion) {
                    hasQuestion = true;
                    // Cycle through 4 shades
                    const shade = (questionIndex % 4) + 1;
                    formattedHTML += '<br><span class="question-highlight shade-' + shade + '">' + trimmed + '</span><br>';
                    questionIndex++;
                } else {
                    formattedHTML += trimmed;
                    if (i < sentences.length - 1) {
                        formattedHTML += ' ';
                    }
                }
            });

            // Apply formatting
            if (hasQuestion) {
                textDiv.innerHTML = formattedHTML;
                textDiv.parentElement?.classList.add('question-paragraph');
            } else {
                textDiv.textContent = text;
            }
        }

        // Render editor
        function renderEditor() {
            const container = document.getElementById('editor-content');
            container.innerHTML = '';

            // Update stats
            document.getElementById('stat-paragraphs').textContent = processedData.stats.paragraphCount;
            document.getElementById('stat-words').textContent = processedData.stats.totalWords;
            document.getElementById('stat-duration').textContent = formatDuration(processedData.stats.totalDuration);
            document.getElementById('stat-wpm').textContent = Math.round(processedData.stats.wordsPerMinute);

            // Render paragraphs
            processedData.paragraphs.forEach((para, index) => {
                const paraDiv = document.createElement('div');
                paraDiv.className = 'paragraph-container';
                paraDiv.id = `para-${index}`;

                const number = document.createElement('div');
                number.className = 'paragraph-number';
                number.textContent = index + 1;
                number.onclick = () => {
                    const audioBtn = document.querySelector(`button.audio-btn[data-para-index="${index}"]`);
                    if (audioBtn) {
                        togglePlayPause(index, audioBtn);
                    }
                };

                const text = document.createElement('div');
                text.className = 'paragraph-text';
                text.contentEditable = false;  // Start in read-only mode for text selection
                text.dataset.paraIndex = index;
                text.addEventListener('input', () => markEdited(index));

                // Apply question formatting on initial render
                formatQuestionsInParagraph(text, para);

                const meta = document.createElement('div');
                meta.className = 'paragraph-meta';

                // Time
                const timeMeta = document.createElement('div');
                timeMeta.className = 'meta-item';
                timeMeta.innerHTML = `‚è±Ô∏è ${formatTime(para.start)} - ${formatTime(para.end)}`;

                // Audio button
                const audioBtn = document.createElement('button');
                audioBtn.className = 'audio-btn';
                audioBtn.textContent = '‚ñ∂ Play';
                audioBtn.setAttribute('data-para-index', index);

                // Single click: toggle play/pause
                audioBtn.onclick = () => togglePlayPause(index, audioBtn);

                // Double click: stop playback
                audioBtn.ondblclick = () => {
                    stopAudio();
                    audioBtn.textContent = '‚ñ∂ Play';
                };

                // Chunk badges
                const chunkMeta = document.createElement('div');
                chunkMeta.className = 'meta-item';
                para.chunkIds.forEach(chunkId => {
                    const badge = document.createElement('span');
                    badge.className = 'chunk-badge';
                    badge.textContent = chunkId;
                    badge.onclick = () => showChunkDetails(chunkId, index);
                    chunkMeta.appendChild(badge);
                });

                // Original text toggle
                const originalToggle = document.createElement('button');
                originalToggle.className = 'original-text-toggle';
                originalToggle.textContent = 'Show Original';
                originalToggle.onclick = () => toggleOriginal(index);

                meta.appendChild(timeMeta);
                meta.appendChild(audioBtn);
                meta.appendChild(chunkMeta);
                meta.appendChild(originalToggle);

                // Original text content (hidden by default)
                const originalContent = document.createElement('div');
                originalContent.className = 'original-text-content';
                originalContent.id = `original-${index}`;
                originalContent.textContent = para.segments.map(s => s.text).join(' ');

                paraDiv.appendChild(number);
                paraDiv.appendChild(text);
                paraDiv.appendChild(meta);
                paraDiv.appendChild(originalContent);

                container.appendChild(paraDiv);
            });
        }

        // Toggle play/pause
        async function togglePlayPause(index, button) {
            // If already playing this paragraph, pause it
            if (currentAudio && currentPlayingIndex === index) {
                if (currentAudio.paused) {
                    currentAudio.play();
                    button.textContent = '‚è∏ Pause';
                } else {
                    currentAudio.pause();
                    button.textContent = '‚ñ∂ Play';
                }
                return;
            }

            // Stop any currently playing audio
            if (currentAudio) {
                stopAudio();
            }

            // Start playing this paragraph
            await playParagraph(index, button);
        }

        // Stop audio playback
        function stopAudio() {
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio = null;
            }

            if (wordHighlightInterval) {
                clearInterval(wordHighlightInterval);
                wordHighlightInterval = null;
            }

            // Clear highlighting
            document.querySelectorAll('.paragraph-text').forEach(el => el.classList.remove('playing'));
            document.querySelectorAll('.word-highlight').forEach(el => el.classList.remove('playing'));

            // Restore question formatting for the paragraph that was playing
            if (currentPlayingIndex !== null && processedData && processedData.paragraphs) {
                const para = processedData.paragraphs[currentPlayingIndex];
                const paraText = document.querySelector(`[data-para-index="${currentPlayingIndex}"]`);
                if (paraText && para) {
                    formatQuestionsInParagraph(paraText, para);
                }
            }

            // Reset button
            if (currentPlayButton) {
                currentPlayButton.textContent = '‚ñ∂ Play';
                currentPlayButton = null;
            }

            currentPlayingIndex = null;
        }

        // Play paragraph audio with word-level highlighting
        async function playParagraph(index, button) {
            const para = processedData.paragraphs[index];
            const firstChunkId = para.chunkIds[0];
            const chunkIndex = parseInt(firstChunkId.match(/chunk-(\d+)/)?.[1] || '0');

            try {
                // Load audio chunk
                console.log('Attempting to load audio chunk:', chunkIndex);
                const audioUrl = await getChunkUrl(chunkIndex);
                console.log('Got audio URL, creating Audio element...');
                const audio = new Audio(audioUrl);

                // Add error handler before attempting to play
                audio.onerror = (e) => {
                    console.error('Audio element error:', e);
                    console.error('Audio error details:', {
                        error: audio.error,
                        code: audio.error?.code,
                        message: audio.error?.message,
                        url: audioUrl
                    });
                    showToast('Audio format not supported by browser', 'error');
                    stopAudio();
                    button.textContent = '‚ñ∂ Play';
                };

                currentAudio = audio;
                currentPlayingIndex = index;
                currentPlayButton = button;

                // Highlight paragraph
                document.querySelectorAll('.paragraph-text').forEach(el => el.classList.remove('playing'));
                const paraText = document.querySelector(`[data-para-index="${index}"]`);
                paraText.classList.add('playing');

                // Wrap words in spans with timing data
                wrapWordsWithTimestamps(paraText, para);

                // Play segment
                console.log('Setting currentTime to:', para.start);
                audio.currentTime = para.start;
                console.log('Attempting to play audio...');
                await audio.play();
                console.log('Audio playing successfully');
                button.textContent = '‚è∏ Pause';

                // Check if this is an uploaded file (single continuous audio)
                const isUpload = (currentSession.sessionId && currentSession.sessionId.includes('-upload-')) ||
                                 (currentSession.metadata && currentSession.metadata.source === 'upload');

                // Update word highlighting as audio plays
                wordHighlightInterval = setInterval(() => {
                    if (!audio.paused) {
                        if (isUpload) {
                            // For uploads, highlight across all paragraphs
                            highlightCurrentWordGlobal(audio.currentTime);
                        } else {
                            // For live sessions, highlight only current paragraph
                            highlightCurrentWord(paraText, para, audio.currentTime);
                        }
                    }
                }, 50); // Update every 50ms for smooth highlighting

                audio.onended = () => {
                    stopAudio();
                    button.textContent = '‚ñ∂ Play';
                };

                audio.ontimeupdate = () => {
                    // For uploaded files, don't stop at paragraph end - let it play continuously
                    if (!isUpload && audio.currentTime >= para.end) {
                        stopAudio();
                        button.textContent = '‚ñ∂ Play';
                    }
                };

                audio.onpause = () => {
                    if (currentPlayButton === button) {
                        button.textContent = '‚ñ∂ Play';
                    }
                };

                audio.onplay = () => {
                    if (currentPlayButton === button) {
                        button.textContent = '‚è∏ Pause';
                    }
                };

            } catch (error) {
                console.error('Audio playback error:', error);
                showToast('Failed to play audio', 'error');
                stopAudio();
                button.textContent = '‚ñ∂ Play';
            }
        }

        // Wrap words in spans with timing data
        function wrapWordsWithTimestamps(paraText, para) {
            // Build word-level timing map from segments
            const wordTimings = [];
            para.segments.forEach(segment => {
                const words = segment.text.trim().split(/\s+/);
                const segmentDuration = segment.end - segment.start;
                const avgWordDuration = segmentDuration / words.length;

                words.forEach((word, i) => {
                    const wordStart = segment.start + (i * avgWordDuration);
                    const wordEnd = wordStart + avgWordDuration;
                    wordTimings.push({
                        word: word,
                        start: wordStart,
                        end: wordEnd
                    });
                });
            });

            // Detect questions in the paragraph text
            const questionPatterns = [
                /\?$/,  // Ends with question mark
                /^(what|where|when|why|who|whom|which|whose|how)\b/i,
                /^(is|are|was|were|do|does|did|can|could|will|would|should|have|has|had)\b/i,
            ];

            const sentences = para.text.split(/(?<=[.!?])\s+/);
            const questionSentences = new Set();

            sentences.forEach(sentence => {
                const isQuestion = questionPatterns.some(pattern => pattern.test(sentence.trim())) ||
                                 sentence.includes('?');
                if (isQuestion) {
                    questionSentences.add(sentence.trim());
                }
            });

            // Build HTML with word spans, detecting question boundaries
            let html = '';
            let currentText = '';
            let wordIndex = 0;
            let inQuestion = false;
            let questionIndex = 0;  // Track question number for alternating colors

            wordTimings.forEach((wt, i) => {
                currentText += (currentText ? ' ' : '') + wt.word;

                // Check if we're starting a question
                let startQuestion = false;
                for (const qSentence of questionSentences) {
                    if (qSentence.startsWith(currentText.trim())) {
                        startQuestion = true;
                        break;
                    }
                }

                // Add word span
                const wordSpan = `<span class="word-highlight" data-word-index="${i}" data-word-start="${wt.start}" data-word-end="${wt.end}">${wt.word}</span>`;

                // If starting a question, add break and open question span with shade
                if (startQuestion && !inQuestion) {
                    const shade = (questionIndex % 4) + 1;
                    html += '<br><span class="question-highlight shade-' + shade + '">';
                    inQuestion = true;
                }

                html += wordSpan;

                // Check if question ends (contains ? or !)
                if (inQuestion && (wt.word.includes('?') || wt.word.includes('!'))) {
                    html += '</span><br>';
                    inQuestion = false;
                    currentText = '';
                    questionIndex++;
                }

                // Add space between words
                if (i < wordTimings.length - 1) {
                    html += ' ';
                }
            });

            // Close any unclosed question span
            if (inQuestion) {
                html += '</span>';
            }

            paraText.innerHTML = html;

            // Mark paragraph if it contains questions
            if (questionSentences.size > 0) {
                paraText.parentElement?.classList.add('question-paragraph');
            }
        }

        // Highlight the current word being spoken (for single paragraph)
        function highlightCurrentWord(paraText, para, currentTime) {
            const words = paraText.querySelectorAll('.word-highlight');
            words.forEach(word => {
                const start = parseFloat(word.dataset.wordStart);
                const end = parseFloat(word.dataset.wordEnd);

                if (currentTime >= start && currentTime < end) {
                    word.classList.add('playing');
                } else {
                    word.classList.remove('playing');
                }
            });
        }

        // Highlight the current word across all paragraphs (for uploaded files)
        function highlightCurrentWordGlobal(currentTime) {
            // Get all word elements across all paragraphs
            const allWords = document.querySelectorAll('.word-highlight');
            let foundWord = false;

            allWords.forEach(word => {
                const start = parseFloat(word.dataset.wordStart);
                const end = parseFloat(word.dataset.wordEnd);

                if (currentTime >= start && currentTime < end) {
                    word.classList.add('playing');
                    foundWord = true;

                    // Auto-scroll to keep highlighted word in view
                    if (!foundWord) {
                        word.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                } else {
                    word.classList.remove('playing');
                }
            });
        }

        // Get chunk URL
        async function getChunkUrl(chunkIndex) {
            if (audioCache.has(chunkIndex)) {
                return audioCache.get(chunkIndex);
            }

            const userId = getUserId();
            const sessionFolder = currentSession.folder;
            const metadata = currentSession.metadata || {};
            const isUpload = (currentSession.sessionId && currentSession.sessionId.includes('-upload-')) ||
                             metadata.source === 'upload';

            // For uploaded files, we need to find the actual file extension
            if (isUpload) {
                // Try to get extension from metadata
                let extension = 'webm'; // default
                if (metadata.originalFilename) {
                    const parts = metadata.originalFilename.split('.');
                    if (parts.length > 1) {
                        extension = parts[parts.length - 1];
                    }
                } else if (metadata.mimeType) {
                    // Map MIME type to extension
                    const mimeToExt = {
                        'audio/aac': 'aac',
                        'audio/x-m4a': 'm4a',
                        'audio/m4a': 'm4a',
                        'audio/mpeg': 'mp3',
                        'audio/mp3': 'mp3',
                        'audio/wav': 'wav',
                        'audio/x-wav': 'wav',
                        'audio/webm': 'webm'
                    };
                    extension = mimeToExt[metadata.mimeType] || 'webm';
                }

                const chunkKey = `users/${userId}/audio/sessions/${sessionFolder}/chunk-${String(chunkIndex).padStart(3, '0')}.${extension}`;
                console.log('Loading uploaded audio chunk:', chunkKey);

                try {
                    const downloadData = await apiCall(`/api/s3/download/${encodeURIComponent(chunkKey)}`);
                    audioCache.set(chunkIndex, downloadData.downloadUrl);
                    return downloadData.downloadUrl;
                } catch (error) {
                    console.error(`Failed to get URL for uploaded chunk ${chunkIndex} with extension ${extension}:`, error);
                    // Try fallback extensions
                    const fallbackExts = ['m4a', 'aac', 'mp3', 'wav', 'webm'];
                    for (const ext of fallbackExts) {
                        if (ext === extension) continue; // Already tried
                        try {
                            const fallbackKey = `users/${userId}/audio/sessions/${sessionFolder}/chunk-${String(chunkIndex).padStart(3, '0')}.${ext}`;
                            console.log('Trying fallback extension:', fallbackKey);
                            const downloadData = await apiCall(`/api/s3/download/${encodeURIComponent(fallbackKey)}`);
                            audioCache.set(chunkIndex, downloadData.downloadUrl);
                            return downloadData.downloadUrl;
                        } catch (fallbackError) {
                            // Continue to next extension
                        }
                    }
                    throw new Error(`Could not find audio file for chunk ${chunkIndex}`);
                }
            } else {
                // Live session - use .webm
                const chunkKey = `users/${userId}/audio/sessions/${sessionFolder}/chunk-${String(chunkIndex).padStart(3, '0')}.webm`;

                const downloadData = await apiCall(`/api/s3/download/${encodeURIComponent(chunkKey)}`);
                audioCache.set(chunkIndex, downloadData.downloadUrl);
                return downloadData.downloadUrl;
            }
        }

        // Toggle original text
        function toggleOriginal(index) {
            const originalDiv = document.getElementById(`original-${index}`);
            const toggle = event.target;

            if (originalDiv.classList.contains('show')) {
                originalDiv.classList.remove('show');
                toggle.textContent = 'Show Original';
            } else {
                originalDiv.classList.add('show');
                toggle.textContent = 'Hide Original';
            }
        }

        // Toggle edit mode
        let editModeEnabled = false;
        function toggleEditMode() {
            editModeEnabled = !editModeEnabled;
            const btn = document.getElementById('edit-mode-btn');
            const paragraphs = document.querySelectorAll('.paragraph-text');

            // Toggle editing buttons
            const editButtons = ['undo-btn', 'redo-btn', 'bold-btn', 'italic-btn', 'underline-btn'];
            editButtons.forEach(id => {
                document.getElementById(id).disabled = !editModeEnabled;
            });

            if (editModeEnabled) {
                btn.textContent = '‚úèÔ∏è Edit Mode: ON';
                btn.classList.add('active');
                paragraphs.forEach(p => p.contentEditable = true);
                showToast('Edit mode enabled - you can now edit paragraphs');
            } else {
                btn.textContent = '‚úèÔ∏è Edit Mode: OFF';
                btn.classList.remove('active');
                paragraphs.forEach(p => p.contentEditable = false);
                showToast('Edit mode disabled - you can now select and copy text');
            }
        }

        // Mark paragraph as edited
        function markEdited(index) {
            const textDiv = document.querySelector(`[data-para-index="${index}"]`);
            textDiv.classList.add('edited');

            const para = processedData.paragraphs[index];
            para.text = textDiv.textContent;
            para.edited = true;
        }

        // Show chunk details
        function showChunkDetails(chunkId, paraIndex) {
            const para = processedData.paragraphs[paraIndex];
            const chunkSegments = para.segments.filter(s => s.chunkId === chunkId);

            const modalBody = document.getElementById('modal-body');
            modalBody.innerHTML = `
                <p><strong>Chunk:</strong> ${chunkId}</p>
                <p><strong>Segments in this paragraph:</strong> ${chunkSegments.length}</p>
                <div style="margin-top: 16px;">
                    <h3 style="font-size: 14px; font-weight: 600; margin-bottom: 8px;">Original Segments:</h3>
                    ${chunkSegments.map(s => `<p style="margin: 8px 0; padding: 8px; background: var(--gray-50); border-radius: 4px;">${s.text}</p>`).join('')}
                </div>
            `;

            document.getElementById('modal-title').textContent = `Chunk Details: ${chunkId}`;
            document.getElementById('plugin-modal').classList.add('show');
        }

        // Quick search
        function quickSearch(query) {
            if (!query) {
                document.querySelectorAll('.paragraph-text').forEach(el => {
                    el.style.background = '';
                });
                return;
            }

            const lowerQuery = query.toLowerCase();
            document.querySelectorAll('.paragraph-text').forEach(el => {
                const text = el.textContent.toLowerCase();
                if (text.includes(lowerQuery)) {
                    el.style.background = '#fef3c7';
                } else {
                    el.style.background = '';
                }
            });
        }

        // Copy all text
        function copyAllText() {
            const allText = processedData.paragraphs.map(p => p.text).join('\n\n');
            navigator.clipboard.writeText(allText).then(() => {
                showToast('Copied all text to clipboard');
            }).catch(err => {
                showToast('Failed to copy text', 'error');
            });
        }

        // Toggle download menu
        function toggleDownloadMenu() {
            const menu = document.getElementById('download-menu');
            menu.classList.toggle('show');

            // Close dropdown when clicking outside
            if (menu.classList.contains('show')) {
                setTimeout(() => {
                    document.addEventListener('click', closeDropdownOnOutsideClick);
                }, 0);
            }
        }

        // Close dropdown when clicking outside
        function closeDropdownOnOutsideClick(e) {
            const menu = document.getElementById('download-menu');
            const dropdown = menu.closest('.dropdown');

            if (!dropdown.contains(e.target)) {
                menu.classList.remove('show');
                document.removeEventListener('click', closeDropdownOnOutsideClick);
            }
        }

        // Copy as markdown
        function copyAsMarkdown() {
            const markdown = generateMarkdown();
            navigator.clipboard.writeText(markdown).then(() => {
                showToast('‚úÖ Copied as Markdown! Paste into Claude Code', 'success');
            }).catch(err => {
                console.error('Copy failed:', err);
                showToast('Failed to copy markdown', 'error');
            });
        }

        // Download transcript in various formats
        function downloadTranscript(format) {
            // Close dropdown
            document.getElementById('download-menu').classList.remove('show');

            let content, mimeType, extension;
            const sessionName = formatSessionName(currentSession.folder, selectedTimezone)
                .replace(/[^a-zA-Z0-9-]/g, '-')
                .toLowerCase();

            switch (format) {
                case 'markdown':
                    content = generateMarkdown();
                    mimeType = 'text/markdown';
                    extension = 'md';
                    break;

                case 'text':
                    content = generatePlainText();
                    mimeType = 'text/plain';
                    extension = 'txt';
                    break;

                case 'json':
                    content = JSON.stringify(processedData, null, 2);
                    mimeType = 'application/json';
                    extension = 'json';
                    break;
            }

            // Create download
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `transcript-${sessionName}.${extension}`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showToast(`‚úÖ Downloaded as ${extension.toUpperCase()}`, 'success');
        }

        // Generate markdown format
        function generateMarkdown() {
            const sessionDate = formatSessionName(currentSession.folder, selectedTimezone);
            const stats = processedData.stats;

            let markdown = `# Transcript: ${sessionDate}\n\n`;
            markdown += `**Duration:** ${formatDuration(stats.totalDuration)} | `;
            markdown += `**Words:** ${stats.totalWords} | `;
            markdown += `**WPM:** ${Math.round(stats.wordsPerMinute)}\n\n`;
            markdown += `---\n\n`;

            processedData.paragraphs.forEach((para, index) => {
                markdown += `## [${formatTime(para.start)}]\n\n`;
                markdown += `${para.text}\n\n`;
            });

            markdown += `---\n\n`;
            markdown += `*Transcribed with CloudDrive Transcription*\n`;

            return markdown;
        }

        // Generate plain text format
        function generatePlainText() {
            const sessionDate = formatSessionName(currentSession.folder, selectedTimezone);
            const stats = processedData.stats;

            let text = `Transcript: ${sessionDate}\n`;
            text += `Duration: ${formatDuration(stats.totalDuration)} | `;
            text += `Words: ${stats.totalWords} | `;
            text += `WPM: ${Math.round(stats.wordsPerMinute)}\n`;
            text += `${'='.repeat(60)}\n\n`;

            processedData.paragraphs.forEach((para, index) => {
                text += `[${formatTime(para.start)}]\n`;
                text += `${para.text}\n\n`;
            });

            text += `${'='.repeat(60)}\n`;
            text += `Transcribed with CloudDrive Transcription\n`;

            return text;
        }

        // Save transcript
        async function saveTranscript() {
            try {
                const userId = getUserId();
                const sessionFolder = currentSession.folder;

                // Save processed data
                const blob = new Blob([JSON.stringify(processedData, null, 2)], { type: 'application/json' });

                const uploadData = await apiCall('/api/s3/upload', {
                    method: 'POST',
                    body: JSON.stringify({
                        fileName: `audio/sessions/${sessionFolder}/transcript-processed.json`,
                        contentType: 'application/json',
                        fileSize: blob.size
                    })
                });

                await fetch(uploadData.uploadUrl, {
                    method: 'PUT',
                    body: blob,
                    headers: { 'Content-Type': 'application/json' }
                });

                showToast('Transcript saved successfully!');
            } catch (error) {
                console.error('Error saving:', error);
                showToast('Failed to save transcript', 'error');
            }
        }

        // UI Plugin Manager (extends base plugin manager)
        class UIPluginManager extends TranscriptPluginManager {
            constructor() {
                super();
            }

            showSearchDialog() {
                const modalBody = document.getElementById('modal-body');
                modalBody.innerHTML = `
                    <input type="text" id="search-query" class="search-input" placeholder="Enter search term..." style="width: 100%; margin-bottom: 12px;">
                    <label style="display: block; margin-bottom: 12px;">
                        <input type="checkbox" id="search-case"> Case sensitive
                    </label>
                    <label style="display: block; margin-bottom: 16px;">
                        <input type="checkbox" id="search-regex"> Regular expression
                    </label>
                    <button class="btn btn-primary" onclick="pluginManager.executeSearch()">Search</button>
                `;

                document.getElementById('modal-title').textContent = 'Search Transcript';
                document.getElementById('plugin-modal').classList.add('show');
            }

            async executeSearch() {
                const query = document.getElementById('search-query').value;
                const caseSensitive = document.getElementById('search-case').checked;
                const regex = document.getElementById('search-regex').checked;

                const results = await this.execute('search', {
                    paragraphs: processedData.paragraphs,
                    query,
                    options: { caseSensitive, regex }
                });

                // Highlight results
                results.results.forEach(r => {
                    const paraDiv = document.querySelector(`[data-para-index="${r.paragraphIndex}"]`);
                    if (paraDiv) {
                        paraDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        paraDiv.style.background = '#fef3c7';
                        setTimeout(() => { paraDiv.style.background = ''; }, 3000);
                    }
                });

                closeModal();
                showToast(`Found ${results.totalMatches} matches`);
            }

            showReplaceDialog() {
                const modalBody = document.getElementById('modal-body');
                modalBody.innerHTML = `
                    <input type="text" id="replace-find" class="search-input" placeholder="Find..." style="width: 100%; margin-bottom: 12px;">
                    <input type="text" id="replace-with" class="search-input" placeholder="Replace with..." style="width: 100%; margin-bottom: 12px;">
                    <label style="display: block; margin-bottom: 16px;">
                        <input type="checkbox" id="replace-all" checked> Replace all
                    </label>
                    <button class="btn btn-primary" onclick="pluginManager.executeReplace()">Replace</button>
                `;

                document.getElementById('modal-title').textContent = 'Find & Replace';
                document.getElementById('plugin-modal').classList.add('show');
            }

            async executeReplace() {
                const find = document.getElementById('replace-find').value;
                const replace = document.getElementById('replace-with').value;
                const replaceAll = document.getElementById('replace-all').checked;

                const results = await this.execute('replace', {
                    paragraphs: processedData.paragraphs,
                    find,
                    replace,
                    options: { replaceAll }
                });

                renderEditor();
                closeModal();
                showToast(`Replaced ${results.modifiedCount} occurrences`);
            }

            showHighlightDialog() {
                const modalBody = document.getElementById('modal-body');
                modalBody.innerHTML = `
                    <input type="text" id="highlight-keywords" class="search-input" placeholder="Enter keywords (comma separated)" style="width: 100%; margin-bottom: 16px;">
                    <button class="btn btn-primary" onclick="pluginManager.executeHighlight()">Highlight</button>
                `;

                document.getElementById('modal-title').textContent = 'Highlight Keywords';
                document.getElementById('plugin-modal').classList.add('show');
            }

            async executeHighlight() {
                const keywords = document.getElementById('highlight-keywords').value.split(',').map(k => k.trim());

                const results = await this.execute('highlight', {
                    paragraphs: processedData.paragraphs,
                    keywords
                });

                renderEditor();
                closeModal();
                showToast(`Highlighted ${results.highlightCount} instances`);
            }

            async extractActions() {
                const results = await this.execute('extract-actions', {
                    paragraphs: processedData.paragraphs
                });

                const modalBody = document.getElementById('modal-body');
                modalBody.innerHTML = `
                    <p><strong>Found ${results.actionCount} action items:</strong></p>
                    <div style="margin-top: 16px;">
                        ${results.actions.map(a => `
                            <div style="margin: 12px 0; padding: 12px; background: var(--gray-50); border-left: 3px solid var(--primary); border-radius: 4px;">
                                <p style="font-weight: 600;">${a.text}</p>
                                <p style="font-size: 12px; color: var(--gray-600); margin-top: 4px;">
                                    Time: ${formatTime(a.timestamp)} | Paragraph ${a.paragraphIndex + 1}
                                </p>
                            </div>
                        `).join('')}
                    </div>
                `;

                document.getElementById('modal-title').textContent = 'Action Items';
                document.getElementById('plugin-modal').classList.add('show');
            }

            async showWordFrequency() {
                const results = await this.execute('word-frequency', {
                    paragraphs: processedData.paragraphs,
                    minLength: 4,
                    excludeCommon: true
                });

                const modalBody = document.getElementById('modal-body');
                modalBody.innerHTML = `
                    <p><strong>Top 20 words:</strong></p>
                    <div style="margin-top: 16px;">
                        ${results.topWords.slice(0, 20).map((w, i) => `
                            <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: var(--gray-50); margin: 4px 0; border-radius: 4px;">
                                <span><strong>${i + 1}.</strong> ${w.word}</span>
                                <span style="background: var(--primary); color: white; padding: 2px 8px; border-radius: 4px; font-weight: 600;">${w.count}</span>
                            </div>
                        `).join('')}
                    </div>
                `;

                document.getElementById('modal-title').textContent = 'Word Frequency';
                document.getElementById('plugin-modal').classList.add('show');
            }

            async export(format) {
                const results = await this.execute('export', {
                    paragraphs: processedData.paragraphs,
                    format
                });

                const blob = new Blob([results.content], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `transcript-${currentSession.folder}.${format === 'plain' ? 'txt' : format}`;
                a.click();
                URL.revokeObjectURL(url);

                showToast(`Exported as ${format.toUpperCase()}`);
            }
        }

        // Utility functions
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function formatDuration(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function closeModal() {
            document.getElementById('plugin-modal').classList.remove('show');
        }

        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast ${type} show`;

            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        // Close modal on outside click
        document.getElementById('plugin-modal').addEventListener('click', (e) => {
            if (e.target.id === 'plugin-modal') {
                closeModal();
            }
        });

        // ====================================================================
        // AI Timeline Navigator
        // ====================================================================

        class AITimelineNavigator {
            constructor() {
                this.aiAnalysis = null;
                this.activeFilter = 'all';
                this.totalDuration = 0;
                this.detectedQuestions = null;
                this.colorMap = {
                    highlights: '#8b5cf6',
                    questions: '#ec4899',
                    actionItems: '#ef4444',
                    keyTerms: '#3b82f6',
                    keyThemes: '#f59e0b',
                    topicChanges: '#10b981'
                };
            }

            reset() {
                // Reset all state when switching sessions
                this.aiAnalysis = null;
                this.activeFilter = 'all';
                this.totalDuration = 0;
                this.detectedQuestions = null;

                // Hide the AI navigation container
                const container = document.getElementById('ai-nav-container');
                if (container) {
                    container.style.display = 'none';
                }

                // Clear timeline markers
                const track = document.getElementById('timeline-track');
                if (track) {
                    track.innerHTML = '';
                }

                // Reset all count badges to 0
                ['all', 'highlights', 'questions', 'actionItems', 'keyTerms', 'keyThemes', 'topicChanges'].forEach(type => {
                    const badge = document.getElementById(`count-${type}`);
                    if (badge) badge.textContent = '0';
                });

                // Reset active tab to "all"
                document.querySelectorAll('.ai-nav-tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                const allTab = document.querySelector('.ai-nav-tab[data-type="all"]');
                if (allTab) {
                    allTab.classList.add('active');
                }
            }

            async loadAnalysis() {
                if (!currentSession) return false;

                const userId = getUserId();
                const sessionFolder = currentSession.folder;
                const sessionPath = `users/${userId}/audio/sessions/${sessionFolder}`;

                try {
                    // Try to load AI analysis
                    const analysisKey = `${sessionPath}/transcription-ai-analysis.json`;
                    const downloadData = await apiCall(`/api/s3/download/${encodeURIComponent(analysisKey)}`);
                    const response = await fetch(downloadData.downloadUrl);

                    if (response.ok) {
                        this.aiAnalysis = await response.json();
                        console.log('‚úÖ AI analysis loaded:', this.aiAnalysis);
                        return true;
                    }
                } catch (error) {
                    console.log('No AI analysis available for this session');
                    return false;
                }

                return false;
            }

            detectQuestions() {
                // Detect all questions in the transcript
                if (!processedData || !processedData.paragraphs) return [];

                const questions = [];
                const questionPatterns = [
                    /\?$/,  // Ends with question mark
                    /^(what|where|when|why|who|whom|which|whose|how)\b/i,  // Question words at start
                    /^(is|are|was|were|do|does|did|can|could|will|would|should|have|has|had)\b/i,  // Auxiliary verbs at start
                ];

                processedData.paragraphs.forEach((para, index) => {
                    const text = para.text.trim();
                    const paraDuration = para.end - para.start;

                    // Check if paragraph contains questions
                    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);

                    // Calculate approximate position of each sentence within the paragraph
                    let charsSoFar = 0;
                    const totalChars = text.length;

                    sentences.forEach(sentence => {
                        sentence = sentence.trim();

                        // Check if it's a question
                        const isQuestion = questionPatterns.some(pattern => pattern.test(sentence)) ||
                                         sentence.includes('?');

                        if (isQuestion) {
                            // Estimate time position based on character position in paragraph
                            const sentencePosition = charsSoFar / totalChars;
                            const estimatedTime = para.start + (paraDuration * sentencePosition);

                            questions.push({
                                timeCode: estimatedTime,  // Estimated position within paragraph
                                text: sentence,
                                summary: sentence.length > 100 ? sentence.substring(0, 97) + '...' : sentence,
                                paragraphIndex: index,
                                type: 'questions'
                            });
                        }

                        // Update character count for next sentence
                        charsSoFar += sentence.length + 1; // +1 for the delimiter
                    });
                });

                this.detectedQuestions = questions;
                return questions;
            }

            render() {
                if (!this.aiAnalysis || !processedData) {
                    // Hide AI navigation if no analysis
                    document.getElementById('ai-nav-container').style.display = 'none';
                    return;
                }

                // Show AI navigation
                document.getElementById('ai-nav-container').style.display = 'block';

                this.totalDuration = processedData.stats.totalDuration;

                // Detect questions from transcript
                this.detectQuestions();

                // Update duration labels
                document.getElementById('timeline-duration').textContent = formatDuration(this.totalDuration);
                document.getElementById('timeline-end-label').textContent = formatDuration(this.totalDuration);

                // Update count badges
                this.updateCounts();

                // Render markers
                this.renderMarkers();
            }

            updateCounts() {
                const counts = {
                    highlights: this.aiAnalysis.highlights?.length || 0,
                    questions: this.detectedQuestions?.length || 0,
                    actionItems: this.aiAnalysis.actionItems?.length || 0,
                    keyTerms: this.aiAnalysis.keyTerms?.length || 0,
                    keyThemes: this.aiAnalysis.keyThemes?.length || 0,
                    topicChanges: this.aiAnalysis.topicChanges?.length || 0
                };

                counts.all = Object.values(counts).reduce((a, b) => a + b, 0);

                Object.keys(counts).forEach(type => {
                    const badge = document.getElementById(`count-${type}`);
                    if (badge) badge.textContent = counts[type];
                });
            }

            filterByType(type) {
                console.log('üéØ filterByType called with:', type);
                this.activeFilter = type;

                // Update active tab
                document.querySelectorAll('.ai-nav-tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                document.querySelector(`.ai-nav-tab[data-type="${type}"]`).classList.add('active');

                // Show configuration panel for this category (if not "all")
                console.log('üîç Checking if should show config:', {
                    type,
                    isNotAll: type !== 'all',
                    hasConfigPanel: !!window.aiConfigPanel,
                    aiConfigPanel: window.aiConfigPanel
                });

                if (type !== 'all' && window.aiConfigPanel) {
                    console.log('‚úÖ Calling aiConfigPanel.showCategory()');
                    aiConfigPanel.showCategory(type);
                } else {
                    console.log('‚ùå NOT calling showCategory. Reasons:', {
                        isAll: type === 'all',
                        noConfigPanel: !window.aiConfigPanel
                    });
                }

                // Re-render markers
                this.renderMarkers();
            }

            renderMarkers() {
                const track = document.getElementById('timeline-track');
                track.innerHTML = '';

                const items = this.getFilteredItems();

                items.forEach(item => {
                    const marker = this.createMarker(item);
                    track.appendChild(marker);
                });
            }

            getFilteredItems() {
                if (!this.aiAnalysis) return [];

                let items = [];

                if (this.activeFilter === 'all') {
                    // Include all types
                    ['highlights', 'questions', 'actionItems', 'keyTerms', 'keyThemes', 'topicChanges'].forEach(type => {
                        if (type === 'questions' && this.detectedQuestions) {
                            items.push(...this.detectedQuestions);
                        } else if (this.aiAnalysis[type]) {
                            items.push(...this.aiAnalysis[type].map(item => ({ ...item, type })));
                        }
                    });
                } else if (this.activeFilter === 'questions') {
                    // Show detected questions
                    if (this.detectedQuestions) {
                        items = this.detectedQuestions;
                    }
                } else {
                    // Only include selected type from AI analysis
                    if (this.aiAnalysis[this.activeFilter]) {
                        items = this.aiAnalysis[this.activeFilter].map(item => ({ ...item, type: this.activeFilter }));
                    }
                }

                return items;
            }

            createMarker(item) {
                const marker = document.createElement('div');
                marker.className = 'timeline-marker';

                const startTime = item.timeCodeStart || item.timeCode || 0;
                const endTime = item.timeCodeEnd || startTime;

                // Position marker
                const leftPercent = (startTime / this.totalDuration) * 100;
                marker.style.left = `${leftPercent}%`;

                // Color by type
                marker.style.backgroundColor = this.colorMap[item.type] || '#666';

                // Segments vs points
                if (endTime > startTime) {
                    // Segment (like themes)
                    const widthPercent = ((endTime - startTime) / this.totalDuration) * 100;
                    marker.style.width = `${Math.max(widthPercent, 0.5)}%`;
                    marker.classList.add('segment');
                } else {
                    // Point marker
                    marker.style.width = '4px';
                }

                // Tooltip data
                marker.dataset.time = startTime;
                marker.dataset.summary = item.summary || item.text || item.term || item.theme || 'No description';

                // Click to jump
                marker.onclick = () => this.jumpToTime(startTime, item);

                // Hover tooltip
                marker.onmouseenter = (e) => this.showTooltip(e, item, startTime);
                marker.onmouseleave = () => this.hideTooltip();

                return marker;
            }

            jumpToTime(timeCode, item) {
                let paraIndex;

                // For questions, use the stored paragraph index directly
                if (item.type === 'questions' && item.paragraphIndex !== undefined) {
                    paraIndex = item.paragraphIndex;
                } else {
                    // Find paragraph that contains this time
                    const paragraph = processedData.paragraphs.find(p =>
                        timeCode >= p.start && timeCode <= p.end
                    );

                    if (!paragraph) return;
                    paraIndex = processedData.paragraphs.indexOf(paragraph);
                }

                const paraEl = document.querySelector(`#para-${paraIndex}`);

                if (paraEl) {
                    const textEl = paraEl.querySelector('.paragraph-text');

                    // Get the search text based on item type
                    const searchText = item.text || item.term || null;

                    // For items with specific text (questions, action items, key terms), search for it
                    if (searchText) {
                        // First scroll to paragraph
                        paraEl.scrollIntoView({ behavior: 'smooth', block: 'start' });

                        // Use browser's find-in-page API to search and highlight
                        setTimeout(() => {
                            // Create a temporary range to find the text
                            const textContent = textEl.textContent;
                            const searchIndex = textContent.indexOf(searchText);

                            if (searchIndex !== -1) {
                                // Use window.find() if available (works in most browsers)
                                if (window.find) {
                                    window.find(searchText);
                                }

                                // Alternative: Create a text highlight using range
                                const range = document.createRange();
                                const walker = document.createTreeWalker(
                                    textEl,
                                    NodeFilter.SHOW_TEXT,
                                    null,
                                    false
                                );

                                let charCount = 0;
                                let startNode = null;
                                let startOffset = 0;
                                let endNode = null;
                                let endOffset = 0;

                                while (walker.nextNode()) {
                                    const node = walker.currentNode;
                                    const nodeLength = node.textContent.length;

                                    if (charCount + nodeLength >= searchIndex && !startNode) {
                                        startNode = node;
                                        startOffset = searchIndex - charCount;
                                    }

                                    if (charCount + nodeLength >= searchIndex + searchText.length) {
                                        endNode = node;
                                        endOffset = searchIndex + searchText.length - charCount;
                                        break;
                                    }

                                    charCount += nodeLength;
                                }

                                if (startNode && endNode) {
                                    range.setStart(startNode, startOffset);
                                    range.setEnd(endNode, endOffset);

                                    // Scroll the range into view
                                    const rect = range.getBoundingClientRect();
                                    const scrollTop = window.scrollY + rect.top - (window.innerHeight / 2);
                                    window.scrollTo({ top: scrollTop, behavior: 'smooth' });

                                    // Create temporary highlight
                                    const span = document.createElement('span');
                                    span.style.backgroundColor = '#fbbf24';
                                    span.style.transition = 'background-color 0.3s';
                                    range.surroundContents(span);

                                    setTimeout(() => {
                                        span.style.backgroundColor = '';
                                        setTimeout(() => {
                                            // Unwrap the span
                                            const parent = span.parentNode;
                                            while (span.firstChild) {
                                                parent.insertBefore(span.firstChild, span);
                                            }
                                            parent.removeChild(span);
                                        }, 300);
                                    }, 2000);
                                }
                            } else {
                                // Text not found, just highlight paragraph
                                textEl.classList.add('ai-highlighted');
                                setTimeout(() => textEl.classList.remove('ai-highlighted'), 2000);
                            }
                        }, 300);
                    } else {
                        // For items without specific text, just scroll to paragraph and highlight
                        paraEl.scrollIntoView({ behavior: 'smooth', block: 'center' });

                        textEl.classList.add('ai-highlighted');
                        setTimeout(() => textEl.classList.remove('ai-highlighted'), 2000);
                    }

                    // If audio is playing, seek to time
                    if (currentAudio) {
                        currentAudio.currentTime = timeCode;
                    }
                }
            }

            showTooltip(event, item, timeCode) {
                const tooltip = document.getElementById('timeline-tooltip');
                const timeEl = document.getElementById('tooltip-time');
                const summaryEl = document.getElementById('tooltip-summary');

                timeEl.textContent = formatTime(timeCode);
                summaryEl.textContent = item.summary || item.text || item.term || item.theme || item.toTopic || 'No description';

                // Position tooltip
                const rect = event.target.getBoundingClientRect();
                tooltip.style.left = `${rect.left}px`;
                tooltip.style.top = `${rect.top - 80}px`;

                tooltip.classList.add('show');
            }

            hideTooltip() {
                const tooltip = document.getElementById('timeline-tooltip');
                tooltip.classList.remove('show');
            }
        }

        // Initialize AI Navigator
        let aiNavigator = new AITimelineNavigator();

        // ====================================================================
        // AI Configuration Panel
        // ====================================================================

        class PromptEditor {
            constructor() {
                this.isExpanded = false;
            }

            toggleExpand() {
                const textarea = document.getElementById('category-prompt');
                const button = document.querySelector('.expand-button');

                if (!this.isExpanded) {
                    textarea.style.height = '300px';
                    button.textContent = '‚ñ≤ Collapse';
                    this.isExpanded = true;
                } else {
                    textarea.style.height = '80px';
                    button.textContent = '‚ñº Expand';
                    this.isExpanded = false;
                }
            }
        }

        class AIConfigPanel {
            constructor() {
                this.currentCategory = null;
                this.config = null;
                this.defaultPrompts = null;
                this.isDirty = false;
                this.originalValues = {};
            }

            async init() {
                await this.loadDefaultPrompts();
                this.attachEventListeners();
            }

            async loadDefaultPrompts() {
                try {
                    const response = await fetch('/ai-prompts.json');
                    if (response.ok) {
                        this.defaultPrompts = await response.json();
                        console.log('‚úÖ Loaded default AI prompts');
                    }
                } catch (error) {
                    console.error('Error loading default prompts:', error);
                }
            }

            async loadConfig() {
                // Try to load existing AI analysis to get metadata
                const userId = getUserId();
                const sessionFolder = currentSession.folder;
                const sessionPath = `users/${userId}/audio/sessions/${sessionFolder}`;
                const analysisKey = `${sessionPath}/transcription-ai-analysis.json`;

                try {
                    const downloadData = await apiCall(`/api/s3/download/${encodeURIComponent(analysisKey)}`);
                    const response = await fetch(downloadData.downloadUrl);

                    if (response.ok) {
                        const analysis = await response.json();
                        // Extract metadata from analysis
                        this.config = {
                            version: "2.0",
                            sessionId: currentSession.folder,
                            lastModified: analysis._meta?.lastModified || new Date().toISOString(),
                            categories: this.buildConfigFromDefaults(),
                            _meta: analysis._meta || {}
                        };

                        // Update metadata if available
                        if (analysis._meta) {
                            Object.keys(this.config.categories).forEach(cat => {
                                if (analysis[cat]) {
                                    this.config.categories[cat].metadata.itemCount = analysis[cat].length;
                                }
                            });
                        }

                        return;
                    }
                } catch (error) {
                    console.log('No AI analysis found, using defaults');
                }

                // Initialize with defaults
                this.config = {
                    version: "2.0",
                    sessionId: currentSession?.folder || '',
                    lastModified: new Date().toISOString(),
                    categories: this.buildConfigFromDefaults(),
                    _meta: {
                        totalCost: 0,
                        totalTokens: 0
                    }
                };
            }

            buildConfigFromDefaults() {
                const categories = {};

                if (this.defaultPrompts?.templates) {
                    Object.keys(this.defaultPrompts.templates).forEach(category => {
                        const template = this.defaultPrompts.templates[category];
                        categories[category] = {
                            displayName: template.displayName,
                            enabled: true,
                            prompt: template.prompt,
                            settings: {
                                model: "claude-3-5-haiku-20241022",
                                maxTokens: 8000,
                                ...template.settings
                            },
                            metadata: {
                                lastAnalyzed: null,
                                itemCount: 0,
                                tokensUsed: 0,
                                costUSD: 0
                            }
                        };
                    });
                }

                return categories;
            }

            async showCategory(categoryId) {
                console.log('üîß AIConfigPanel.showCategory called with:', categoryId);
                this.currentCategory = categoryId;

                // Load config if not loaded
                if (!this.config) {
                    console.log('üì• Loading config...');
                    await this.loadConfig();
                }

                // Transition: hide session info, show config panel
                const sessionInfo = document.getElementById('session-info');
                const configPanel = document.getElementById('ai-config-panel');

                console.log('üîÑ Transitioning panels:', {
                    sessionInfo: !!sessionInfo,
                    configPanel: !!configPanel,
                    sessionInfoDisplay: sessionInfo?.style.display,
                    configPanelDisplay: configPanel?.style.display
                });

                if (!sessionInfo || !configPanel) {
                    console.error('‚ùå Panel elements not found!');
                    return;
                }

                sessionInfo.style.display = 'none';
                configPanel.style.display = 'block';

                console.log('‚úÖ Panels transitioned, rendering...');
                this.render();
                console.log('‚úÖ Render complete');
            }

            close() {
                // Transition: show session info, hide config panel
                const sessionInfo = document.getElementById('session-info');
                const configPanel = document.getElementById('ai-config-panel');

                // Warn if unsaved changes
                if (this.isDirty) {
                    if (!confirm('You have unsaved changes. Close anyway?')) {
                        return;
                    }
                    this.isDirty = false;
                }

                configPanel.style.display = 'none';
                sessionInfo.style.display = 'block';

                this.currentCategory = null;
            }

            render() {
                if (!this.currentCategory || !this.config) return;

                const categoryConfig = this.config.categories[this.currentCategory];
                if (!categoryConfig) return;

                // Update category name input
                document.getElementById('category-name').value = categoryConfig.displayName;

                // Update prompt editor
                document.getElementById('category-prompt').value = categoryConfig.prompt;

                // Update settings
                document.getElementById('setting-model').value = categoryConfig.settings.model;
                document.getElementById('setting-max-items').value = categoryConfig.settings.maxItems || 15;

                // Render category-specific settings
                this.renderCategorySpecificSettings(this.currentCategory, categoryConfig.settings);

                // Update status
                const metadata = categoryConfig.metadata;
                document.getElementById('last-analyzed-time').textContent =
                    metadata.lastAnalyzed ? this.formatRelativeTime(metadata.lastAnalyzed) : 'Never';
                document.getElementById('estimated-cost').textContent =
                    `$${(metadata.costUSD || 0).toFixed(4)}`;
                document.getElementById('current-count').textContent =
                    `${metadata.itemCount || 0} items`;

                // Store original values for dirty detection
                this.originalValues = {
                    displayName: categoryConfig.displayName,
                    prompt: categoryConfig.prompt,
                    settings: JSON.stringify(categoryConfig.settings)
                };

                this.isDirty = false;
                this.updateSaveButton();
            }

            renderCategorySpecificSettings(category, settings) {
                const container = document.getElementById('category-specific-settings');
                container.innerHTML = '';

                // Render settings specific to each category
                switch(category) {
                    case 'highlights':
                        container.innerHTML = `
                            <div class="setting-item">
                                <label for="setting-min-importance">Min Importance:</label>
                                <input type="number" id="setting-min-importance"
                                       min="0" max="1" step="0.1"
                                       value="${settings.minImportance || 0.7}">
                            </div>
                        `;
                        break;
                    case 'actionItems':
                        container.innerHTML = `
                            <div class="setting-item">
                                <label for="setting-min-priority">Min Priority:</label>
                                <select id="setting-min-priority">
                                    <option value="low" ${settings.minPriority === 'low' ? 'selected' : ''}>Low</option>
                                    <option value="medium" ${settings.minPriority === 'medium' ? 'selected' : ''}>Medium</option>
                                    <option value="high" ${settings.minPriority === 'high' ? 'selected' : ''}>High</option>
                                </select>
                            </div>
                        `;
                        break;
                    case 'keyTerms':
                        container.innerHTML = `
                            <div class="setting-item">
                                <label for="setting-first-mention-only">
                                    <input type="checkbox" id="setting-first-mention-only"
                                           ${settings.firstMentionOnly !== false ? 'checked' : ''}>
                                    First Mention Only
                                </label>
                            </div>
                        `;
                        break;
                    case 'keyThemes':
                        container.innerHTML = `
                            <div class="setting-item">
                                <label for="setting-min-intensity">Min Intensity:</label>
                                <input type="number" id="setting-min-intensity"
                                       min="0" max="1" step="0.1"
                                       value="${settings.minIntensity || 0.5}">
                            </div>
                            <div class="setting-item">
                                <label for="setting-min-duration">Min Duration (sec):</label>
                                <input type="number" id="setting-min-duration"
                                       min="0" step="5"
                                       value="${settings.minDuration || 30}">
                            </div>
                        `;
                        break;
                    case 'topicChanges':
                        container.innerHTML = `
                            <div class="setting-item">
                                <label for="setting-include-implicit">
                                    <input type="checkbox" id="setting-include-implicit"
                                           ${settings.includeImplicit !== false ? 'checked' : ''}>
                                    Include Implicit Transitions
                                </label>
                            </div>
                        `;
                        break;
                }
            }

            attachEventListeners() {
                // Detect changes to mark dirty
                const inputs = ['category-name', 'category-prompt', 'setting-model', 'setting-max-items'];

                inputs.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {
                        el.addEventListener('input', () => this.markDirty());
                        el.addEventListener('change', () => this.markDirty());
                    }
                });

                // Use event delegation for dynamically added category-specific settings
                document.addEventListener('change', (e) => {
                    if (e.target.id.startsWith('setting-')) {
                        this.markDirty();
                    }
                });
            }

            markDirty() {
                this.isDirty = true;
                this.updateSaveButton();

                // Add visual indicator to prompt
                const promptEditor = document.getElementById('category-prompt');
                if (promptEditor) {
                    promptEditor.classList.add('dirty');
                }
            }

            updateSaveButton() {
                const saveBtn = document.querySelector('.btn-save');
                if (saveBtn) {
                    if (this.isDirty) {
                        saveBtn.disabled = false;
                        saveBtn.classList.add('dirty');
                    } else {
                        saveBtn.disabled = true;
                        saveBtn.classList.remove('dirty');
                    }
                }
            }

            async saveConfig() {
                if (!this.currentCategory) return;

                showToast('Save functionality coming in Phase 3 - backend API', 'info');
                console.log('Config to save:', this.config);

                // TODO: Implement S3 upload in Phase 3
                this.isDirty = false;
                this.updateSaveButton();
            }

            async reanalyzeCategory() {
                if (!this.currentCategory) return;

                showToast('Re-analysis functionality coming in Phase 3 - backend API', 'info');
                console.log('Re-analyze category:', this.currentCategory);

                // TODO: Implement backend API call in Phase 3
            }

            resetToDefault() {
                if (!this.currentCategory || !this.defaultPrompts) return;

                if (!confirm('Reset this category to default settings?')) {
                    return;
                }

                const template = this.defaultPrompts.templates[this.currentCategory];
                if (template) {
                    const categoryConfig = this.config.categories[this.currentCategory];
                    categoryConfig.displayName = template.displayName;
                    categoryConfig.prompt = template.prompt;
                    categoryConfig.settings = {
                        model: "claude-3-5-haiku-20241022",
                        maxTokens: 8000,
                        ...template.settings
                    };

                    this.render();
                    this.markDirty();
                }
            }

            formatRelativeTime(isoString) {
                const date = new Date(isoString);
                const now = new Date();
                const seconds = Math.floor((now - date) / 1000);

                if (seconds < 60) return 'Just now';
                if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
                if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
                return `${Math.floor(seconds / 86400)}d ago`;
            }
        }

        // Initialize AI Config Panel and Prompt Editor
        // Make them global so they can be accessed from onclick handlers
        window.aiConfigPanel = new AIConfigPanel();
        window.promptEditor = new PromptEditor();

        // Initialize config panel when page loads
        aiConfigPanel.init();

        // Add scroll effect to AI navigation
        let lastScrollTop = 0;

        // Listen on window scroll or main content wrapper scroll
        window.addEventListener('scroll', function() {
            const aiNav = document.getElementById('ai-nav-container');
            if (!aiNav || aiNav.style.display === 'none') return;

            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

            if (scrollTop > 100) {
                aiNav.classList.add('scrolled');
            } else {
                aiNav.classList.remove('scrolled');
            }

            lastScrollTop = scrollTop;
        });

        // Also listen on main content wrapper if it scrolls
        const mainContent = document.querySelector('.main-content-wrapper');
        if (mainContent) {
            mainContent.addEventListener('scroll', function() {
                const aiNav = document.getElementById('ai-nav-container');
                if (!aiNav || aiNav.style.display === 'none') return;

                const scrollTop = mainContent.scrollTop;

                if (scrollTop > 50) {
                    aiNav.classList.add('scrolled');
                } else {
                    aiNav.classList.remove('scrolled');
                }
            });
        }

    </script>
</body>
</html>
