<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Real-Time Audio Recording & Transcription</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* Step 4 IndexDB UI Styles */
    :root{
      --bg-top:#0b1220;
      --bg-bottom:#090d16;
      --glass: rgba(255,255,255,0.08);
      --glass-strong: rgba(255,255,255,0.12);
      --stroke: rgba(255,255,255,0.12);
      --text:#e6edf3;
      --muted:#9aa6b2;
      --accent:#35e0ff;
      --good:#3be38a;
      --danger:#ff6b6b;
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --radius-xl: 18px;
      --radius-lg: 14px;
      --radius-md: 12px;
      --blur: blur(16px);
    }
    *{ box-sizing:border-box }
    html,body{ height:100% }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color:var(--text);
      background: linear-gradient(to bottom, var(--bg-top), var(--bg-bottom)) fixed;
    }
    .app-shell{
      min-height:100dvh;
      display:flex;
      flex-direction:column;
      align-items:center;
      padding:56px 16px 120px;
      position:relative;
      overflow:hidden;
    }
    .app-shell::after{
      content:"";
      position:fixed; inset:-10%;
      pointer-events:none;
      background: radial-gradient(60% 40% at 50% 0%, rgba(255,255,255,0.06), transparent 60%);
      filter: blur(40px);
      opacity:.8;
    }

    /* Context ribbon */
    .ribbon{
      position:fixed; top:10px; left:50%; transform:translateX(-50%);
      color:var(--muted); font-size:13px; letter-spacing:.02em;
      backdrop-filter: var(--blur);
      background: rgba(255,255,255,0.04);
      border:1px solid var(--stroke);
      border-radius: 999px;
      padding:6px 10px;
      box-shadow: var(--shadow);
      z-index: 100;
    }
    .kbd{
      padding:2px 6px; border:1px solid var(--stroke); border-radius:6px; background: rgba(255,255,255,0.06);
      font-size:12px; color:var(--muted)
    }

    /* Floating palette */
    .palette{
      position:fixed; top:54px; left:50%; transform:translateX(-50%);
      width:min(92vw, 520px);
      backdrop-filter: var(--blur);
      background: var(--glass);
      border:1px solid var(--stroke);
      border-radius: var(--radius-xl);
      box-shadow: var(--shadow);
      padding:14px;
      display:none;
      z-index: 100;
    }
    .palette.open{ display:block; animation:pop .16s ease-out }
    @keyframes pop{ from{ opacity:0; transform:translateX(-50%) translateY(-6px) } to{ opacity:1; transform:translateX(-50%) translateY(0) } }
    .row{ display:flex; gap:10px; align-items:center }
    .icon-dot{
      width:10px; height:10px; border-radius:999px; background: var(--accent);
      box-shadow: 0 0 14px rgba(53,224,255,.8);
    }
    .mic-dot{
      width:10px; height:10px; border-radius:999px; background: var(--accent);
      margin-left:8px; box-shadow:0 0 10px currentColor;
      transition: background .3s ease, box-shadow .3s ease;
    }
    .mic-dot.good{ background: var(--good); }
    .mic-dot.danger{ background: var(--danger); }
    .palette input[type="text"]{
      flex:1; border:none; outline:none; background:transparent; color:var(--text);
      font-size:18px; padding:6px 2px;
    }
    .btn{
      border:1px solid var(--stroke); background: rgba(255,255,255,0.06);
      color:var(--text); padding:8px 12px; border-radius:999px; cursor:pointer;
      transition: background .15s ease, transform .05s ease;
      text-decoration:none; display:inline-flex; align-items:center; justify-content:center;
    }
    .btn:hover{ background: rgba(255,255,255,0.12) }
    .btn:active{ transform: translateY(1px) }
    .btn:disabled { opacity:.6; cursor:not-allowed; }
    .btn-accent{
      border-color: rgba(53,224,255,.35);
      background: linear-gradient(180deg, rgba(53,224,255,.18), rgba(53,224,255,.12));
      color:#b8f4ff;
    }

    /* Control Panel */
    .control-panel{
      width:min(92vw, 920px);
      border:1px solid var(--stroke);
      background: var(--glass);
      backdrop-filter: var(--blur);
      border-radius: var(--radius-xl);
      box-shadow: var(--shadow);
      padding:16px;
      margin: 20px 0;
      z-index: 10;
    }

    /* Recorder Card */
    .recorder-card{
      width:min(92vw, 920px);
      border:1px solid var(--stroke);
      background: var(--glass);
      backdrop-filter: var(--blur);
      border-radius: var(--radius-xl);
      box-shadow: var(--shadow);
      padding:18px 18px 22px;
      transition: box-shadow .2s ease, outline-color .2s ease;
      outline:1px solid transparent;
      z-index: 10;
      margin-top: 20px;
    }
    .recorder-card.active{
      outline-color: rgba(53,224,255,.5);
      box-shadow: 0 0 0 2px rgba(53,224,255,.25), var(--shadow);
    }
    .recorder-header{
      display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:8px;
    }
    .title{ font-weight:600; letter-spacing:.2px }
    .muted{ color:var(--muted); font-size:13px }

    /* Transcription Display - NEW */
    .transcription-display{
      background: rgba(0,0,0,0.3);
      border: 1px solid var(--stroke);
      border-radius: var(--radius-md);
      padding: 12px;
      margin-top: 12px;
      max-height: 200px;
      overflow-y: auto;
      font-size: 14px;
      line-height: 1.6;
    }
    .transcription-display.empty{
      color: var(--muted);
      text-align: center;
      font-style: italic;
    }
    .transcript-entry{
      margin-bottom: 8px;
      padding: 8px;
      background: rgba(255,255,255,0.04);
      border-radius: 6px;
      border-left: 3px solid var(--accent);
    }
    .transcript-entry.final{
      border-left-color: var(--good);
    }
    .transcript-entry.partial{
      border-left-color: var(--muted);
      opacity: 0.7;
      font-style: italic;
    }

    /* Chunks Section */
    .chunks-panel {
      width:min(92vw, 920px);
      border:1px solid var(--stroke);
      background: var(--glass);
      backdrop-filter: var(--blur);
      border-radius: var(--radius-xl);
      box-shadow: var(--shadow);
      padding:18px;
      margin: 20px 0;
      z-index: 10;
    }
    .list {
      display:flex;
      flex-direction:column;
      gap:16px;
    }
    .chunk {
      border:1px solid var(--stroke);
      border-radius: var(--radius-md);
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
      background: rgba(255,255,255,0.04);
      transition: box-shadow .15s ease, transform .1s ease;
    }
    .chunk:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
    }
    .chunk-header {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .meta {
      font-size:12px;
      color:var(--muted);
    }
    .chunk-audio {
      width:280px;
      height: 32px;
    }
    .waveform-shell {
      position:relative;
      border-radius: var(--radius-md);
      overflow:hidden;
      background: rgba(255,255,255,0.03);
      border:1px solid var(--stroke);
      padding:10px 12px;
    }
    .waveform-canvas {
      width:100%;
      height:96px;
      display:block;
    }

    /* Log Section */
    .log-panel {
      width:min(92vw, 920px);
      border:1px solid var(--stroke);
      background: var(--glass);
      backdrop-filter: var(--blur);
      border-radius: var(--radius-xl);
      box-shadow: var(--shadow);
      padding:18px;
      margin: 20px 0;
      z-index: 10;
    }
    .log {
      width:100%;
      height:140px;
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      background: rgba(0,0,0,0.3);
      border: 1px solid var(--stroke);
      border-radius: var(--radius-md);
      padding: 10px;
      color: var(--text);
      resize: vertical;
    }

    /* Word-level highlighting (karaoke style) */
    .word {
      transition: background-color 0.15s ease, color 0.15s ease, font-weight 0.15s ease;
      padding: 2px 4px;
      border-radius: 3px;
      display: inline-block;
      cursor: pointer;
    }
    .word.active {
      background-color: rgba(251, 191, 36, 0.4);
      font-weight: 600;
      color: #fbbf24;
      box-shadow: 0 0 8px rgba(251, 191, 36, 0.3);
    }

    /* Confirmation sheet */
    .confirm{
      position:fixed; left:50%; transform:translateX(-50%);
      bottom:-320px; width:min(92vw, 520px);
      border-top-left-radius: var(--radius-xl);
      border-top-right-radius: var(--radius-xl);
      border:1px solid var(--stroke);
      background: var(--glass-strong);
      backdrop-filter: blur(20px);
      box-shadow: var(--shadow);
      padding:16px;
      transition: bottom .22s ease;
      z-index: 200;
    }
    .confirm.open{ bottom:10px }
    .confirm .ok{ color:#b6f7d2 }

    /* Helpers */
    .row-wrap{ display:flex; gap:8px; flex-wrap:wrap }
    .spacer{ flex:1 }
    .hidden{ display:none !important }
  </style>
</head>
<body>
  <div class="app-shell">

    <!-- Context ribbon -->
    <div id="context-ribbon" class="ribbon">
      <span style="color:#3be38a;font-weight:600;">v5.1.0-word-highlighting</span> &nbsp;‚Ä¢&nbsp;
      In Browser ‚Ä∫ Audio Recorder ‚Ä∫ <span id="elapsed">00:00</span>
      &nbsp;‚Ä¢&nbsp; <span class="kbd">‚åò</span>/<span class="kbd">Ctrl</span>+<span class="kbd">K</span> to open palette
    </div>

    <!-- Floating command palette -->
    <div id="palette" class="palette" aria-hidden="true">
      <div class="row" style="margin-bottom:8px;">
        <span class="icon-dot" aria-hidden="true"></span>
        <input id="palette-input" type="text" placeholder="Ask: "Transcribe the latest recording and summarize‚Ä¶"" />
        <button id="palette-start" class="btn btn-accent">üéô Start</button>
        <button id="palette-stop" class="btn hidden">‚èπ Stop</button>
      </div>
      <div class="row-wrap muted">
        <span>Suggestions:</span>
        <span class="kbd">Summarize</span>
        <span class="kbd">Export SRT</span>
        <span class="kbd">Timestamps</span>
      </div>
    </div>

    <!-- Main Title -->
    <h1 style="display:flex;align-items:center;gap:8px;color:var(--text);margin:0 0 20px 0;">
      Real-Time Recording & Transcription
      <span id="mic-status" class="mic-dot" title="mic status"></span>
    </h1>

    <!-- Control Panel -->
    <div class="control-panel">
      <div class="row">
        <label style="display:flex;align-items:center;gap:8px;color:var(--muted);">Chunk length (ms):
          <input id="timeslice" type="number" value="5000" min="500" step="500"
                 style="background:rgba(255,255,255,0.08);border:1px solid var(--stroke);
                        border-radius:8px;padding:6px 10px;color:var(--text);width:80px;" />
        </label>
        <label style="display:flex;align-items:center;gap:8px;color:var(--muted);">Overlap (ms):
          <input id="overlap" type="number" value="500" min="0" max="2000" step="100"
                 style="background:rgba(255,255,255,0.08);border:1px solid var(--stroke);
                        border-radius:8px;padding:6px 10px;color:var(--text);width:80px;" />
        </label>
        <div class="spacer"></div>
        <div id="storage-status" style="color:var(--muted);font-size:12px;">
          Storage: Loading...
        </div>
      </div>
      <div class="row" style="margin-top:10px">
        <button id="btn-start" class="btn btn-accent">üéô Start Recording</button>
        <button id="btn-stop" class="btn" disabled>‚èπ Stop</button>
        <button id="clearBtn" class="btn">üóëÔ∏è Clear</button>
      </div>
    </div>

    <!-- Recorder card with live waveform AND transcription -->
    <section id="recorder-card" class="recorder-card">
      <div class="recorder-header">
        <div>
          <div class="title">Live Recording Status</div>
          <div class="muted">Overlapping chunks for gap-free recording + Real-time transcription via WhisperLive</div>
        </div>
      </div>
      <div id="recorder-body" class="recorder-body" style="padding:16px;">
        <div id="live-placeholder" style="text-align:center;padding:20px;color:var(--muted);border:2px dashed var(--stroke);border-radius:8px;">
          <div style="font-size:18px;margin-bottom:8px;">üéôÔ∏è</div>
          <div>Click "Start Recording" to see live waveform and transcription</div>
        </div>
      </div>
    </section>

    <!-- Chunks Section -->
    <div class="chunks-panel">
      <h3 style="margin:0 0 16px 0;color:var(--text);">Recorded Chunks</h3>
      <div id="chunkList" class="list"></div>
    </div>

    <!-- Log Section -->
    <div class="log-panel">
      <h3 style="margin:0 0 16px 0;color:var(--text);">Log</h3>
      <textarea id="log" class="log" readonly></textarea>
    </div>

    <!-- Confirmation sheet -->
    <section id="confirm" class="confirm" aria-hidden="true">
      <div class="row" style="margin-bottom:8px;">
        <div class="ok">‚úÖ Recording Complete</div>
        <div class="spacer"></div>
        <button id="confirm-close" class="btn" type="button">Close</button>
      </div>
      <div class="muted" id="confirm-details">‚Äì</div>
    </section>
  </div>

  <script>
    // ============================================================
    // INDEXEDDB STORAGE MANAGER
    // ============================================================
    class AudioStorageManager {
      constructor() {
        this.db = null;
        this.dbName = 'AudioRecorderDB';
        this.dbVersion = 3;  // Bumped to v3 for transcriptions table
        this.initialized = false;
      }

      async init() {
        if (this.initialized) return this.db;

        return new Promise((resolve, reject) => {
          const request = indexedDB.open(this.dbName, this.dbVersion);

          request.onerror = () => {
            console.error('IndexedDB failed to open:', request.error);
            reject(request.error);
          };

          request.onsuccess = () => {
            this.db = request.result;
            this.initialized = true;
            console.log('IndexedDB opened successfully');
            resolve(this.db);
          };

          request.onupgradeneeded = (event) => {
            const db = event.target.result;

            // Sessions table
            if (!db.objectStoreNames.contains('sessions')) {
              const sessionsStore = db.createObjectStore('sessions', { keyPath: 'id' });
              sessionsStore.createIndex('timestamp', 'timestamp', { unique: false });
              sessionsStore.createIndex('status', 'status', { unique: false });
            }

            // Chunks table
            if (!db.objectStoreNames.contains('chunks')) {
              const chunksStore = db.createObjectStore('chunks', { keyPath: 'id' });
              chunksStore.createIndex('sessionId', 'sessionId', { unique: false });
              chunksStore.createIndex('chunkIndex', 'chunkIndex', { unique: false });
              chunksStore.createIndex('timestamp', 'timestamp', { unique: false });
            }

            // Transcriptions table (NEW in v3)
            if (!db.objectStoreNames.contains('transcriptions')) {
              const transcriptionsStore = db.createObjectStore('transcriptions', {
                keyPath: 'id',
                autoIncrement: true
              });
              transcriptionsStore.createIndex('sessionId', 'sessionId', { unique: false });
              transcriptionsStore.createIndex('start', 'start', { unique: false });
              transcriptionsStore.createIndex('timestamp', 'timestamp', { unique: false });
              console.log('‚úÖ Created transcriptions table with indexes');
            }

            console.log('IndexedDB schema created/updated to version', db.version);
          };
        });
      }

      async createSession(settings = {}) {
        await this.init();

        if (!this.db.objectStoreNames.contains('sessions')) {
          throw new Error('Sessions object store not found');
        }

        const sessionId = `session_${new Date().toISOString().replace(/[:.]/g, '_')}`;
        const session = {
          id: sessionId,
          timestamp: Date.now(),
          totalDuration: 0,
          chunkCount: 0,
          settings: {
            chunkDuration: 5000,
            mimeType: 'audio/webm',
            ...settings
          },
          status: 'recording',
          transcription: null,
          created: new Date().toISOString()
        };

        const transaction = this.db.transaction(['sessions'], 'readwrite');
        const store = transaction.objectStore('sessions');

        return new Promise((resolve, reject) => {
          const request = store.add(session);
          request.onsuccess = () => resolve(session);
          request.onerror = () => reject(request.error);
        });
      }

      async updateSession(sessionId, updates) {
        await this.init();

        const transaction = this.db.transaction(['sessions'], 'readwrite');
        const store = transaction.objectStore('sessions');

        return new Promise((resolve, reject) => {
          const getRequest = store.get(sessionId);
          getRequest.onsuccess = () => {
            const session = getRequest.result;
            if (!session) {
              reject(new Error('Session not found'));
              return;
            }

            Object.assign(session, updates);
            const putRequest = store.put(session);
            putRequest.onsuccess = () => resolve(session);
            putRequest.onerror = () => reject(putRequest.error);
          };
          getRequest.onerror = () => reject(getRequest.error);
        });
      }

      async getAllSessions() {
        await this.init();

        if (!this.db.objectStoreNames.contains('sessions')) {
          return [];
        }

        const transaction = this.db.transaction(['sessions'], 'readonly');
        const store = transaction.objectStore('sessions');
        const index = store.index('timestamp');

        return new Promise((resolve, reject) => {
          const request = index.getAll();
          request.onsuccess = () => {
            const sessions = request.result.sort((a, b) => b.timestamp - a.timestamp);
            resolve(sessions);
          };
          request.onerror = () => reject(request.error);
        });
      }

      async saveChunk(sessionId, chunkIndex, blob, duration) {
        await this.init();

        const chunkId = `chunk_${sessionId}_${String(chunkIndex).padStart(3, '0')}`;
        const chunk = {
          id: chunkId,
          sessionId: sessionId,
          chunkIndex: chunkIndex,
          blob: blob,
          duration: duration,
          timestamp: Date.now(),
          size: blob.size,
          type: blob.type
        };

        const transaction = this.db.transaction(['chunks'], 'readwrite');
        const store = transaction.objectStore('chunks');

        return new Promise((resolve, reject) => {
          const request = store.add(chunk);
          request.onsuccess = () => resolve(chunk);
          request.onerror = () => reject(request.error);
        });
      }

      async getChunksBySession(sessionId) {
        await this.init();

        const transaction = this.db.transaction(['chunks'], 'readonly');
        const store = transaction.objectStore('chunks');
        const index = store.index('sessionId');

        return new Promise((resolve, reject) => {
          const request = index.getAll(sessionId);
          request.onsuccess = () => {
            const chunks = request.result.sort((a, b) => a.chunkIndex - b.chunkIndex);
            resolve(chunks);
          };
          request.onerror = () => reject(request.error);
        });
      }

      async saveTranscription(sessionId, text, start, end, words, completed) {
        await this.init();

        const transcription = {
          sessionId: sessionId,
          text: text,
          start: start,
          end: end,
          words: words || [],
          completed: completed,
          timestamp: Date.now()
        };

        const transaction = this.db.transaction(['transcriptions'], 'readwrite');
        const store = transaction.objectStore('transcriptions');

        return new Promise((resolve, reject) => {
          const request = store.add(transcription);
          request.onsuccess = () => {
            console.log('üíæ Saved transcription:', text.substring(0, 30), `[${start.toFixed(2)}s ‚Üí ${end.toFixed(2)}s]`);
            resolve(transcription);
          };
          request.onerror = () => reject(request.error);
        });
      }

      async getTranscriptionsBySession(sessionId) {
        await this.init();

        const transaction = this.db.transaction(['transcriptions'], 'readonly');
        const store = transaction.objectStore('transcriptions');
        const index = store.index('sessionId');

        return new Promise((resolve, reject) => {
          const request = index.getAll(sessionId);
          request.onsuccess = () => {
            const transcriptions = request.result.sort((a, b) => a.start - b.start);
            console.log('üìñ Loaded', transcriptions.length, 'transcriptions for session', sessionId);
            resolve(transcriptions);
          };
          request.onerror = () => reject(request.error);
        });
      }

      async getStorageUsage() {
        if (!navigator.storage || !navigator.storage.estimate) {
          return { used: 0, available: 0, percentage: 0, usedMB: 0, availableMB: 0 };
        }

        try {
          const estimate = await navigator.storage.estimate();
          const used = estimate.usage || 0;
          const available = estimate.quota || 0;

          return {
            usedMB: Math.round(used / (1024 * 1024)),
            availableMB: Math.round(available / (1024 * 1024))
          };
        } catch (error) {
          return { usedMB: 0, availableMB: 0 };
        }
      }

      createObjectURL(blob) {
        return URL.createObjectURL(blob);
      }

      async clearDatabase() {
        return new Promise((resolve, reject) => {
          if (this.db) {
            this.db.close();
            this.db = null;
            this.initialized = false;
          }

          const deleteRequest = indexedDB.deleteDatabase(this.dbName);
          deleteRequest.onsuccess = () => resolve();
          deleteRequest.onerror = () => reject(deleteRequest.error);
        });
      }
    }

    window.audioStorage = new AudioStorageManager();
  </script>

  <script>
    // ============================================================
    // TRANSCRIPT ACCUMULATOR (from existing app)
    // ============================================================
    class TranscriptAccumulator {
      constructor(cfg = {}) {
        this.cfg = {
          K: cfg.stabilityFrames ?? 2,
          Lmin: cfg.minPrefixLength ?? 3,
          T_ms: cfg.stabilityTimeMs ?? 1000,
          W: cfg.overlapWindow ?? 8,
          eps: cfg.refineEpsilon ?? 0.15,
          alpha: cfg.slideThreshold ?? 0.4,
          beta: cfg.minSlideLength ?? 5,
          H: cfg.hysteresisFrames ?? 2,
          cooldownMs: cfg.cooldownMs ?? 250,
          finalAlignW: cfg.alignWindow ?? 10,
          softTailTokens: cfg.softTailTokens ?? 12,
          recentTailGuard: cfg.recentTailGuard ?? 35,
          debug: cfg.debug ?? true,
        };

        this.accTokens = [];
        this.accText = "";
        this.hardCommitted = 0;
        this.workingTokens = [];
        this.workingOrig = "";
        this.lastPartialTokens = [];
        this.stableCounts = [];
        this.stableSince = [];
        this.slideStreak = 0;
        this.lastSlideAt = 0;
      }

      ingestPartial(text) {
        const now = Date.now();
        const norm = this._normalize(text);
        const curr = this._tokenize(norm);

        if (this.workingTokens.length === 0) {
          this.workingTokens = curr.slice();
          this.workingOrig = text;
          this.lastPartialTokens = curr.slice();
          this._resetStability(curr.length, now);
          this._alignCurrWithTail(curr);
          return { slideDetected: false };
        }

        this._alignCurrWithTail(curr);

        const lcp = this._lcp(this.lastPartialTokens, curr);
        const limit = Math.min(lcp, this.workingTokens.length);

        for (let i = 0; i < limit; i++) {
          this.stableCounts[i] += 1;
          if (this.stableCounts[i] === 1) this.stableSince[i] = now;
        }
        for (let i = limit; i < this.workingTokens.length; i++) {
          this.stableCounts[i] = 0;
          this.stableSince[i] = now;
        }

        const { K, Lmin, T_ms: Tms } = this.cfg;
        let commitLen = 0;
        for (let i = 0; i < limit; i++) {
          const byFrames = this.stableCounts[i] >= K;
          const byTime = (now - this.stableSince[i]) >= Tms;
          if ((byFrames || byTime) && i >= (Lmin - 1)) commitLen = i + 1;
          else break;
        }

        if (commitLen > 0) {
          const prefix = this.workingTokens.slice(0, commitLen);
          if (!this._recentTailDuplicate(prefix)) {
            const display = this._detok(prefix);
            this._appendToAccumulated(prefix, display);
            if (this.cfg.debug) console.log(`[SPC] committed: "${display}"`);
          }
          this.workingTokens = this.workingTokens.slice(commitLen);
          this.workingOrig = this._detok(this.workingTokens);
          this.stableCounts = this.stableCounts.slice(commitLen);
          this.stableSince = this.stableSince.slice(commitLen);

          const desiredHard = Math.max(0, this.accTokens.length - this.cfg.softTailTokens);
          if (desiredHard > this.hardCommitted) this.hardCommitted = desiredHard;
        }

        const slide = this._detectSlide(this.lastPartialTokens, curr, now);
        if (slide && this.workingTokens.length >= this.cfg.beta) {
          const overlapK = this._maxPrefixOverlapWithTail(this.workingTokens, this.accTokens, this.cfg.finalAlignW);
          const remainder = this.workingTokens.slice(overlapK);

          let rescuedText = '';
          if (remainder.length > 0 && !this._recentTailDuplicate(remainder)) {
            const disp = this._detok(remainder);
            rescuedText = disp;
            this._appendToAccumulated(remainder, disp, true);
            if (this.cfg.debug) console.log(`[EW] RESCUED remainder: "${disp}"`);
          }

          this.workingTokens = curr.slice();
          this.workingOrig = text;
          this._resetStability(this.workingTokens.length, now);
          this.hardCommitted = this.accTokens.length;

          this.lastPartialTokens = curr.slice();
          return { slideDetected: true, rescuedText: rescuedText };
        }

        this.workingTokens = curr.slice();
        this.workingOrig = text;
        this._ensureStabilityLength(this.workingTokens.length, now);
        this.lastPartialTokens = curr.slice();
        return { slideDetected: false };
      }

      ingestFinal(text) {
        const finalTok = this._tokenize(this._normalize(text));
        const drop = this._maxPrefixOverlapWithTail(finalTok, this.accTokens, this.cfg.finalAlignW);
        const remainder = finalTok.slice(drop);
        if (remainder.length === 0) return;
        if (!this._recentTailDuplicate(remainder)) {
          const disp = this._detok(remainder);
          this._appendToAccumulated(remainder, disp, true);
          if (this.cfg.debug) console.log(`[BoF] Added final: "${disp}"`);
        }

        const covered = this._lcp(this.workingTokens, finalTok);
        if (covered > 0) {
          this.workingTokens = this.workingTokens.slice(covered);
          this.workingOrig = this._detok(this.workingTokens);
          this.stableCounts = this.stableCounts.slice(covered);
          this.stableSince = this.stableSince.slice(covered);
        }
        if (this.workingTokens.length === 0) {
          this._resetStability(0, Date.now());
        }

        this.hardCommitted = this.accTokens.length;
      }

      getTranscript() { return this.accText.trim(); }

      getTranscriptWithCurrent() {
        const base = this.accText.trim();
        const curr = this.workingOrig.trim();
        return base ? (curr ? `${base} ${curr}` : base) : curr;
      }

      reset() {
        this.accTokens = [];
        this.accText = "";
        this.hardCommitted = 0;
        this.workingTokens = [];
        this.workingOrig = "";
        this.lastPartialTokens = [];
        this.stableCounts = [];
        this.stableSince = [];
        this.slideStreak = 0;
        this.lastSlideAt = 0;
      }

      flushWorking() {
        if (this.workingTokens.length > 0) {
          const text = this.workingOrig.trim();
          if (text) {
            this.ingestFinal(text);
            return text;
          }
        }
        return '';
      }

      _normalize(s) {
        const numberWords = {
          'zero': '0', 'one': '1', 'two': '2', 'three': '3', 'four': '4',
          'five': '5', 'six': '6', 'seven': '7', 'eight': '8', 'nine': '9',
          'ten': '10', 'eleven': '11', 'twelve': '12', 'thirteen': '13',
          'fourteen': '14', 'fifteen': '15', 'sixteen': '16', 'seventeen': '17',
          'eighteen': '18', 'nineteen': '19', 'twenty': '20', 'thirty': '30',
          'forty': '40', 'fifty': '50', 'sixty': '60', 'seventy': '70',
          'eighty': '80', 'ninety': '90', 'hundred': '100', 'thousand': '1000'
        };

        let normalized = String(s)
          .toLowerCase()
          .replace(/[""]/g, '"')
          .replace(/['']/g, "'")
          .replace(/[^\p{L}\p{N}\s'".,!?-]+/gu, " ")
          .replace(/[,\.!?;:'"-]/g, '');

        Object.keys(numberWords).forEach(word => {
          const regex = new RegExp(`\\b${word}\\b`, 'g');
          normalized = normalized.replace(regex, numberWords[word]);
        });

        return normalized.replace(/\s+/g, " ").trim();
      }

      _tokenize(norm) { return norm ? norm.split(" ") : []; }
      _detok(toks) { return toks.join(" "); }

      _resetStability(len, now) {
        this.stableCounts = Array(len).fill(0);
        this.stableSince = Array(len).fill(now);
      }

      _ensureStabilityLength(len, now) {
        const d = len - this.stableCounts.length;
        if (d > 0) {
          this.stableCounts.push(...Array(d).fill(0));
          this.stableSince.push(...Array(d).fill(now));
        }
      }

      _lcp(a, b) {
        const n = Math.min(a.length, b.length);
        let i = 0;
        while (i < n && a[i] === b[i]) i++;
        return i;
      }

      _overlapSuffixPrefix(a, b, W) {
        const maxk = Math.min(W, a.length, b.length);
        for (let k = maxk; k > 0; k--) {
          let ok = true;
          for (let i = 0; i < k; i++) {
            if (a[a.length - k + i] !== b[i]) { ok = false; break; }
          }
          if (ok) return k;
        }
        return 0;
      }

      _lcpRatio(oldT, newT) {
        if (oldT.length === 0) return 1;
        const l = this._lcp(oldT, newT);
        return l / oldT.length;
      }

      _detectSlide(oldT, newT, now) {
        const { W, eps, alpha, H, cooldownMs } = this.cfg;
        const lcpR = this._lcpRatio(oldT, newT);
        const sp = this._overlapSuffixPrefix(oldT, newT, W);

        const refinement = (lcpR >= (1 - eps)) || (sp >= Math.min(3, Math.floor(oldT.length / 2)));
        if (refinement) { this.slideStreak = 0; return false; }

        const candidate = (sp === 0) && (lcpR < alpha) && (oldT.length >= this.cfg.beta);
        if (!candidate) { this.slideStreak = 0; return false; }

        if (now - this.lastSlideAt < cooldownMs) return false;

        this.slideStreak += 1;
        if (this.slideStreak >= H) {
          this.slideStreak = 0;
          this.lastSlideAt = now;
          return true;
        }
        return false;
      }

      _maxPrefixOverlapWithTail(prefix, tail, W) {
        const maxk = Math.min(W, prefix.length, tail.length);
        for (let k = maxk; k > 0; k--) {
          let ok = true;
          for (let i = 0; i < k; i++) {
            if (prefix[i] !== tail[tail.length - k + i]) { ok = false; break; }
          }
          if (ok) return k;
        }
        return 0;
      }

      _recentTailDuplicate(tokens) {
        const guard = Math.max(this.cfg.recentTailGuard, tokens.length);
        const tail = this.accTokens.slice(Math.max(0, this.accTokens.length - guard));
        if (tokens.length > tail.length) return false;
        const start = tail.length - tokens.length;
        for (let i = 0; i < tokens.length; i++) {
          if (tail[start + i] !== tokens[i]) return false;
        }
        return true;
      }

      _appendToAccumulated(tokens, display, isFromFinal = false) {
        if (tokens.length === 0) return;
        const separator = isFromFinal ? "\n" : " ";
        const sep = this.accText.length ? separator : "";
        this.accText = `${this.accText}${sep}${display}`.trim();
        this.accTokens.push(...tokens);

        const desiredHard = Math.max(0, this.accTokens.length - this.cfg.softTailTokens);
        if (desiredHard > this.hardCommitted) this.hardCommitted = desiredHard;
      }

      _alignCurrWithTail(curr) {
        const R = this.cfg.softTailTokens;
        if (this.accTokens.length === 0) return;

        const direct = this._maxPrefixOverlapWithTail(curr, this.accTokens, Math.max(R, this.cfg.finalAlignW));
        if (direct > 0) return;

        const editableStart = Math.max(this.hardCommitted, this.accTokens.length - R);
        const editableLen = this.accTokens.length - editableStart;
        if (editableLen <= 0) return;

        for (let back = 1; back <= editableLen; back++) {
          const newTailLen = this.accTokens.length - back;
          const k = this._maxPrefixOverlapWithTail(curr, this.accTokens.slice(0, newTailLen), this.cfg.finalAlignW);
          if (k > 0) {
            this.accTokens = this.accTokens.slice(0, newTailLen);
            this.accText = this._detok(this.accTokens);
            if (this.cfg.debug) console.log(`[REWIND] tokensRolledBack=${back}`);
            return;
          }
        }
      }
    }

    const transcriptAccumulator = new TranscriptAccumulator({
      stabilityFrames: 2,
      minPrefixLength: 3,
      stabilityTimeMs: 1000,
      overlapWindow: 8,
      slideThreshold: 0.95,
      minSlideLength: 200,
      hysteresisFrames: 10,
      cooldownMs: 60000,
      alignWindow: 10
    });
  </script>

  <script>
    // ============================================================
    // MAIN APPLICATION - Merged Recording + Transcription
    // ============================================================
    (() => {
      // Helpers
      function $(id){ return document.getElementById(id); }
      var logEl = $('log');
      function log(){
        var parts=[];
        for (var i=0;i<arguments.length;i++){
          try{
            parts.push(typeof arguments[i]==='string'?arguments[i]:JSON.stringify(arguments[i]));
          }catch(_){
            parts.push(String(arguments[i]));
          }
        }
        var line = new Date().toISOString() + '  ' + parts.join(' ');
        logEl.value += '\n' + line;
        logEl.scrollTop = logEl.scrollHeight;
        console.log('[app]', line);
      }
      function pad3(n){ n=String(n); while(n.length<3) n='0'+n; return n; }
      function fmt(t){
        t = Math.max(0, t|0);
        const m = String((t/60|0)).padStart(2,'0');
        const s = String(t%60).padStart(2,'0');
        return `${m}:${s}`;
      }

      // UI refs
      var timesliceInput = $('timeslice');
      var overlapInput = $('overlap');
      var startBtn = $('btn-start');
      var stopBtn  = $('btn-stop');
      var palStart = $('palette-start');
      var palStop  = $('palette-stop');
      var clearBtn = $('clearBtn');
      var list     = $('chunkList');
      var dot      = $('mic-status');
      var palette  = $('palette');
      var elapsedEl = $('elapsed');
      var card     = $('recorder-card');
      var confirmEl = $('confirm');
      var confirmDetails = $('confirm-details');
      var confirmClose = $('confirm-close');
      var storageStatus = $('storage-status');
      var recorderBody = $('recorder-body');

      // State
      var mediaStream = null;
      var running     = false;
      var chunkIndex  = 0;
      var chunkTimer  = null;
      var preferredMime = null;
      var startedAt = null;
      var timerId = null;
      var currentSession = null;
      var chunkStartTimes = [];
      var liveWaveformCanvas = null;
      var liveAnalyser = null;
      var liveAnimationId = null;
      var completedChunks = 0;
      var activeRecorders = [];
      var decodeCtx = null;

      // WhisperLive state
      var ws = null;
      var whisperAudioContext = null;
      var whisperProcessor = null;
      var whisperSource = null;
      var transcriptDisplay = null;
      var lastCommittedTimestamp = 0;
      var transcriptionSegments = [];  // Store all final segments with timestamps

      function chooseMime(){
        var c = ['audio/ogg;codecs=opus','audio/ogg','audio/webm;codecs=opus','audio/webm'];
        if (window.MediaRecorder && MediaRecorder.isTypeSupported){
          for (var i=0; i<c.length; i++){
            try{ if (MediaRecorder.isTypeSupported(c[i])) return c[i]; }catch(e){}
          }
        }
        return '';
      }

      // Waveform rendering (from step4)
      function getCanvasSize(canvas){
        const rect = canvas.getBoundingClientRect();
        if (canvas.width !== Math.floor(rect.width) || canvas.height !== Math.floor(rect.height)){
          canvas.width  = Math.floor(rect.width);
          canvas.height = Math.floor(rect.height);
        }
        return { W: canvas.width, H: canvas.height };
      }

      function drawRoundRect(ctx, x, y, w, h, r){
        r = Math.min(r, w/2, h/2);
        ctx.beginPath();
        ctx.moveTo(x+r, y);
        ctx.lineTo(x+w-r, y);
        ctx.quadraticCurveTo(x+w, y, x+w, y+r);
        ctx.lineTo(x+w, y+h-r);
        ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
        ctx.lineTo(x+r, y+h);
        ctx.quadraticCurveTo(x, y+h, x, y+h-r);
        ctx.lineTo(x, y+r);
        ctx.quadraticCurveTo(x, y, x+r, y);
        ctx.closePath();
      }

      function computePeaksFromBuffer(buffer, barCount){
        var data = buffer.getChannelData(0);
        var total = data.length;
        var samplesPerBar = Math.max(1, Math.floor(total / barCount));
        var peaks = new Float32Array(barCount);

        for (var i=0; i<barCount; i++){
          var start = i * samplesPerBar;
          var end   = Math.min(total, start + samplesPerBar);
          var sum=0, cnt=0;
          for (var j=start; j<end; j++){ var v=data[j]; sum += v*v; cnt++; }
          var rms = Math.sqrt(sum / Math.max(1, cnt));
          peaks[i] = rms;
        }
        var max = 0; for (var k=0;k<barCount;k++){ if (peaks[k] > max) max = peaks[k]; }
        var scale = max > 0 ? (1 / max) : 1;
        for (var m=0;m<barCount;m++){ peaks[m] *= scale; }
        return peaks;
      }

      function drawBars(ctx, canvas, peaks, progressRatio){
        const size = getCanvasSize(canvas);
        const W = size.W, H = size.H;
        ctx.clearRect(0,0,W,H);

        const bars = peaks.length;
        const padX = 12;
        const gap  = 1;
        const bw   = Math.max(2, Math.floor((W - padX*2) / bars) - gap);
        const cy   = H / 2;
        const maxH = H - 18;
        const playedBars = Math.floor(Math.max(0, Math.min(1, progressRatio)) * bars);

        function drawCenteredBar(i, color){
          const amp = peaks[i];
          const h   = Math.max(2, amp * maxH);
          const y   = cy - (h / 2);
          const x   = padX + i * (bw + gap);
          ctx.fillStyle = color;
          const ry = Math.min(4, h/2);
          if (ctx.roundRect) { ctx.beginPath(); ctx.roundRect(x, y, bw, h, ry); ctx.fill(); }
          else { drawRoundRect(ctx, x, y, bw, h, ry); ctx.fill(); }
        }

        for (let i = 0; i < playedBars; i++) drawCenteredBar(i, '#35e0ff');
        for (let i = playedBars; i < bars; i++) drawCenteredBar(i, '#475569');

        ctx.fillStyle = '#ffffff10';
        ctx.fillRect(padX, Math.floor(cy) - 0.5, W - padX*2, 1);
      }

      function renderWaveform(canvas, audioEl, blob){
        getCanvasSize(canvas);

        if (!decodeCtx){
          var AC = window.AudioContext || window.webkitAudioContext;
          decodeCtx = new AC();
        }
        blob.arrayBuffer().then(function(ab){
          return decodeCtx.decodeAudioData(ab);
        }).then(function(buffer){
          var desiredPxPerBar = 4;
          var W = canvas.getBoundingClientRect().width;
          var barCount = Math.max(60, Math.min(800, Math.floor(W / desiredPxPerBar)));
          var peaks = computePeaksFromBuffer(buffer, barCount);
          var ctx = canvas.getContext('2d');

          function repaint(){
            var ratio = (!audioEl.duration || !isFinite(audioEl.duration)) ? 0
                      : Math.max(0, Math.min(1, audioEl.currentTime / audioEl.duration));
            drawBars(ctx, canvas, peaks, ratio);
          }
          repaint();

          audioEl.addEventListener('timeupdate', repaint);
          audioEl.addEventListener('seeked', repaint);
          audioEl.addEventListener('loadedmetadata', repaint);
          audioEl.addEventListener('play', repaint);
          audioEl.addEventListener('pause', repaint);

          canvas.style.cursor = 'pointer';
          canvas.title = 'Click to seek';
          canvas.onclick = function(ev){
            var rect = canvas.getBoundingClientRect();
            var x = ev.clientX - rect.left;
            var ratio = Math.min(1, Math.max(0, x / rect.width));
            if (!isNaN(audioEl.duration) && isFinite(audioEl.duration)){
              audioEl.currentTime = ratio * audioEl.duration;
              audioEl.play().catch(function(){});
            }
          };

          window.addEventListener('resize', function(){
            getCanvasSize(canvas);
            var W2 = canvas.getBoundingClientRect().width;
            var barCount2 = Math.max(60, Math.min(800, Math.floor(W2 / desiredPxPerBar)));
            peaks = computePeaksFromBuffer(buffer, barCount2);
            repaint();
          });
        }).catch(function(err){
          console.warn('decode/waveform error', err);
        });
      }

      async function renderChunk(blob, idx, duration){
        var row = document.createElement('div');
        row.className = 'chunk';

        var top = document.createElement('div');
        top.className = 'chunk-header';

        var meta = document.createElement('div');
        meta.className = 'meta';

        var chunkStartTime = chunkStartTimes[idx - 1] || 0;
        var chunkEndTime = Date.now();
        var startOffset = chunkStartTime ? ((chunkStartTime - startedAt) / 1000) : 0;
        var endOffset = (chunkEndTime - startedAt) / 1000;
        var startTimeStr = fmt(startOffset);
        var endTimeStr = fmt(endOffset);

        meta.innerHTML = 'seg-' + pad3(idx) + ' (' + (blob.type || 'audio') + ')<br>' +
                         '<span style="color:var(--accent);font-size:11px;">' +
                         startTimeStr + ' ‚Üí ' + endTimeStr + ' (' + Math.round(blob.size / 1024) + 'KB)</span>';

        var audioEl = document.createElement('audio');
        var localUrl = URL.createObjectURL(blob);
        audioEl.controls = true;
        audioEl.preload = 'metadata';
        audioEl.src = localUrl;
        audioEl.className = 'chunk-audio';
        audioEl.addEventListener('loadedmetadata', function(){
          log('seg-' + pad3(idx) + ' loadedmetadata duration=' + (audioEl.duration || 0));
        });

        top.appendChild(meta);
        top.appendChild(audioEl);

        var shell = document.createElement('div');
        shell.className = 'waveform-shell';

        var canvas = document.createElement('canvas');
        canvas.className = 'waveform-canvas';
        shell.appendChild(canvas);

        // Create transcription container for this chunk
        var transcriptionContainer = document.createElement('div');
        transcriptionContainer.className = 'chunk-transcription';
        transcriptionContainer.style.cssText = 'margin-top:8px;padding:8px;background:rgba(0,0,0,0.2);border-radius:6px;min-height:24px;font-size:13px;line-height:1.5;color:var(--text);border:1px solid var(--stroke);';
        transcriptionContainer.innerHTML = '<span style="color:var(--muted);font-style:italic;">Transcription will appear here...</span>';

        // Store chunk timing data for later lookup
        row.dataset.chunkIndex = idx;
        row.dataset.startTime = startOffset.toFixed(3);
        row.dataset.endTime = endOffset.toFixed(3);

        row.appendChild(top);
        row.appendChild(shell);
        row.appendChild(transcriptionContainer);

        if (list.firstChild) {
          list.insertBefore(row, list.firstChild);
        } else {
          list.appendChild(row);
        }

        renderWaveform(canvas, audioEl, blob);

        // Setup word-level highlighting for this chunk
        setupWordHighlighting(audioEl, row);

        completedChunks++;

        var chunkCountEl = $('chunk-count');
        if (chunkCountEl) chunkCountEl.textContent = completedChunks;

        if (currentSession && window.audioStorage) {
          try {
            await window.audioStorage.saveChunk(
              currentSession.id,
              idx,
              blob,
              duration || audioEl.duration || 0
            );
            log('Chunk saved to IndexedDB');

            await window.audioStorage.updateSession(currentSession.id, {
              chunkCount: chunkIndex,
              totalDuration: ((Date.now() - startedAt) / 1000)
            });

            updateStorageStatus();
          } catch (error) {
            log('Error saving chunk:', error.message);
          }
        }
      }

      function recordOverlappingChunk(stream, chunkMs, overlapMs, mime, onBlob){
        var opts = mime ? { mimeType: mime } : {};
        var rec;
        try { rec = new MediaRecorder(stream, opts); }
        catch(e){ log('MediaRecorder ctor failed:', e && e.message ? e.message : e); throw e; }

        var gotData = false;
        var startTime = Date.now();

        rec.ondataavailable = function(ev){
          if (ev.data && ev.data.size > 0){
            gotData = true;
            var typed = new Blob([ev.data], { type: (mime || ev.data.type || 'audio/webm') });
            var actualDuration = (Date.now() - startTime) / 1000;
            onBlob(typed, actualDuration);
          }
        };

        rec.onstop = function(){
          var index = activeRecorders.indexOf(rec);
          if (index > -1) activeRecorders.splice(index, 1);

          if (!gotData){
            log('WARN: recorder stopped without data');
          }
        };

        activeRecorders.push(rec);
        rec.start();

        setTimeout(function(){
          try { rec.stop(); } catch(_){}
        }, chunkMs + overlapMs);

        return rec;
      }

      function stopAllRecorders(){
        log('Stopping all active recorders:', activeRecorders.length);
        activeRecorders.forEach(function(rec){
          try {
            if (rec.state === 'recording') {
              rec.stop();
            }
          } catch(_){}
        });
        activeRecorders = [];
      }

      // Live waveform (frequency bars)
      function setupLiveWaveform(stream) {
        try {
          log('Setting up live waveform...');

          if (!decodeCtx) {
            var AC = window.AudioContext || window.webkitAudioContext;
            decodeCtx = new AC();
          }

          if (decodeCtx.state === 'suspended') {
            decodeCtx.resume().then(() => log('Audio context resumed'));
          }

          var source = decodeCtx.createMediaStreamSource(stream);
          liveAnalyser = decodeCtx.createAnalyser();
          liveAnalyser.fftSize = 256;
          liveAnalyser.smoothingTimeConstant = 0.8;
          source.connect(liveAnalyser);

          log('Web Audio API setup complete');

          var placeholder = recorderBody.querySelector('#live-placeholder');
          if (placeholder) placeholder.remove();

          var existingCanvas = recorderBody.querySelector('.live-waveform');
          if (existingCanvas) existingCanvas.remove();

          liveWaveformCanvas = document.createElement('canvas');
          liveWaveformCanvas.className = 'live-waveform';
          liveWaveformCanvas.style.cssText = 'width:100%;height:60px;border-radius:8px;background:rgba(255,255,255,0.03);border:1px solid var(--stroke);display:block;';
          recorderBody.appendChild(liveWaveformCanvas);

          getCanvasSize(liveWaveformCanvas);
          log('Canvas created');

          var existingStats = recorderBody.querySelector('#live-stats');
          if (existingStats) existingStats.remove();

          var liveStats = document.createElement('div');
          liveStats.id = 'live-stats';
          liveStats.style.cssText = 'display:flex;justify-content:space-between;margin-top:12px;font-size:14px;color:var(--accent);';
          liveStats.innerHTML = '<span>Recording chunk: <strong id="current-chunk">1</strong></span>' +
                               '<span>Total time: <strong id="total-time">00:00</strong></span>' +
                               '<span>Chunks recorded: <strong id="chunk-count">0</strong></span>';
          recorderBody.appendChild(liveStats);

          // Add transcription display
          transcriptDisplay = document.createElement('div');
          transcriptDisplay.id = 'transcription-display';
          transcriptDisplay.className = 'transcription-display empty';
          transcriptDisplay.innerHTML = '<div style="margin-bottom:6px;font-weight:600;color:var(--accent);">Live Transcription</div>' +
                                       '<div style="opacity:0.7;">Transcription will appear here...</div>';
          recorderBody.appendChild(transcriptDisplay);

          startLiveWaveform();
        } catch (error) {
          log('Error setting up live waveform:', error.message);
        }
      }

      function startLiveWaveform() {
        if (!liveAnalyser || !liveWaveformCanvas) return;

        log('Starting live waveform animation...');

        var ctx = liveWaveformCanvas.getContext('2d');
        var bufferLength = liveAnalyser.frequencyBinCount;
        var dataArray = new Uint8Array(bufferLength);

        function drawLiveWaveform() {
          if (!running) return;

          liveAnimationId = requestAnimationFrame(drawLiveWaveform);
          liveAnalyser.getByteFrequencyData(dataArray);

          var size = getCanvasSize(liveWaveformCanvas);
          var W = size.W, H = size.H;

          if (W === 0 || H === 0) return;

          ctx.clearRect(0, 0, W, H);

          var barWidth = Math.max(2, (W / bufferLength) * 2);
          var barHeight;
          var x = 0;

          var hasAudio = false;
          for (var j = 0; j < bufferLength; j++) {
            if (dataArray[j] > 10) {
              hasAudio = true;
              break;
            }
          }

          if (!hasAudio) {
            ctx.fillStyle = '#35e0ff';
            ctx.fillRect(0, H - 2, W, 2);
          } else {
            for (var i = 0; i < bufferLength; i++) {
              barHeight = Math.max(2, (dataArray[i] / 255) * H * 0.8);

              if (dataArray[i] > 128) {
                ctx.fillStyle = '#3be38a';
              } else {
                ctx.fillStyle = '#35e0ff';
              }

              ctx.fillRect(x, H - barHeight, barWidth, barHeight);

              x += barWidth + 1;
              if (x >= W) break;
            }
          }
        }

        drawLiveWaveform();
      }

      function stopLiveWaveform() {
        if (liveAnimationId) {
          cancelAnimationFrame(liveAnimationId);
          liveAnimationId = null;
        }
        if (liveWaveformCanvas) {
          liveWaveformCanvas.remove();
          liveWaveformCanvas = null;
        }

        var liveStats = $('live-stats');
        if (liveStats) liveStats.remove();

        if (transcriptDisplay) {
          transcriptDisplay.remove();
          transcriptDisplay = null;
        }

        var placeholder = document.createElement('div');
        placeholder.id = 'live-placeholder';
        placeholder.style.cssText = 'text-align:center;padding:20px;color:var(--muted);border:2px dashed var(--stroke);border-radius:8px;';
        placeholder.innerHTML = '<div style="font-size:18px;margin-bottom:8px;">üéôÔ∏è</div>' +
                               '<div>Click "Start Recording" to see live waveform and transcription</div>';
        recorderBody.appendChild(placeholder);

        liveAnalyser = null;
      }

      // WhisperLive WebSocket connection
      async function connectWhisperLive(stream) {
        try {
          log('Connecting to WhisperLive...');

          const wsUrl = `wss://${window.location.host}/ws`;
          ws = new WebSocket(wsUrl);

          ws.onopen = async () => {
            log('WhisperLive WebSocket connected');

            const config = {
              uid: 'browser-' + Date.now(),
              task: 'transcribe',
              language: 'en',
              model: 'Systran/faster-whisper-small.en',
              use_vad: true,
              word_timestamps: true  // Request word-level timestamps from WhisperLive
            };
            console.log('%cüì§ Sending WhisperLive Config:', 'font-weight:bold;color:#00d4ff;', config);
            ws.send(JSON.stringify(config));
            log('Sent config to WhisperLive');

            // Set up audio streaming to WhisperLive
            whisperAudioContext = new (window.AudioContext || window.webkitAudioContext)({
              sampleRate: 16000
            });
            whisperSource = whisperAudioContext.createMediaStreamSource(stream);
            whisperProcessor = whisperAudioContext.createScriptProcessor(4096, 1, 1);

            whisperProcessor.onaudioprocess = (e) => {
              if (!running || ws.readyState !== WebSocket.OPEN) return;
              const audioData = e.inputBuffer.getChannelData(0);
              ws.send(audioData.buffer);
            };

            whisperSource.connect(whisperProcessor);
            whisperProcessor.connect(whisperAudioContext.destination);

            log('Audio streaming to WhisperLive started');
          };

          ws.onmessage = (event) => {
            try {
              const data = JSON.parse(event.data);

              if (data.segments && data.segments.length > 0) {
                for (const segment of data.segments) {
                  const text = segment.text || '';
                  const isFinal = segment.completed === true;
                  const start = parseFloat(segment.start || 0);
                  const end = parseFloat(segment.end || 0);

                  // DEBUG: Log full segment data to see what's available
                  console.log('üìä WhisperLive Segment:', {
                    text: text.substring(0, 50),
                    start: start.toFixed(3),
                    end: end.toFixed(3),
                    duration: (end - start).toFixed(3),
                    completed: isFinal,
                    hasWords: !!segment.words,
                    wordCount: segment.words ? segment.words.length : 0,
                    allKeys: Object.keys(segment)
                  });

                  // If word-level timestamps exist, log them
                  if (segment.words && segment.words.length > 0) {
                    // One-time celebration when we first get word data
                    if (!window.wordDataReceived) {
                      window.wordDataReceived = true;
                      console.log('%cüéâ SUCCESS! Word-level timestamps are working!', 'font-size:16px;font-weight:bold;color:#3be38a;background:#0b1220;padding:8px;');
                    }
                    console.log('üìù Word-level timestamps:', segment.words.map(w => ({
                      word: w.word || w.text,
                      start: w.start ? w.start.toFixed(3) : 'N/A',
                      end: w.end ? w.end.toFixed(3) : 'N/A',
                      probability: w.probability ? w.probability.toFixed(2) : 'N/A'
                    })));
                  }

                  // Deduplication for finals
                  if (isFinal && end <= lastCommittedTimestamp) {
                    console.log(`‚è≠Ô∏è Skipping duplicate final`);
                    continue;
                  }

                  if (text.trim()) {
                    updateTranscription(text, isFinal, start, end, segment.words);

                    if (isFinal && end > lastCommittedTimestamp) {
                      lastCommittedTimestamp = end;
                    }
                  }
                }
              } else if (data.message === 'SERVER_READY') {
                log('WhisperLive ready');
              } else if (data.type === 'error') {
                log('WhisperLive error:', data.message);
              }
            } catch (e) {
              console.error('Failed to parse WhisperLive message:', e);
            }
          };

          ws.onerror = (error) => {
            log('WhisperLive WebSocket error:', error);
          };

          ws.onclose = (event) => {
            log('WhisperLive WebSocket closed:', event.code);
          };

        } catch (error) {
          log('Failed to connect to WhisperLive:', error.message);
        }
      }

      function updateTranscription(text, isFinal, start, end, words) {
        if (!transcriptDisplay) return;

        if (transcriptDisplay.classList.contains('empty')) {
          transcriptDisplay.classList.remove('empty');
          transcriptDisplay.innerHTML = '<div style="margin-bottom:6px;font-weight:600;color:var(--accent);">Live Transcription</div>';
        }

        if (isFinal) {
          transcriptAccumulator.ingestFinal(text);

          // Store in global array for chunk association
          if (start !== undefined && end !== undefined) {
            transcriptionSegments.push({
              text: text,
              start: start,
              end: end,
              words: words || []
            });

            // Save to IndexedDB for persistence
            if (currentSession && window.audioStorage) {
              window.audioStorage.saveTranscription(
                currentSession.id,
                text,
                start,
                end,
                words || [],
                true  // completed = true for finals
              ).catch(err => {
                console.error('Failed to save transcription:', err);
              });
            }
          }

          const entry = document.createElement('div');
          entry.className = 'transcript-entry final';

          // Add timestamp info if available
          if (start !== undefined && end !== undefined) {
            const timestampSpan = document.createElement('div');
            timestampSpan.style.cssText = 'font-size:11px;color:var(--muted);margin-bottom:4px;';
            timestampSpan.textContent = `${start.toFixed(2)}s ‚Üí ${end.toFixed(2)}s (${(end - start).toFixed(2)}s)`;
            entry.appendChild(timestampSpan);
          }

          const textDiv = document.createElement('div');
          textDiv.textContent = text;
          entry.appendChild(textDiv);

          // Store word-level timestamps if available (for later use)
          if (words && words.length > 0) {
            entry.dataset.words = JSON.stringify(words);
            console.log('‚úÖ Stored word-level timestamps for segment:', words.length, 'words');
          }

          transcriptDisplay.appendChild(entry);

          // Update all existing chunks with new transcription
          updateChunkTranscriptions();
        } else {
          const result = transcriptAccumulator.ingestPartial(text);

          // Update or create partial entry
          let partialEntry = transcriptDisplay.querySelector('.transcript-entry.partial');
          if (!partialEntry) {
            partialEntry = document.createElement('div');
            partialEntry.className = 'transcript-entry partial';
            transcriptDisplay.appendChild(partialEntry);
          }

          // Add timestamp for partials too
          let content = '';
          if (start !== undefined && end !== undefined) {
            content = `<div style="font-size:11px;color:var(--muted);margin-bottom:4px;">${start.toFixed(2)}s ‚Üí ${end.toFixed(2)}s</div>`;
          }
          content += `<div>${text}</div>`;
          partialEntry.innerHTML = content;

          if (result.slideDetected && result.rescuedText) {
            // Create final entry for rescued text
            const rescuedEntry = document.createElement('div');
            rescuedEntry.className = 'transcript-entry final';
            rescuedEntry.textContent = result.rescuedText;
            transcriptDisplay.insertBefore(rescuedEntry, partialEntry);
          }
        }

        transcriptDisplay.scrollTop = transcriptDisplay.scrollHeight;
      }

      // Helper: Calculate overlap percentage between chunk and segment
      function calculateOverlap(chunkStart, chunkEnd, segStart, segEnd) {
        // Find intersection
        var overlapStart = Math.max(chunkStart, segStart);
        var overlapEnd = Math.min(chunkEnd, segEnd);
        var overlapDuration = Math.max(0, overlapEnd - overlapStart);

        // Calculate as percentage of segment duration
        var segmentDuration = segEnd - segStart;
        if (segmentDuration === 0) return 0;

        var overlapPercent = (overlapDuration / segmentDuration) * 100;
        return overlapPercent;
      }

      // Helper: Get timing offset description
      function getOffsetDescription(chunkStart, chunkEnd, segStart, segEnd) {
        var segMidpoint = (segStart + segEnd) / 2;
        var chunkMidpoint = (chunkStart + chunkEnd) / 2;
        var offset = segMidpoint - chunkMidpoint;

        var absOffset = Math.abs(offset);
        var direction = offset > 0 ? 'LATE' : 'EARLY';

        if (absOffset < 0.5) {
          return 'ON TIME';
        } else {
          return (offset > 0 ? '+' : '') + offset.toFixed(2) + 's ' + direction;
        }
      }

      // Helper: Get match quality based on overlap percentage
      function getMatchQuality(overlapPercent) {
        if (overlapPercent >= 80) {
          return { color: '#3be38a', emoji: 'üü¢', label: 'Perfect', bgColor: 'rgba(59,227,138,0.1)' };
        } else if (overlapPercent >= 50) {
          return { color: '#fbbf24', emoji: 'üü°', label: 'Good', bgColor: 'rgba(251,191,36,0.1)' };
        } else if (overlapPercent >= 20) {
          return { color: '#fb923c', emoji: 'üü†', label: 'Partial', bgColor: 'rgba(251,146,60,0.1)' };
        } else {
          return { color: '#ff6b6b', emoji: 'üî¥', label: 'Weak', bgColor: 'rgba(255,107,107,0.1)' };
        }
      }

      // Word highlighting: Sync audio playback with word highlighting
      function setupWordHighlighting(audioEl, chunk) {
        var chunkStartTime = parseFloat(chunk.dataset.startTime);
        var highlightInterval = null;

        console.log('[WORD-HIGHLIGHT] Setup called for chunk', {
          chunkIndex: chunk.dataset.chunkIndex,
          chunkStartTime: chunkStartTime,
          hasAudioElement: !!audioEl
        });

        function updateWordHighlights() {
          try {
            // Calculate absolute time from chunk start + audio current time
            var absoluteTime = chunkStartTime + audioEl.currentTime;

            // Find all word spans in this chunk's transcription
            var container = chunk.querySelector('.chunk-transcription');
            if (!container) return;

            var words = container.querySelectorAll('.word');
            if (words.length === 0) {
              console.log('[WORD-HIGHLIGHT] No word spans found in chunk transcription');
              return;
            }

            // Clear all highlights first
            words.forEach(function(word) {
              word.classList.remove('active');
            });

            // Find and highlight active word(s)
            words.forEach(function(word) {
              var wordStart = parseFloat(word.dataset.start);
              var wordEnd = parseFloat(word.dataset.end);

              if (isNaN(wordStart) || isNaN(wordEnd)) return;

              // Check if current time is within this word's range
              if (absoluteTime >= wordStart && absoluteTime <= wordEnd) {
                word.classList.add('active');

                // Debug logging
                console.log('[WORD-HIGHLIGHT]', {
                  audioTime: audioEl.currentTime.toFixed(2),
                  chunkStart: chunkStartTime.toFixed(2),
                  absoluteTime: absoluteTime.toFixed(2),
                  word: word.textContent,
                  wordRange: wordStart.toFixed(2) + 's ‚Üí ' + wordEnd.toFixed(2) + 's',
                  delta: (absoluteTime - wordStart).toFixed(2) + 's into word'
                });
              }
            });
          } catch (error) {
            console.error('Word highlighting error:', error);
          }
        }

        // Start highlighting when audio plays
        audioEl.addEventListener('play', function() {
          var container = chunk.querySelector('.chunk-transcription');
          var wordCount = container ? container.querySelectorAll('.word').length : 0;
          console.log('[WORD-HIGHLIGHT] Audio playing, starting highlights', {
            chunkIndex: chunk.dataset.chunkIndex,
            wordSpansFound: wordCount,
            chunkStartTime: chunkStartTime
          });
          // Use interval for smoother updates (every 100ms)
          highlightInterval = setInterval(updateWordHighlights, 100);
          updateWordHighlights(); // Immediate update
        });

        // Update on timeupdate as backup
        audioEl.addEventListener('timeupdate', updateWordHighlights);

        // Clear highlights when paused or ended
        audioEl.addEventListener('pause', function() {
          console.log('[WORD-HIGHLIGHT] Audio paused, clearing highlights');
          if (highlightInterval) {
            clearInterval(highlightInterval);
            highlightInterval = null;
          }
          var container = chunk.querySelector('.chunk-transcription');
          if (container) {
            container.querySelectorAll('.word').forEach(function(word) {
              word.classList.remove('active');
            });
          }
        });

        audioEl.addEventListener('ended', function() {
          console.log('[WORD-HIGHLIGHT] Audio ended, clearing highlights');
          if (highlightInterval) {
            clearInterval(highlightInterval);
            highlightInterval = null;
          }
          var container = chunk.querySelector('.chunk-transcription');
          if (container) {
            container.querySelectorAll('.word').forEach(function(word) {
              word.classList.remove('active');
            });
          }
        });
      }

      // Helper: Wrap words in spans with timing data for highlighting
      // Only wraps words that fall within the chunk's time boundaries
      function wrapWordsInSpans(segment, chunkStart, chunkEnd) {
        if (!segment.words || segment.words.length === 0) {
          // No word-level data, return plain text
          console.log('[WRAP-WORDS] No words in segment:', {
            hasWords: !!segment.words,
            wordCount: segment.words ? segment.words.length : 0,
            text: segment.text ? segment.text.substring(0, 50) : 'N/A'
          });
          return segment.text;
        }

        console.log('[WRAP-WORDS] Wrapping words:', {
          wordCount: segment.words.length,
          segmentTime: segment.start.toFixed(2) + 's ‚Üí ' + segment.end.toFixed(2) + 's',
          chunkTime: chunkStart.toFixed(2) + 's ‚Üí ' + chunkEnd.toFixed(2) + 's'
        });

        // IMPORTANT: Word timestamps from WhisperLive are SEGMENT-RELATIVE, not absolute!
        // We must add the segment's start time to get absolute timestamps.
        var segmentStartTime = parseFloat(segment.start);

        // Filter and wrap only words that fall within chunk boundaries (with small tolerance)
        var WORD_TOLERANCE = 0.5; // Allow words up to 0.5s outside chunk boundaries

        var wrappedParts = segment.words.map(function(word) {
          var wordText = word.word || word.text || '';
          var wordStartRelative = parseFloat(word.start) || 0; // 'N/A' or missing ‚Üí 0
          var wordEndRelative = parseFloat(word.end) || 0;

          // Convert segment-relative times to ABSOLUTE times
          var wordStartAbsolute = segmentStartTime + wordStartRelative;
          var wordEndAbsolute = segmentStartTime + wordEndRelative;

          // Check if this word falls within the chunk's time range
          var wordMidpoint = (wordStartAbsolute + wordEndAbsolute) / 2;
          var inChunkRange = (wordMidpoint >= chunkStart - WORD_TOLERANCE) &&
                             (wordMidpoint <= chunkEnd + WORD_TOLERANCE);

          if (inChunkRange) {
            // Word is in range - wrap it with highlighting attributes (use ABSOLUTE times)
            return '<span class="word" data-start="' + wordStartAbsolute.toFixed(3) + '" data-end="' + wordEndAbsolute.toFixed(3) + '">' +
                   wordText + '</span>';
          } else {
            // Word is outside chunk range - show as plain text (no highlighting)
            return '<span style="color:var(--muted);opacity:0.6;">' + wordText + '</span>';
          }
        }).join(' ');

        return wrappedParts;
      }

      function updateChunkTranscriptions() {
        var TOLERANCE = 2.0;  // ¬±2 seconds tolerance

        // Find all chunk elements
        var chunks = document.querySelectorAll('.chunk');

        chunks.forEach(function(chunk) {
          var chunkStart = parseFloat(chunk.dataset.startTime);
          var chunkEnd = parseFloat(chunk.dataset.endTime);
          var chunkIndex = chunk.dataset.chunkIndex;

          if (isNaN(chunkStart) || isNaN(chunkEnd)) return;

          // Find transcription segments with tolerance
          var chunkTranscriptions = transcriptionSegments.filter(function(seg) {
            return (
              (seg.start >= chunkStart - TOLERANCE && seg.start < chunkEnd + TOLERANCE) ||
              (seg.end > chunkStart - TOLERANCE && seg.end <= chunkEnd + TOLERANCE) ||
              (seg.start <= chunkStart && seg.end >= chunkEnd)
            );
          });

          // Sort by start time
          chunkTranscriptions.sort(function(a, b) { return a.start - b.start; });

          // Update the transcription container
          var container = chunk.querySelector('.chunk-transcription');
          if (!container) return;

          if (chunkTranscriptions.length === 0) {
            container.innerHTML = '<span style="color:var(--muted);font-style:italic;">No transcription for this time range</span>';
          } else {
            // Build transcription display with color coding
            var html = '';

            chunkTranscriptions.forEach(function(seg) {
              var overlapPercent = calculateOverlap(chunkStart, chunkEnd, seg.start, seg.end);
              var offsetDesc = getOffsetDescription(chunkStart, chunkEnd, seg.start, seg.end);
              var quality = getMatchQuality(overlapPercent);

              // Console logging for debugging
              console.log('[CHUNK-MATCH]', {
                chunk: 'seg-' + chunkIndex,
                chunkWindow: chunkStart.toFixed(2) + 's ‚Üí ' + chunkEnd.toFixed(2) + 's',
                segment: seg.start.toFixed(2) + 's ‚Üí ' + seg.end.toFixed(2) + 's',
                text: seg.text.substring(0, 30),
                overlap: overlapPercent.toFixed(1) + '%',
                offset: offsetDesc,
                quality: quality.label,
                hasWords: !!(seg.words && seg.words.length > 0),
                wordCount: seg.words ? seg.words.length : 0
              });

              // Build HTML with color coding
              var timeLabel = '<span style="color:' + quality.color + ';font-size:11px;font-weight:600;">' +
                              quality.emoji + ' ' + seg.start.toFixed(2) + 's ‚Üí ' + seg.end.toFixed(2) + 's</span>';

              var metaInfo = '<span style="color:var(--muted);font-size:10px;margin-left:8px;">' +
                            overlapPercent.toFixed(0) + '% overlap, ' + offsetDesc + '</span>';

              // Wrap words in spans for highlighting (only words within chunk boundaries)
              var wrappedText = wrapWordsInSpans(seg, chunkStart, chunkEnd);

              html += '<div class="transcription-segment" style="margin-bottom:6px;padding:6px;background:' + quality.bgColor +
                      ';border-left:3px solid ' + quality.color + ';border-radius:4px;" ' +
                      'data-seg-start="' + seg.start.toFixed(3) + '" data-seg-end="' + seg.end.toFixed(3) + '">' +
                      timeLabel + metaInfo + '<br>' +
                      '<span style="margin-left:20px;">' + wrappedText + '</span>' +
                      '</div>';
            });

            container.innerHTML = html;
            container.style.fontStyle = 'normal';
          }
        });
      }

      function disconnectWhisperLive() {
        if (whisperProcessor) {
          whisperProcessor.disconnect();
          whisperProcessor = null;
        }
        if (whisperSource) {
          whisperSource.disconnect();
          whisperSource = null;
        }
        if (whisperAudioContext) {
          whisperAudioContext.close();
          whisperAudioContext = null;
        }
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.close();
        }
        ws = null;
      }

      async function start(){
        if (running) return;
        log('Start clicked');

        var SLICE_MS = Math.max(1000, Number(timesliceInput.value) || 5000);

        try {
          if (window.audioStorage) {
            currentSession = await window.audioStorage.createSession({
              chunkDuration: SLICE_MS,
              mimeType: chooseMime()
            });
            log('Created session:', currentSession.id);
          }

          const stream = await navigator.mediaDevices.getUserMedia({ audio:true });

          mediaStream = stream;
          dot.classList.remove('danger');
          dot.classList.add('good');
          running = true;
          startBtn.disabled = true;
          stopBtn.disabled = false;
          palStart.classList.add('hidden');
          palStop.classList.remove('hidden');

          preferredMime = chooseMime();
          log('Recording started');

          // Reset transcription state
          transcriptAccumulator.reset();
          lastCommittedTimestamp = 0;
          transcriptionSegments = [];

          startUI();
          setupLiveWaveform(stream);
          connectWhisperLive(stream);

          var OVERLAP_MS = Math.max(0, Number(overlapInput.value) || 500);

          var loop = function(){
            if (!running) return;
            var idx = ++chunkIndex;
            var chunkStartTime = Date.now();
            chunkStartTimes[idx - 1] = chunkStartTime;

            var currentChunkEl = $('current-chunk');
            if (currentChunkEl) currentChunkEl.textContent = idx;

            recordOverlappingChunk(mediaStream, SLICE_MS, OVERLAP_MS, preferredMime, function(blob, actualDuration){
              log('Got chunk', idx, (blob.type||'audio/*'), (blob.size||0) + 'B');
              renderChunk(blob, idx, actualDuration);
            });

            if (running) {
              chunkTimer = setTimeout(loop, SLICE_MS);
            }
          };

          loop();
        } catch(err) {
          log('Error starting recording:', err && (err.message || String(err)));
          dot.classList.add('danger');
        }
      }

      async function stop(){
        if (!running) return;
        running = false;
        if (chunkTimer){ clearTimeout(chunkTimer); chunkTimer = null; }

        stopAllRecorders();
        disconnectWhisperLive();

        if (mediaStream){ mediaStream.getTracks().forEach(function(t){ t.stop(); }); mediaStream = null; }
        dot.classList.remove('good');
        startBtn.disabled = false;
        stopBtn.disabled = true;
        palStart.classList.remove('hidden');
        palStop.classList.add('hidden');
        log('Stopped');

        stopLiveWaveform();

        if (currentSession && window.audioStorage) {
          try {
            const finalDuration = startedAt ? ((Date.now() - startedAt) / 1000) : 0;
            await window.audioStorage.updateSession(currentSession.id, {
              status: 'completed',
              totalDuration: finalDuration,
              chunkCount: chunkIndex
            });
            log('Session completed');
            updateStorageStatus();
          } catch (error) {
            log('Error updating session:', error.message);
          }
        }

        stopUI();
      }

      function clearList(){
        list.innerHTML = '';
        chunkIndex = 0;
        completedChunks = 0;
        chunkStartTimes = [];
        transcriptionSegments = [];
        log('Cleared');
      }

      async function updateStorageStatus() {
        if (!window.audioStorage || !storageStatus) return;

        try {
          const usage = await window.audioStorage.getStorageUsage();
          const sessions = await window.audioStorage.getAllSessions();

          storageStatus.textContent = `Storage: ${usage.usedMB}MB used ‚Ä¢ ${sessions.length} sessions`;
        } catch (error) {
          storageStatus.textContent = 'Storage: Error';
        }
      }

      function tick(){
        if(!startedAt) return;
        const secs = (Date.now()-startedAt)/1000|0;
        const chunkText = completedChunks > 0 ? ` ‚Ä¢ ${completedChunks} chunks` : '';
        elapsedEl.textContent = fmt(secs) + chunkText;

        if (running) {
          var totalTimeEl = $('total-time');
          if (totalTimeEl) totalTimeEl.textContent = fmt(secs);
        }
      }

      function startUI(){
        card.classList.add('active');
        confirmEl.classList.remove('open');
        startedAt = Date.now();
        if(timerId) clearInterval(timerId);
        timerId = setInterval(tick, 1000);
        tick();
      }

      function stopUI(){
        card.classList.remove('active');
        if(timerId) { clearInterval(timerId); timerId = null; }
        const dur = startedAt ? ((Date.now()-startedAt)/1000|0) : 0;
        startedAt = null;

        const msg = `${chunkIndex} audio chunks recorded ‚Ä¢ Duration ${fmt(dur)}`;
        confirmDetails.textContent = msg;
        confirmEl.classList.add('open');
      }

      function togglePalette(force){
        const open = force ?? !palette.classList.contains('open');
        palette.classList.toggle('open', open);
        if(open) $('palette-input')?.focus();
      }

      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
        log('ERROR: getUserMedia not supported');
      }
      if (!window.MediaRecorder){
        log('ERROR: MediaRecorder not supported');
      }

      startBtn.addEventListener('click', start);
      stopBtn.addEventListener('click', stop);
      palStart.addEventListener('click', start);
      palStop.addEventListener('click', stop);
      clearBtn?.addEventListener('click', clearList);
      confirmClose.addEventListener('click', ()=> confirmEl.classList.remove('open'));

      window.addEventListener('keydown', (e)=>{
        const mod = e.ctrlKey || e.metaKey;
        if(mod && (e.key.toLowerCase() === 'k')){
          e.preventDefault();
          togglePalette();
        }
      });

      // Load most recent session from IndexedDB
      async function loadRecentSession() {
        try {
          log('Loading recent session from IndexedDB...');

          const sessions = await window.audioStorage.getAllSessions();
          if (sessions.length === 0) {
            log('No previous sessions found');
            return;
          }

          // Get most recent session (already sorted by timestamp desc)
          const recentSession = sessions[0];
          log('Loading session:', recentSession.id, 'from', recentSession.created);

          // Get all chunks for this session
          const chunks = await window.audioStorage.getChunksBySession(recentSession.id);
          if (chunks.length === 0) {
            log('No chunks found in session');
            return;
          }

          log('Found', chunks.length, 'chunks to restore');

          // Get all transcriptions for this session
          const transcriptions = await window.audioStorage.getTranscriptionsBySession(recentSession.id);
          log('Found', transcriptions.length, 'transcriptions to restore');

          // Rebuild transcriptionSegments array from stored data
          transcriptionSegments = transcriptions.map(t => ({
            text: t.text,
            start: t.start,
            end: t.end,
            words: t.words || []
          }));

          // Load chunks in reverse order (newest first in UI)
          for (let i = chunks.length - 1; i >= 0; i--) {
            const chunk = chunks[i];
            await restoreChunk(chunk);
          }

          completedChunks = chunks.length;

          // Update all chunks with restored transcriptions
          if (transcriptions.length > 0) {
            updateChunkTranscriptions();
            log('‚úÖ Restored', transcriptions.length, 'transcriptions with color coding');
          }

          log('‚úÖ Restored', chunks.length, 'chunks from previous session');

        } catch (error) {
          log('Error loading recent session:', error.message);
        }
      }

      // Restore a single chunk from IndexedDB
      async function restoreChunk(chunk) {
        try {
          const blob = chunk.blob;
          const idx = chunk.chunkIndex;
          const duration = chunk.duration;

          // Calculate timing from stored timestamp
          var chunkStartTime = chunk.timestamp;
          var startOffset = 0; // We don't have recording start time, so use relative
          var endOffset = duration;

          // Create chunk UI elements
          var row = document.createElement('div');
          row.className = 'chunk';

          var top = document.createElement('div');
          top.className = 'chunk-header';

          var meta = document.createElement('div');
          meta.className = 'meta';

          meta.innerHTML = 'seg-' + pad3(idx) + ' (' + (blob.type || 'audio') + ')<br>' +
                           '<span style="color:var(--accent);font-size:11px;">' +
                           'Loaded from storage (' + Math.round(blob.size / 1024) + 'KB)</span>';

          var audioEl = document.createElement('audio');
          var localUrl = URL.createObjectURL(blob);
          audioEl.controls = true;
          audioEl.preload = 'metadata';
          audioEl.src = localUrl;
          audioEl.className = 'chunk-audio';

          top.appendChild(meta);
          top.appendChild(audioEl);

          var shell = document.createElement('div');
          shell.className = 'waveform-shell';

          var canvas = document.createElement('canvas');
          canvas.className = 'waveform-canvas';
          shell.appendChild(canvas);

          // Create transcription container
          var transcriptionContainer = document.createElement('div');
          transcriptionContainer.className = 'chunk-transcription';
          transcriptionContainer.style.cssText = 'margin-top:8px;padding:8px;background:rgba(0,0,0,0.2);border-radius:6px;min-height:24px;font-size:13px;line-height:1.5;color:var(--text);border:1px solid var(--stroke);';
          transcriptionContainer.innerHTML = '<span style="color:var(--muted);font-style:italic;">No transcription saved for this chunk</span>';

          // Store chunk timing data
          row.dataset.chunkIndex = idx;
          row.dataset.startTime = startOffset.toFixed(3);
          row.dataset.endTime = endOffset.toFixed(3);

          row.appendChild(top);
          row.appendChild(shell);
          row.appendChild(transcriptionContainer);

          // Add to list (append since we're going in reverse)
          list.appendChild(row);

          // Render waveform
          renderWaveform(canvas, audioEl, blob);

          // Setup word-level highlighting for restored chunk
          setupWordHighlighting(audioEl, row);

        } catch (error) {
          log('Error restoring chunk:', error.message);
        }
      }

      console.log('%cüé§ Audio Recorder v5.1.0-word-highlighting', 'font-size:16px;font-weight:bold;color:#3be38a;');
      console.log('%c‚úÖ Word-level karaoke highlighting fully operational!', 'font-size:12px;color:#3be38a;');
      console.log('%cüîß Server patches: word_timestamps enabled + word extraction', 'font-size:12px;color:#ff9500;');
      console.log('%cüîß CRITICAL FIX: Word timestamps are segment-relative! Now converting to absolute.', 'font-size:14px;font-weight:bold;color:#fbbf24;');
      console.log('%c‚ö†Ô∏è  OLD SESSIONS HAVE WRONG DATA - Record a NEW session to see fix!', 'font-size:13px;font-weight:bold;color:#ff6b6b;background:#1a0000;padding:4px;');
      console.log('‚úÖ Word-level highlighting enabled');
      console.log('üìñ Features: IndexedDB persistence, color-coded timing, karaoke highlighting');
      log('UI ready');

      if (window.audioStorage) {
        window.audioStorage.init().then(async () => {
          log('IndexedDB initialized');
          updateStorageStatus();
          storageStatus.textContent = 'Storage: Ready';

          // Load recent session after IndexedDB is ready
          await loadRecentSession();
        }).catch(error => {
          log('IndexedDB initialization failed:', error.message);
          storageStatus.textContent = 'Storage: Failed';
        });
      } else {
        log('Storage not available');
        storageStatus.textContent = 'Storage: Not available';
      }
    })();
  </script>
</body>
</html>
